<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coffee, Coke and Code</title>
    <description>Archive diabloneo's articles.
</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 30 Sep 2017 22:37:20 +0800</pubDate>
    <lastBuildDate>Sat, 30 Sep 2017 22:37:20 +0800</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>Uber Jaeger介绍</title>
        <description>&lt;h1 id=&quot;jaeger加入cncf&quot;&gt;Jaeger加入CNCF&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Jaeger&lt;/strong&gt;是 &lt;em&gt;Uber&lt;/em&gt;开源的 &lt;strong&gt;&lt;a href=&quot;http://opentracing.io/&quot;&gt;OpenTracing&lt;/a&gt;&lt;/strong&gt;实现，包括客户端和服务端。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;项目地址: &lt;a href=&quot;https://github.com/jaegertracing/jaeger/&quot;&gt;https://github.com/jaegertracing/jaeger/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;项目文档: &lt;a href=&quot;http://jaeger.readthedocs.io/en/latest/&quot;&gt;http://jaeger.readthedocs.io/en/latest/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jaeger项目4月14日开源，9月13日被 &lt;em&gt;CNCF&lt;/em&gt;接受成为第12个托管项目, &lt;a href=&quot;https://www.cncf.io/blog/2017/09/13/cncf-hosts-jaeger/&quot;&gt;CNCF Hosts Jaeger&lt;/a&gt;。CNCF托管的其他11个项目是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Kubernetes&lt;/li&gt;
  &lt;li&gt;Prometheus&lt;/li&gt;
  &lt;li&gt;OpenTracing&lt;/li&gt;
  &lt;li&gt;Fluentd&lt;/li&gt;
  &lt;li&gt;Linkerd&lt;/li&gt;
  &lt;li&gt;gRPC&lt;/li&gt;
  &lt;li&gt;CoreDNS&lt;/li&gt;
  &lt;li&gt;containerd&lt;/li&gt;
  &lt;li&gt;rkt&lt;/li&gt;
  &lt;li&gt;CNI&lt;/li&gt;
  &lt;li&gt;Envoy&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;jaeger架构&quot;&gt;Jaeger架构&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Jaeger&lt;/em&gt;的架构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/imgs/00018_uber_jaeger_architecture.png&quot; alt=&quot;Jaeger Architecture&quot; /&gt;
&lt;em&gt;图片来自http://jaeger.readthedocs.io/en/latest/architecture/&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Jaeger的架构很简洁：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在每个服务器上运行 &lt;em&gt;jaeger-agent&lt;/em&gt;，用于收集本服务器的信息，然后发送给 &lt;em&gt;jaeger-collector&lt;/em&gt;。&lt;/li&gt;
  &lt;li&gt;每个服务都嵌入 &lt;em&gt;jaeger-client&lt;/em&gt;，这是一个客户端，会把服务的请求处理的tracing信息发送给 &lt;em&gt;jaeger-agent&lt;/em&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;jaeger-collector&lt;/em&gt;是一个中心化的服务端，用于收集 &lt;em&gt;jaeger-agent&lt;/em&gt;发送过来的tracing信息进行处理后存储到数据库中（目前只支持Cassandra）。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;jaeger-query&lt;/em&gt;是一个查询服务，对外保护tracing信息的查询API。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;jaeger-ui&lt;/em&gt;是一个浏览器客户端。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;jaeger的demo&quot;&gt;Jaeger的demo&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Jaeger&lt;/em&gt;项目的leader写了一篇很好的文章来介绍Jaeger的使用 &lt;a href=&quot;https://medium.com/opentracing/take-opentracing-for-a-hotrod-ride-f6e3141f7941&quot;&gt;Take OpenTracing for a HotROD ride&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;文中演示了查看服务的架构，查看请求的详细构成，定位延迟原因等基本用法。还介绍了span，基于上下文的log，tag，OpenTracing baggage等概念。要了解 &lt;em&gt;Jaeger&lt;/em&gt;能做什么，可以从这篇文章开始。&lt;/p&gt;

&lt;p&gt;这个demo项目是用了 &lt;em&gt;Uber&lt;/em&gt;的 &lt;strong&gt;&lt;a href=&quot;https://github.com/uber/tchannel&quot;&gt;TChannel&lt;/a&gt;&lt;/strong&gt;来实现微服务的RPC，它已经和OpenTracing做了集成，用起来很方便。另外一个流行的rpc框架 &lt;strong&gt;gRPC&lt;/strong&gt;也已经和OpenTracing进行了集成。&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Sep 2017 00:00:00 +0800</pubDate>
        <link>/2017/09/30/uber-jaeger-introduction.html</link>
        <guid isPermaLink="true">/2017/09/30/uber-jaeger-introduction.html</guid>
        
        
      </item>
    
      <item>
        <title>Rob Pike's Go Proverb</title>
        <description>&lt;p&gt;&lt;img src=&quot;/assets/imgs/00017_rob_pike_go_proverb.png&quot; alt=&quot;Rob Pike&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Rob Pike在2015年的Gopherfest的演讲，题目是 &lt;em&gt;Go Proverbs&lt;/em&gt;. YouTube地址:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;amp;index=27&amp;amp;t=1s&amp;amp;list=WL&quot;&gt;Go Proverbs - Rob Pike - Gopherfest - November 18, 2015&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;他分享了他自己写的几条Go编程的格言，类似 &lt;em&gt;The Zen of Python&lt;/em&gt;，但是没那么正式，格言的列表如下，推荐看视频：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Don’t communicate by sharing memory, share memory by communicating.&lt;/li&gt;
  &lt;li&gt;Concurrency is not parallism.&lt;/li&gt;
  &lt;li&gt;Channels orchestrate; mutexes serialize.&lt;/li&gt;
  &lt;li&gt;The bigger the interface, the weaker the abstraction.&lt;/li&gt;
  &lt;li&gt;Make the zero value useful. (e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;bytes.Buffer&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;sync.Mutex&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;interface{}&lt;/code&gt; says nothing.&lt;/li&gt;
  &lt;li&gt;Gofmt’s style is no one’s favorite, yet gofmt is everyone’s favorite.&lt;/li&gt;
  &lt;li&gt;A little copying is better than a little dependency.&lt;/li&gt;
  &lt;li&gt;Syscall must always be guarded with build tags.&lt;/li&gt;
  &lt;li&gt;Cgo must always be guarded with build tags.&lt;/li&gt;
  &lt;li&gt;Cgo is not Go. (他说自己几乎不使用cgo)&lt;/li&gt;
  &lt;li&gt;With the &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe&lt;/code&gt; package, there are no guarantees.&lt;/li&gt;
  &lt;li&gt;Clear is better than clever.&lt;/li&gt;
  &lt;li&gt;Reflection is never clear.&lt;/li&gt;
  &lt;li&gt;Errors are values.&lt;/li&gt;
  &lt;li&gt;Don’t just check errors, handle them gracefully.&lt;/li&gt;
  &lt;li&gt;Design the architecture, name the components, document the details.&lt;/li&gt;
  &lt;li&gt;Documentation is for users.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 29 Sep 2017 00:00:00 +0800</pubDate>
        <link>/2017/09/29/rob-pike-go-proverb.html</link>
        <guid isPermaLink="true">/2017/09/29/rob-pike-go-proverb.html</guid>
        
        
      </item>
    
      <item>
        <title>SDC 2017 Day 3 General Session</title>
        <description>&lt;p&gt;&lt;img src=&quot;/assets/imgs/00016_sdc2017_day3.jpg&quot; alt=&quot;Day3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;今天SDC 2017进入第三天，早上还是General Session。&lt;/p&gt;

&lt;h1 id=&quot;impact-of-persistent-memory-on-ssds-and-fabrics&quot;&gt;Impact of Persistent Memory on SSDs and Fabrics&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/549928&quot;&gt;https://sniasdc17.pathable.com/meetings/549928&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;是一个联合介绍PM的session，三个公司分别介绍了他们在PM上的产品，具体的可以到他们官网上查看&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.everspin.com/&quot;&gt;https://www.everspin.com/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.newisys.com/&quot;&gt;http://www.newisys.com/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.mobiveil.com/&quot;&gt;http://www.mobiveil.com/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;linux-optimizations-for-low-latency-block-devices&quot;&gt;Linux Optimizations for Low Latency Block Devices&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/549964&quot;&gt;https://sniasdc17.pathable.com/meetings/549964&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Througput is easy, latency is hard&lt;/strong&gt;。存储的性能在不断的提升，但是软件层面要提高latency是很困难的。&lt;/p&gt;

&lt;p&gt;SPDK带来的latency降低有限，代价不小，不适用于普通的应用，比较适合专门做硬件的使用。kernel的I/O增加了polling机制，可以有效降低延迟，同时不增加应用的复杂度。一开始做的是不断的polling，会导致CPU 100%，后来增加了hybrid polling机制，cpu降低到58%的同时，I/O延迟和不断的polling是一样的。后续会继续改进，会在需要I/O结果时再做polling，可以进一步降低CPU。&lt;/p&gt;

&lt;h1 id=&quot;data-and-intelligence-in-storage&quot;&gt;Data and Intelligence in Storage&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/549932&quot;&gt;https://sniasdc17.pathable.com/meetings/549932&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Intel的广告，介绍了Intel Rack Scale Design。&lt;/p&gt;

&lt;h1 id=&quot;persistent-memory-new-tier-or-storage-replacement&quot;&gt;Persistent Memory: New Tier or Storage Replacement?&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/549982&quot;&gt;https://sniasdc17.pathable.com/meetings/549982&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个没听。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 Sep 2017 00:00:00 +0800</pubDate>
        <link>/2017/09/14/sdc-2017-3.html</link>
        <guid isPermaLink="true">/2017/09/14/sdc-2017-3.html</guid>
        
        
      </item>
    
      <item>
        <title>SDC 2017 Day 2 General Session</title>
        <description>&lt;p&gt;&lt;img src=&quot;/assets/imgs/00014_sdc2017_day2.jpg&quot; alt=&quot;Day2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;今天会议的第二天，上午是General Session。从现场看，参会人数大约150人。整个General Session包括4个Keynote。&lt;/p&gt;

&lt;h1 id=&quot;snia-20-years-of-storage-innovation-and-predictions-for-the-next-20-years&quot;&gt;SNIA: 20 Years of Storage Innovation and Predictions for the Next 20 Years&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/549880&quot;&gt;https://sniasdc17.pathable.com/meetings/549880&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;因为今年是SNIA 20周年，这个keynote紧扣20年这个周期，回顾了过去20周年的存储的发展以及SNIA在这期间的工作。&lt;/p&gt;

&lt;p&gt;Michael Qros特别强调了标准化的重要性，他举了供电系统作为例子。供电系统刚出现的时候没有标准话，而且建设之后很难再推倒重来，所以长期下来，现在供电系统就有2种不同的电压标准以及两种不同的频率标准（4种组合），以及15种不同的接口标准。这种缺失标准化的做法，导致解决供电问题的成本上升。所以SNIA在过去20年在存储方面做了很多标准化工作，将来也会继续推进存储的标准化工作。他也分享了SNIA在接下来的主要方向，包括：storage management, flash, persistent memory, cloud, green, object drives, security。&lt;/p&gt;

&lt;h1 id=&quot;memories-of-tomorrow&quot;&gt;Memories of Tomorrow&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/549938&quot;&gt;https://sniasdc17.pathable.com/meetings/549938&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;介绍了非易失性内存，作者称为storage class memory的最新进展。目前内存和存储的主要问题是：内存数据是易失的，存储的时延则太高。persistent memory（非易失存储内存）是目前被看好的解决方案。但是PM的推广和应用属于架构改变，需要这个计算机系统的严禁来配合，从BIOS到CPU到操作系统到应用软件都需要做出修改，才能充分发挥这种新技术的优势。作者认为SSD的推广和普及也是有类似的过程，不断改进的SATA，以及新出现的NVMe都是为了更好的发挥出SSD的能力。因为PM方面还有很多工作需要去做。&lt;/p&gt;

&lt;h1 id=&quot;goodbye-xfs-building-a-new-faster-storage-backend-for-ceph&quot;&gt;Goodbye, XFS: Building a new, faster storage backend for Ceph&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/550621&quot;&gt;https://sniasdc17.pathable.com/meetings/550621&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Sage Weil回顾了Ceph在store方面的历史。他最开始的直觉是要做一个文件系统，绕过POSIX，这样可以更好的作为存储的底层，所以在2008年之前，Ceph使用的是FakeStore + EBOFS。但是那个时候资源有限，Ceph的其他方面需要更多的投入，自己的文件系统无法做好，所以后来Ceph就转到了大家熟悉的FileStore + XFS + LevelDB的模式，利用已经成熟的解决方案来实现底层的数据存储。FileStore的主要问题是POSIX操作无法实现事务，所以就采用了double write的解决方案，也就有了double write的问题。他还分享了好几个FileStore的问题，都是由于POSIX接口并不适用于OSD的操作需求导致的。所以，Sage觉得实际上一开始自己做文件系统的方向是对的，现在Ceph项目壮大，开始有能力重新回到这个轨道上来，所以从2016年开始，BlueStore的研发就开始了，直到最近L版中正式product ready。最后Sage介绍了BlueStore中解决的几个主要问题，以及和FileStore的性能对比数据，BlueStore相对FileStore来说有很大的性能提升。&lt;/p&gt;

&lt;h1 id=&quot;recent-developments-in-the-linux-io-stack&quot;&gt;Recent Developments in The Linux I/O Stack&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/550618&quot;&gt;https://sniasdc17.pathable.com/meetings/550618&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;内核开发者Martin Petersen介绍了Linux从2013年到现在，在I/O栈方面的总体进展。他通过展示不通类型IO类型系统的开发活跃度来介绍Linux的开发重点。简单的总结一下，活跃度较高的是block层、SCSI和NVMe，SATA的活跃度正在慢慢下降，IDE已经基本不动了，新出现的Persistent Memory呈上升趋势。这个活跃度很客观的反应了目前设备的流行程度。&lt;/p&gt;

&lt;p&gt;他重点介绍了从2013年开始block层的开发比较活跃的原因：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从2013年开始引入了blk-mq，即Multiqueue Block Layer。新的block层的出现是为了更好的使用新设备，遗留的块层是为HDD设计的，现在显然过时了，所以kernel引入了blk-mq，并且不断的改进。&lt;/li&gt;
  &lt;li&gt;除了性能的提升，block层也在I/O抽象接口方面做了很多工作，block层不再是只提供简单的read、write和passthrough这些简单的接口，还有&lt;/li&gt;
  &lt;li&gt;很多其他高级特性，比如discard、write zeros等。&lt;/li&gt;
  &lt;li&gt;增加对zoned block device的支持。&lt;/li&gt;
  &lt;li&gt;NVMe支持的改进。&lt;/li&gt;
  &lt;li&gt;Persistent Memory的支持。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后，一张commit数量的图显示，2017年的以来，Block Storage方面的开发活跃度正在高速增长。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/imgs/00015_sdc2017_block_storage_commits.png&quot; alt=&quot;Block Storage Commits&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 13 Sep 2017 00:00:00 +0800</pubDate>
        <link>/2017/09/13/sdc-2017-2.html</link>
        <guid isPermaLink="true">/2017/09/13/sdc-2017-2.html</guid>
        
        
      </item>
    
      <item>
        <title>SDC 2017 Day 1</title>
        <description>&lt;p&gt;&lt;img src=&quot;/assets/imgs/00013_sdc2017_day1.jpg&quot; alt=&quot;Day1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;9月11日到14日，SNIA SDC (Storage Developer Conference) 2017在美国圣何塞召开。我把今天听的几个演讲分享一下。给出的链接可以下载演讲的幻灯片。&lt;/p&gt;

&lt;h1 id=&quot;causally-ordering-distributed-file-system-events&quot;&gt;Causally Ordering Distributed File System Events&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Dell EMC Isilon&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/549459&quot;&gt;https://sniasdc17.pathable.com/meetings/549459&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;讲了一种在Isilon中使用的高效的分布式文件系统的事件排序方法。基本思路是，Isilon中的每个inode都有编号以及版本号，通过组合文件操作中的inode信息来表示一个事件。将所有的事件发送到一个排序节点上，构建一个有向无环图，然后使用拓扑排序得到一个事件序列。这个事件序列可以用于写入log文件，用于实现文件系统的快照功能。&lt;/p&gt;

&lt;h1 id=&quot;container-native-storage---solving-the-persistent-storage-challenge-with-gluster&quot;&gt;Container Native Storage - Solving the Persistent Storage Challenge With Gluster&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;RedHat&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/549464&quot;&gt;https://sniasdc17.pathable.com/meetings/549464&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;使用Gluster来为容器K8s的容器提供存储。&lt;/p&gt;

&lt;h1 id=&quot;breaking-the-cloud-storage-chains&quot;&gt;Breaking the Cloud Storage Chains&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;INFINIDAT&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/549469&quot;&gt;https://sniasdc17.pathable.com/meetings/549469&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;介绍了InfiniBox产品，这个产品可以帮助拜托公有云的存储绑定问题。将这个存储放在私有云中，然后通过共有云的VPC网络和公有云连接起来，使得公有云的计算资源可以访问到私有云的存储。这种方法的好处包括：省钱、不会有公有云绑定问题，数据安全等。至于性能问题，在网络延迟为2ms的情况下，对于文件系统，Infinibox比公有云性能好；对于块存储，在带宽方面比公有云好。&lt;/p&gt;

&lt;h1 id=&quot;universal-hybrid-cloud-connector-for-seamless-data-migration&quot;&gt;Universal Hybrid Cloud Connector for Seamless Data Migration&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Veritas Technologies&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/549473&quot;&gt;https://sniasdc17.pathable.com/meetings/549473&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基于VxFS之上，实现了一种Mutti-Volume filesystem + SmartTier的文件系统，可以通过配置文件把文件系统的数据分布到不同的本地磁盘或者公有云对象存储上。类似AWS Storage Gateway。&lt;/p&gt;

&lt;h1 id=&quot;providing-efficient-storage-operations-for-both-data-centers-and-hyperscale-applications&quot;&gt;Providing Efficient Storage Operations for Both Data Centers and Hyperscale Applications&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Samsung&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/549818&quot;&gt;https://sniasdc17.pathable.com/meetings/549818&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了发挥出SSD的性能，需要应用或者host控制SSD的更多方面。探讨了Open Channel和IO Determinism。&lt;/p&gt;

&lt;h1 id=&quot;andromeda-building-the-next-generation-high-density-storage-interface-for-successful-adoption&quot;&gt;Andromeda: Building the Next-Generation High-Density Storage Interface for Successful Adoption&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Microsoft&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/549841&quot;&gt;https://sniasdc17.pathable.com/meetings/549841&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;介绍了微软在SSD应用方面的一些进展。微软的不同应用有不同的SSD性能需求，为了在一个节点上同时运行不同的应用，需要应用和host来控制SSD的运行时配置。采用了Open Channel的方案，正在尝试将log manager和media manager分开，log manager放在host中，media manager放在硬盘中，从让不同应用都可以把SSD的性能发挥出来。&lt;/p&gt;

&lt;h1 id=&quot;dynamic-reliability-methods-for-a-clustered-task-server&quot;&gt;Dynamic Reliability Methods for a Clustered-task Server&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Dell EMC&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sniasdc17.pathable.com/meetings/549848&quot;&gt;https://sniasdc17.pathable.com/meetings/549848&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;讲了一个对服务器集群生命周期进行建模的方法。个人觉得这个方法更适合给硬盘使用&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Sep 2017 00:00:00 +0800</pubDate>
        <link>/2017/09/12/sdc-2017-1.html</link>
        <guid isPermaLink="true">/2017/09/12/sdc-2017-1.html</guid>
        
        
      </item>
    
      <item>
        <title>GopherCon 2017 观后感(2)</title>
        <description>&lt;p&gt;GopherConf 2017于7月13日到15日在美国丹佛举行，我在youtube上看了一些视频，本文是一些视频的观后感。&lt;/p&gt;

&lt;h1 id=&quot;ian-schenck---operability-in-go&quot;&gt;Ian Schenck - Operability in Go&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=SIl3wi1iWPE&quot;&gt;https://www.youtube.com/watch?v=SIl3wi1iWPE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;介绍使用 stuct log（github.com/Sirupsen/logrus）和 expvar库来增强互操作性，其实和互操作性没什么关系，就是讲增强导出log的可读性，并且通过expvar来暴露程序运行时的内部状态。不推荐看。&lt;/p&gt;

&lt;h1 id=&quot;jon-bodner---runtime-generated-typesafe-and-declarative-pick-any-three&quot;&gt;Jon Bodner - Runtime Generated, Typesafe, and Declarative: Pick Any Three&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=hz6d7rzqJ6Q&quot;&gt;https://www.youtube.com/watch?v=hz6d7rzqJ6Q&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;介绍了https://github.com/jonbodner/proteus 项目。这个项目通过使用sturct tag, function generation, reflect和template来实现了一个DAO层。这个DAO层可以用来实现把一种DSL转换成对存储系统的访问。演讲中描述了如何使用这个方法来实现SQL的访问。另外，大家都认为大量使用reflect会很慢，但是作者还现场跑了benchmark，说明对于存储访问这种重IO的操作，reflect带来的影响可以接受，速度是足够快的。&lt;/p&gt;

&lt;h1 id=&quot;david-crawshaw---go-build-modes&quot;&gt;David Crawshaw - Go Build Modes&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=x-LhC-J2Vbk&quot;&gt;https://www.youtube.com/watch?v=x-LhC-J2Vbk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;介绍了go的8种build mode：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;exe(static)&lt;/li&gt;
  &lt;li&gt;exe(with libc)&lt;/li&gt;
  &lt;li&gt;exe(with libc and non-Go code)&lt;/li&gt;
  &lt;li&gt;pie&lt;/li&gt;
  &lt;li&gt;c-archive&lt;/li&gt;
  &lt;li&gt;c-shared&lt;/li&gt;
  &lt;li&gt;shared&lt;/li&gt;
  &lt;li&gt;plugin
最后介绍了go plugin的一种应用场景。Plugin的模式正在被慢慢改进，不过短期内还不会进入生产ready。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;edward-muller---go-anti-patterns&quot;&gt;Edward Muller - Go Anti-Patterns&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=ltqV6pDKZD8&quot;&gt;https://www.youtube.com/watch?v=ltqV6pDKZD8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;介绍了go的一些反模式，也就是非常规编码模式。不过，这种事情见仁见智，可以参考，不一定全部接受。&lt;/p&gt;

&lt;h1 id=&quot;mitchell-hashimoto---advanced-testing-with-go&quot;&gt;Mitchell Hashimoto - Advanced Testing with Go&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=8hQG7QlcLBk&quot;&gt;https://www.youtube.com/watch?v=8hQG7QlcLBk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;讲了golang单元测试的一些基本需求以及HashiCorp在这方面对应的技术实现。&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Aug 2017 00:00:00 +0800</pubDate>
        <link>/2017/08/16/gophercon-2017-2.html</link>
        <guid isPermaLink="true">/2017/08/16/gophercon-2017-2.html</guid>
        
        
      </item>
    
      <item>
        <title>GopherCon 2017 观后感(1)</title>
        <description>&lt;p&gt;GopherConf 2017于7月13日到15日在美国丹佛举行，我在youtube上看了一些视频，本文是一些视频的观后感。&lt;/p&gt;

&lt;h1 id=&quot;russ-cox---the-future-of-go&quot;&gt;Russ Cox - The Future of Go&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=0Zbh_vmAKvk&quot;&gt;https://www.youtube.com/watch?v=0Zbh_vmAKvk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;开始为Go2进行宣传。Go2的开发启动还早，但是社区已经开始考虑这个问题。Russ Cox分享了社区这几年来是如何改进语言的。我总结了几点如下：&lt;/p&gt;

&lt;p&gt;首选需要清晰的描述出问题，以便社区进行讨论。
一个问题是否要解决取决于该问题的重要性和影响范围。社区引入一个不确定的feature的方式是等，等到这个feature足够重要了引入。。他举了Go 1.9中新增的type alias和monotonic clock的例子。这两个问题的解决都是在1.9版本中引入的，虽然问题的提出和解决方案在很早之前就完成了，但直到今年才决定要放到Go中。
解决问题的方式不一定是增加变成语言特性，也可能是增加工具（race detection），或者是增加标准库。&lt;/p&gt;

&lt;p&gt;最后，他呼吁大家参与ExperienceReport（golang.org/wiki/ExperienceReports），为社区提供更多的问题积累，以便社区更好的决定哪些特性要引入到语言中。&lt;/p&gt;

&lt;h1 id=&quot;keith-randall---generating-better-machine-code-with-ssa&quot;&gt;Keith Randall - Generating Better Machine Code with SSA&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=uTMvKVma5ms&quot;&gt;https://www.youtube.com/watch?v=uTMvKVma5ms&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;讲述了Golang为什么要引入SSA（Static Single Assignemnt）。从1.5版本之后开始引入，1.7版本合入主干发布。SSA能够让Go代码更快更小，也能够让编译器更方便的对代码进行优化。从结果来看，引入SSA
后，AMD64平台，代码性能提升12%，缩小13%；ARM平台，性能提升20%，缩小18%。&lt;/p&gt;

&lt;h1 id=&quot;kavya-joshi---understanding-channels&quot;&gt;Kavya Joshi - Understanding Channels&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=KBZlN0izeiY&quot;&gt;https://www.youtube.com/watch?v=KBZlN0izeiY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;介绍了channel的内部实现，以及channel导致的goroutine的阻塞和唤醒在runtime中是如何实现的。&lt;/p&gt;

&lt;h1 id=&quot;rhys-hiltner---an-introduction-to-go-tool-trace&quot;&gt;Rhys Hiltner - An Introduction to “go tool trace”&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=V74JnrGTwKA&quot;&gt;https://www.youtube.com/watch?v=V74JnrGTwKA&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;介绍了 go tool trace，内容一般，听得也不太清楚，不推荐。&lt;/p&gt;

&lt;h1 id=&quot;sam-boyer---the-new-era-of-go-package&quot;&gt;Sam Boyer - The New Era of Go Package&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=5LtMb090AZI&quot;&gt;https://www.youtube.com/watch?v=5LtMb090AZI&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;介绍了社区的实验项目 github.com/golang/dep ，这是一个用来实现包依赖管理的工具，用来解决现在广为诟病的包依赖问题。如果合适，将来会进入go tool chain。该项目已经production ready，大家可以开始使用了。&lt;/p&gt;
</description>
        <pubDate>Sat, 05 Aug 2017 00:00:00 +0800</pubDate>
        <link>/2017/08/05/gophercon-2017-1.html</link>
        <guid isPermaLink="true">/2017/08/05/gophercon-2017-1.html</guid>
        
        
      </item>
    
      <item>
        <title>2017 OpenStack Days China Day 1</title>
        <description>&lt;p&gt;&lt;img src=&quot;/assets/imgs/00010_2017_openstack_days_china_gate.jpg&quot; alt=&quot;Gate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2017 OpenStack Days China于7月24日和7月25日在北京国家会议中心举行。会议的目标依旧是推广OpenStack在中国的普及。人数大约2000，但是根据去年有来的人说，人数没有去年多。&lt;/p&gt;

&lt;p&gt;第一天的Keynote分为两个类型，基金会的演讲和5月份Boston summit上的差不多，只是略做修改（比如人工智能提到了百度等）。而赞助商的演讲基本就是广告了。第一天的keynote听下来，你会发现本土厂商的keynote，不论在幻灯片的制作还是演讲上，都和国外厂商有差距，感觉不是很重视。唯一的例外是腾讯，腾讯利用keynote发布了TStack，幻灯片水平和演讲水平确实不错。&lt;/p&gt;

&lt;p&gt;宣传方面，来进行宣传的基本都是本土厂商，包括我所在的XSKY，看到的外国厂商貌似只有Intel, RedHat, NetApp。本土厂商中最让我感到意外的是腾讯。腾讯在本次会议上推出了TStack产品，也就是腾讯定制的OpenStack产品以及相关的服务。搜索了一下，发现腾讯在发布TStack的同时，还向基金会提交了superuser的采访稿（http://superuser.openstack.org/articles/tencent-openstack/），准备参加11月份悉尼summit的superuser评选，说明腾讯对这次TStack发布做了充分的准备。TStack一开始是作为腾讯的内部私有云服务来建设的，目前的版本是基于K版，其内部集群运行了4年多，可用性达到99.99%，运行了5000个物理机和10000+个虚拟机，是国内最大的私有云平台之一（这应该也是他们参加superuser评选的资本）。除了自己用以外，腾讯还发展了一些TStack的用户，比如著名的0元中标的厦门政务云。根据产品介绍页，腾讯这次是产品和服务一起推出，虽然版本看起来有点旧，但是毕竟是个超级大厂，想必会极大的冲击国内的OpenStack市场。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/imgs/00011_tstack_page1.jpg&quot; alt=&quot;TStack1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/imgs/00012_tstack_page2.jpg&quot; alt=&quot;TStack2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我也听了几场技术分享，其中最热门的是EasyStack的一个分享：OpenStack对vCenter存量虚拟机的纳管和迁移实践。来这场分享的听众很多，说明大家对VMWare和OpenStack共存是有很大需求的。从分享中也可以发现EasyStack做了很多这方面的工作。&lt;/p&gt;

&lt;p&gt;我第二天没去，所以没有第二天相关的内容。&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Jul 2017 00:00:00 +0800</pubDate>
        <link>/2017/07/26/2017-openstack-days-china-day1.html</link>
        <guid isPermaLink="true">/2017/07/26/2017-openstack-days-china-day1.html</guid>
        
        
      </item>
    
      <item>
        <title>OpenStack Summit 2017 Boston观后感</title>
        <description>&lt;p&gt;这次summit已经不强调OpenStack本身的技术了，所有的核心项目都已经很成熟，各大厂商也把高可用和在线升级做得很成熟了。而且，OpenStack已经是私有云事实上的标准，除非你选VMWare产品，否则只能选择OpenStack。&lt;/p&gt;

&lt;p&gt;在我看来，OpenStack summit这次强调的重点有两个，一个是open，另一个是和容器的结合。&lt;/p&gt;

&lt;h1 id=&quot;open&quot;&gt;Open&lt;/h1&gt;

&lt;p&gt;Open，在OpenStack的解释里有两个，一个是open source，另一个是open community。&lt;/p&gt;

&lt;p&gt;Open source代表着透明、用户可控，也代表着运维困难等，是一些被大家广泛接受的观点。OpenStack基金会这次还在现场连线采访了斯诺登，就是为了向用户传递open source方面的价值。不过，我觉得这些观点并不能很好的吸引用户。&lt;/p&gt;

&lt;p&gt;Open community是我觉得更有意思的一个方面。基金会COO Mark Collier在第二天的keynote Home of Open {Composable} Infrastructure 花了很大的篇幅来讲这个问题。OpenStack是一个很活跃的社区，Kubernetes是另一个很活跃的社区，两个社区之间是否能有合作呢？合作又会涉及到哪些方面呢？比如在运营方面，Mark觉得很多开源社区的运营都和OpenStack社区类似，其他社区可以学习OpenStack这七年来积累的社区运营经验。在技术方面，是否可以直接利用其他社区的产品，避免重复造轮子？&lt;/p&gt;

&lt;p&gt;在技术方面，Mark举了个很好的例子，像Kubernetes这样的应用是需要解决存储问题的，而OpenStack已经花了7年的时间来解决存储问题，Cinder项目可以对接80种不同的后端，Kubernetes可以通过对接Cinder来解决存储问题，这样就不用重复对接不同存储后端这个工作了。目前Kubernetes也确实这么做了。&lt;/p&gt;

&lt;p&gt;我觉得上面这个例子说明了OpenStack现在的地位，以及基金会对它的期望。现在的OpenStack就像是当年的Linux，已经开始成为一种标准，一种数据中心管理的标准：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当年，你要管理一个服务器上的资源，你就给它装上Linux。Linux负责管理一个服务器上的计算、网络和存储资源。&lt;/li&gt;
  &lt;li&gt;现在，你要管理一个数据中心的资源，你就给它装上OpenStack。OpenStack负责管理一个数据中心里的计算、网络和存储资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;预计，OpenStack会强化自己作为数据中心OS的路线。&lt;/p&gt;

&lt;h1 id=&quot;容器&quot;&gt;容器&lt;/h1&gt;

&lt;p&gt;这两年来，容器技术的发展绝对是对OpenStack发展的一大威胁。不论是用户，还是OpenStack社区，都对容器技术如何与OpenStack结合感到困惑。但是，今年，这个问题似乎得到了解决，不过并不是通过技术方案来解决，而是通过策略。&lt;/p&gt;

&lt;p&gt;这次的summit上，社区和主要厂商都把kubernetes、mesos、swarm等看成是应用管理平台，这个平台通过容器技术可以实现应用在混合云上的编排需求。OpenStack则作为私有云的管理平台，向K8s提供资源，但是不参与应用的管理。类似下图这样的架构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/imgs/00009_hybrid_cloud_architecture.jpg&quot; alt=&quot;Hybrid Cloud Architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也就是说，OpenStack打算脱离应用管理平台，各大厂商目前也在这么做，比如Red Hat和Ubuntu。&lt;/p&gt;

&lt;p&gt;另外，既然把容器管理平台作为连接私有云和公有云的重要工具，那么这个平台就得解决计算、网络和存储这三种资源在私有云和公有云之间迁移的问题。计算很简单，计算是无状态的，私有云的CPU和公有云的CPU可以做同样的事情，只需要一定的启停时间。网络，可以通过修改DNS或者IP地址达到目的，流量还是可以到达你服务所在的位置。存储，只有存储是最难的。
混合云的存储问题，主要还是在于数据的存储位置是很难改变的，成本太高。存储决定了应用的状态，所以存储有一致性等各种要求。要想在混合云的场景里解决这个问题，要么是把数据复制一份，这就存在数据一致性和存储成本的问题；要么是忍受跨WAN的数据访问带来的延迟和吞吐的降低。这个问题应该来说，还没有好的解决方案。但是，从另一方面来说，这个问题应该不是一个太大的问题，公有云一直是推行多region数据不相通的运作方式，大家也都用得好好的。所以，使用容器管理平台来连接私有云和公有云时，还是需要考虑数据的存储位置。&lt;/p&gt;

&lt;p&gt;虽然数据存储不可能那么灵活，Red Hat和AWS还是做了一个尝试。在Red Hat summit上，发布了AWS broker类容器。这类容器是AWS公有云服务的代理容器，创建一个这样的容器，就等于在AWS创建了一个对应的服务，应用连接到这个容器就可以直接访问AWS服务。所以应用不用关心自己在哪里运行，访问的数据始终是在AWS上。这是一个很好的尝试。&lt;/p&gt;

&lt;p&gt;总的来说，使用容器来调度应用也是个事实上的标准了，OpenStack已经没有办法在这个领域中占到地盘了（所以我对Magnum项目的前途感到十分担忧啊）。如何和容器更好的结合，肯定是未来一两年内OpenStack要做的主要事情。&lt;/p&gt;
</description>
        <pubDate>Fri, 26 May 2017 00:00:00 +0800</pubDate>
        <link>/2017/05/26/openstack-summit-2017-boston-review.html</link>
        <guid isPermaLink="true">/2017/05/26/openstack-summit-2017-boston-review.html</guid>
        
        
      </item>
    
      <item>
        <title>Golang源码阅读笔记 -- go build(3)</title>
        <description>&lt;p&gt;在&lt;a href=&quot;/2017/02/26/golang-code-reading-notes-1.html&quot;&gt;第一篇文章go build(1)&lt;/a&gt;中，我们提到了&lt;em&gt;cmd/go/pkg.go&lt;/em&gt;文件中的&lt;code class=&quot;highlighter-rouge&quot;&gt;loadImport&lt;/code&gt;函数。该函数有两个主要的步骤，一个是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;buildContext.Import()&lt;/code&gt;方法来获得要构建的package的基本信息，这个我们在&lt;a href=&quot;/2017/02/27/golang-code-reading-notes-2.html&quot;&gt;上一篇文章go build(2)&lt;/a&gt;中已经说明了其内部逻辑，另外一个调用是&lt;code class=&quot;highlighter-rouge&quot;&gt;p.load(stk, bp, err)&lt;/code&gt;，也就是载入这个package的依赖。本文要看的是第二个步骤的具体过程。&lt;/p&gt;

&lt;h1 id=&quot;cmdgopackage对象的load方法&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd/go.Package&lt;/code&gt;对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt;方法&lt;/h1&gt;

&lt;p&gt;该方法位于&lt;em&gt;cmd/go/pkg.go&lt;/em&gt;文件中。&lt;/p&gt;

&lt;h2 id=&quot;调用说明&quot;&gt;调用说明&lt;/h2&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;loadImport&lt;/code&gt;函数中执行的代码是&lt;code class=&quot;highlighter-rouge&quot;&gt;p.load(stk, bp, err)&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd/go.Package&lt;/code&gt;对象，这个是表示一个要构建的package。相对的&lt;code class=&quot;highlighter-rouge&quot;&gt;go/build.Package&lt;/code&gt;表示一个被import的package。前者包含的信息更多。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stk&lt;/code&gt;是一个表示依赖深度的栈，用于记录import路径的一个栈。通过栈的&lt;strong&gt;push&lt;/strong&gt;和&lt;strong&gt;pop&lt;/strong&gt;操作，不断的记录import的路径，栈顶是当前正在处理的package，栈顶下的那个package则import了栈顶package。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bp&lt;/code&gt; 是&lt;code class=&quot;highlighter-rouge&quot;&gt;buildContext.Import&lt;/code&gt;方法返回的对象，是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;go/build.Package&lt;/code&gt;对象，包含了要构建的package的基本信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;load方法的内部逻辑&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt;方法的内部逻辑&lt;/h2&gt;

&lt;p&gt;强调一下，这里我们还是以最常见的import path形式，类似&lt;strong&gt;goexample/hello&lt;/strong&gt;这样，来看&lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt;方法的内部逻辑。&lt;/p&gt;

&lt;h3 id=&quot;拷贝信息&quot;&gt;拷贝信息&lt;/h3&gt;

&lt;p&gt;首先执行&lt;code class=&quot;highlighter-rouge&quot;&gt;p.copyBuild(bp)&lt;/code&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;go/build.Package&lt;/code&gt;对象的内容拷贝到&lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;，也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd/go.Package&lt;/code&gt;中，也会把&lt;code class=&quot;highlighter-rouge&quot;&gt;bp&lt;/code&gt;赋值给&lt;code class=&quot;highlighter-rouge&quot;&gt;p.build&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;构建结果存放位置的处理&quot;&gt;构建结果存放位置的处理&lt;/h3&gt;

&lt;p&gt;区分两个情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;package的名称是&lt;strong&gt;main&lt;/strong&gt;，也就是构建结果是一个可执行程序。这个时候构建结果的存放目录是在一个&lt;em&gt;bin&lt;/em&gt;目录下，最常见的情况就是&lt;em&gt;GOPATH/bin&lt;/em&gt;目录，输出的文件名是package的目录名。&lt;/li&gt;
  &lt;li&gt;如果是非&lt;strong&gt;main&lt;/strong&gt;的package，那么一般使用&lt;code class=&quot;highlighter-rouge&quot;&gt;p.build.PkgObj&lt;/code&gt;这个路径作为目标路径。这个路径在上一篇文章中有描述了生成过程，类似&lt;em&gt;GOPATH/pkg/linux_amd64/goexample/hello.a&lt;/em&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;依赖的预处理&quot;&gt;依赖的预处理&lt;/h3&gt;

&lt;p&gt;之前已经得到了要构建的package的依赖，保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;p.build.Imports&lt;/code&gt;中，又被拷贝到&lt;code class=&quot;highlighter-rouge&quot;&gt;p.Imports&lt;/code&gt;中。这些只是源码中写的&lt;code class=&quot;highlighter-rouge&quot;&gt;import&lt;/code&gt;语句的依赖，构建过程还需要加上其他的内部依赖。对于最常见的情况，还需要把&lt;strong&gt;runtime&lt;/strong&gt;增加到依赖中。其他的情况会根据是否有cgo、架构平台、是否是标准库以及命令行参数等条件来增加相应的依赖。经过预处理的依赖存放在变量&lt;code class=&quot;highlighter-rouge&quot;&gt;importPaths&lt;/code&gt;中。&lt;/p&gt;

&lt;h3 id=&quot;文件的预处理&quot;&gt;文件的预处理&lt;/h3&gt;

&lt;p&gt;将这个package中的go文件和非go文件都生成绝对路径，保存到相应的变量中并按照文件名排序。&lt;/p&gt;

&lt;p&gt;检查package中的文件名是否有重名，&lt;strong&gt;这个要求是忽略大小的情况下也不能重名&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;处理依赖&quot;&gt;处理依赖&lt;/h3&gt;

&lt;p&gt;接下来，&lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt;方法开始处理依赖，也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;importPaths&lt;/code&gt;变量中的package。这里会遍历每个ImportPath，然后依次处理。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先，跳过ImportPath为&lt;strong&gt;C&lt;/strong&gt;的package，因为这是cgo的package，不属于依赖。&lt;/li&gt;
  &lt;li&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;p1 := loadImport(path, p.Dir, p, stk, p.build.ImportPos[path], useVendor)&lt;/code&gt;。看到&lt;code class=&quot;highlighter-rouge&quot;&gt;loadImport&lt;/code&gt;函数是不是觉得很熟悉？没错，这个就是在&lt;a href=&quot;% post_url 2017-02-26-golang-code-reading-notes-1 %}&quot;&gt;文章go build(1)&lt;/a&gt;中提到的&lt;code class=&quot;highlighter-rouge&quot;&gt;loadImport&lt;/code&gt;函数，也就是调用了我们正在讲解的这个&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd/go.Package&lt;/code&gt;对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt;方法。所以，这里是一个递归调用，不过同样path的package只会收集一次信息，之后再遇到会直接从cache返回，这个在&lt;a href=&quot;% post_url 2017-02-26-golang-code-reading-notes-1 %}&quot;&gt;文章go build(1)&lt;/a&gt;中已经提到过了。&lt;/li&gt;
  &lt;li&gt;判断一下import进来的package的名称是否是&lt;strong&gt;main&lt;/strong&gt;，是的话就报错。&lt;/li&gt;
  &lt;li&gt;把&lt;code class=&quot;highlighter-rouge&quot;&gt;p1&lt;/code&gt;加入到&lt;code class=&quot;highlighter-rouge&quot;&gt;deps&lt;/code&gt;这个map中，这样&lt;code class=&quot;highlighter-rouge&quot;&gt;deps&lt;/code&gt;就是一个包含所有package &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;的依赖的map。同样，也把&lt;code class=&quot;highlighter-rouge&quot;&gt;p1&lt;/code&gt;加入到&lt;code class=&quot;highlighter-rouge&quot;&gt;imports&lt;/code&gt;这个slice中，这样&lt;code class=&quot;highlighter-rouge&quot;&gt;imports&lt;/code&gt;就是一个包含所有package &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;的依赖的slice。&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;p1.Incomplete&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，那么也设置&lt;code class=&quot;highlighter-rouge&quot;&gt;p.Incomplete&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;Incomplete&lt;/code&gt;表示在载入这个package或者它的依赖时出现错误。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;经过上面的处理，就已经递归的载入了package &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;的所有依赖，这些依赖的相关信息会被记录到&lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;中，&lt;code class=&quot;highlighter-rouge&quot;&gt;p.imports = imports&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;p.deps&lt;/code&gt;会是排序过的&lt;code class=&quot;highlighter-rouge&quot;&gt;deps&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;计算buildid&quot;&gt;计算BuildID&lt;/h3&gt;

&lt;p&gt;对于编译一个package而言，&lt;strong&gt;buildID&lt;/strong&gt;是根据这个package的所有文件的文件名，和这个package的所有依赖的ImportPath以及依赖的buildID，计算出来的一个SHA-1值，主要是用来判断一个package是否需要重新构建。这个在后面会讲到。&lt;/p&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;完成上面这些步骤后，这个package的依赖也就都载入成功了，并且buildID也已经计算完成。&lt;/p&gt;

&lt;h1 id=&quot;reusepackage函数&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reusePackage&lt;/code&gt;函数&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reusePackage(p *Package, stk *importStack)&lt;/code&gt;函数位于文件&lt;em&gt;cmd/go/pkg.go&lt;/em&gt;文件中。我们已经知道，这个函数会在&lt;code class=&quot;highlighter-rouge&quot;&gt;loadImport&lt;/code&gt;中被调用，用来判断是否有循环应用的情况。现在我们来仔细看一下这个逻辑。&lt;/p&gt;

&lt;p&gt;首先，看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;loadImport&lt;/code&gt;中的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func loadImport(path, srcDir string, parent *Package, stk *importStack, importPos []token.Position, mode int) *Package {
    ...
    importPath := path
    ...
    if p := packageCache[importPath]; p != nil {
        ...
        return reusePackage(p, stk)
    }

    p := new(Package)
    p.local = isLocal
    p.Importpath = importPath
    packageCache[importPath] = p
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从上面代码可以看出，在发现现在要import的path已经被处理过了之后，就可以直接返回cache中的&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd/go.Package&lt;/code&gt;对象，但是返回前要先调用&lt;code class=&quot;highlighter-rouge&quot;&gt;reusePackage&lt;/code&gt;函数检查是否循环引用。如果这个path不在cache中，那么创建新的package之后，立刻加入到cache。&lt;/p&gt;

&lt;p&gt;接下来看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;reusePackage&lt;/code&gt;中是如何检查循环引用的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func reusePackage(p *Package, stk *importStack) *Package {
    if p.imports == nil {
        // import cycle
    }
    ...
    return p
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上一节中，我们看到了，&lt;code class=&quot;highlighter-rouge&quot;&gt;p.load&lt;/code&gt;这个方法在收集了所有的依赖的信息后，才会设置自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;p.imports&lt;/code&gt;变量。所以，只要&lt;code class=&quot;highlighter-rouge&quot;&gt;p.imports&lt;/code&gt;这个变量还是空的，就说明这个package还没有处理完依赖，所以只要在处理依赖的过程中再次遇到自己，就会触发&lt;code class=&quot;highlighter-rouge&quot;&gt;reusePackage&lt;/code&gt;函数的调用，就会看到&lt;code class=&quot;highlighter-rouge&quot;&gt;p.imports == nil&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;回到packagesanderrors函数&quot;&gt;回到&lt;code class=&quot;highlighter-rouge&quot;&gt;packagesAndErrors&lt;/code&gt;函数&lt;/h1&gt;

&lt;p&gt;现在回到&lt;a href=&quot;% post_url 2017-02-26-golang-code-reading-notes-1 %}&quot;&gt;文章go build(1)&lt;/a&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;packagesAndErrors&lt;/code&gt;函数。我们回顾一下到目前为止走过的流程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;packagesAndErrors()
    loadPackage()
        loadImport()
            reusePackage()
            buildContext.Import()
            p.load()
    computeStale()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到目前为止，我们已经分析了从&lt;code class=&quot;highlighter-rouge&quot;&gt;loadPackage()&lt;/code&gt;函数开始往下的流程。现在，在&lt;code class=&quot;highlighter-rouge&quot;&gt;packagesAndErrors&lt;/code&gt;函数中，我们通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;loadPackage&lt;/code&gt;函数，得到了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd/go.Package&lt;/code&gt;对象&lt;code class=&quot;highlighter-rouge&quot;&gt;pkg&lt;/code&gt;。下面就开始调用&lt;code class=&quot;highlighter-rouge&quot;&gt;computeStale(pkg)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;computestale函数&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;computeStale&lt;/code&gt;函数&lt;/h2&gt;

&lt;p&gt;这个函数会判断一个package是否需要重新构建，也就是是否stale。如果需要，就设置&lt;code class=&quot;highlighter-rouge&quot;&gt;pkg.Stale&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;。判断的工作是由&lt;code class=&quot;highlighter-rouge&quot;&gt;isStale(p *Package) (bool, string)&lt;/code&gt;函数完成的，这个函数位于&lt;em&gt;cmd/go/pkg.go&lt;/em&gt;文件中。&lt;/p&gt;

&lt;p&gt;判断stale的逻辑在&lt;code class=&quot;highlighter-rouge&quot;&gt;isStale&lt;/code&gt;函数的注释中写的非常清楚，包括演变过程，主要是基于buildID和文件修改时间来判断的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;buildID的方法如下：编译输出时，将这个package的buildID记录到目标文件中，在&lt;code class=&quot;highlighter-rouge&quot;&gt;isStale&lt;/code&gt;函数中，会读取目标文件中保存的buildID，如果和现在package中计算出来的buildID不同，那么就需要重新构建。&lt;/li&gt;
  &lt;li&gt;基于文件修改时间的方法如下：只要构建package有关的文件中，有一个文件的修改时间比目标文件晚，那么就需要重新构建。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面这个是最基本的方法介绍，&lt;code class=&quot;highlighter-rouge&quot;&gt;isStale&lt;/code&gt;函数中还考虑了命令行参数，以及文件是否存在等情况。&lt;/p&gt;

&lt;h2 id=&quot;小结-1&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;packagesAndErrors&lt;/code&gt;函数调用完&lt;code class=&quot;highlighter-rouge&quot;&gt;computeStale&lt;/code&gt;之后，就返回所获取到的packages对象。&lt;/p&gt;

&lt;p&gt;因为&lt;code class=&quot;highlighter-rouge&quot;&gt;packagesForBuild&lt;/code&gt;函数是调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;packagesAndErrors&lt;/code&gt;函数来获得packages，如果获取的过程没有错误，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;packagesForBuild&lt;/code&gt;就返回获取到的packages。我们又回到了&lt;code class=&quot;highlighter-rouge&quot;&gt;runBuild&lt;/code&gt;函数中。&lt;/p&gt;
</description>
        <pubDate>Tue, 28 Feb 2017 00:00:00 +0800</pubDate>
        <link>/2017/02/28/golang-code-reading-notes-3.html</link>
        <guid isPermaLink="true">/2017/02/28/golang-code-reading-notes-3.html</guid>
        
        
      </item>
    
  </channel>
</rss>
