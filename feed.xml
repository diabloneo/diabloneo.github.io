<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coffee, Coke and Code</title>
    <description>Archive diabloneo&apos;s articles.
</description>
    <link>http://diabloneo.github.io//</link>
    <atom:link href="http://diabloneo.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 11 Apr 2024 22:09:44 +0800</pubDate>
    <lastBuildDate>Thu, 11 Apr 2024 22:09:44 +0800</lastBuildDate>
    <generator>Jekyll v4.3.1</generator>
    
      <item>
        <title>基于 PostgreSQL 逻辑复制和 CDC 实现企业级分布式系统</title>
        <description>&lt;p&gt;本文是 2023 年 3 月 4 日在第 12 届 PostgreSQL 中国技术大会发表主题演讲《基于 PostgreSQL 逻辑复制和 CDC 实现企业级分布式系统》的文本内容 (数据库管理运维与最佳实践专场)&lt;/p&gt;

&lt;p&gt;大会视频回放和 PPT 下载链接：&lt;em&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/4azY8cm9iA_mcKWPw1jhBw&quot;&gt;https://mp.weixin.qq.com/s/4azY8cm9iA_mcKWPw1jhBw&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;背景与调研&quot;&gt;背景与调研&lt;/h2&gt;

&lt;h3 id=&quot;产品背景&quot;&gt;产品背景&lt;/h3&gt;

&lt;p&gt;XSKY 有 SDS 和 SDDC 两款产品，SDS 诞生于 2015 年，SDDC 诞生于 2021 年。这次分享的是 SDDC 产品的管理面的架构设计。&lt;/p&gt;

&lt;p&gt;SDS 产品基于 Postgres 9.6，为了控制产品的复杂性，我们没有引入数据库消息队列组件。但是在产品中又得依赖于消息队列这样的机制，因此我们使用了两个方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任务表 + 定时轮询
    &lt;ul&gt;
      &lt;li&gt;消息传递及时性较低&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Trigger
    &lt;ul&gt;
      &lt;li&gt;效率低，性能消耗大
-因为没有直接回调，还是需要依赖于定时轮询&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;逻辑复制的相关概念&quot;&gt;逻辑复制的相关概念&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;逻辑复制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;逻辑复制是根据复制标识（通常是主键）复制数据对象及其变更的一种方法。&lt;/li&gt;
  &lt;li&gt;传送的是数据库的一种与存储格式无关的表达格式
    &lt;ul&gt;
      &lt;li&gt;允许跨 Postgres 版本传递数据&lt;/li&gt;
      &lt;li&gt;甚至允许向非 Postgres 程序传递数据&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CDC (Change Data Capture)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;近实时捕获数据源的变更并且发送给下游的数据消费者&lt;/li&gt;
  &lt;li&gt;不能等价于消息队列
    &lt;ul&gt;
      &lt;li&gt;只能表达和数据源有关的数据变化&lt;/li&gt;
      &lt;li&gt;产生的是顺序事件，不能按照随意顺序消费&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;逻辑复制调研&quot;&gt;逻辑复制调研&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;调研过程&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Postgres 10 开始&lt;/li&gt;
  &lt;li&gt;Postgres 13 开始预研
    &lt;ul&gt;
      &lt;li&gt;设计并实现了一个小项目，验证逻辑复制和 CDC 方案的可行性&lt;/li&gt;
      &lt;li&gt;向 &lt;em&gt;&amp;lt;github.com/jackc/pglogrepl&amp;gt;&lt;/em&gt; 贡献 pgoutput 协议解析代码
By @diabloneo&lt;/li&gt;
      &lt;li&gt;性能测试
        &lt;ul&gt;
          &lt;li&gt;Postgres 13&lt;/li&gt;
          &lt;li&gt;Intel(R) Xeon(R) Gold 5218R CPU @ 2.10GHz&lt;/li&gt;
          &lt;li&gt;每分钟可以发送超过 50,000 个简单的事务&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;生产版本使用的是 Postgres 14&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;问题预判&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;逻辑事件只能包含部分的数据库操作
    &lt;ul&gt;
      &lt;li&gt;缺少的那些，在我们的系统里都可以通过带外的方式来解决。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;逻辑复制事件不会包含一行记录的所有内容。
    &lt;ul&gt;
      &lt;li&gt;我们只会依赖消息中的 id 和几个时间戳字段，整个记录的内容会使用 ORM 从数据库重新读取。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;事件丢失 
我们一定要做好事件可能会丢失的准备，提供后备方案。&lt;/li&gt;
  &lt;li&gt;处理阻塞导致 WAL 写满的情况&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;架构设计&quot;&gt;架构设计&lt;/h2&gt;

&lt;h3 id=&quot;整体架构&quot;&gt;整体架构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00039_architecture.png&quot; alt=&quot;architecture&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;API Server
    &lt;ul&gt;
      &lt;li&gt;负责和用户交互，并进行数据库读写&lt;/li&gt;
      &lt;li&gt;消费  LR 消息，用于发送 websocket 消息等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Controller
    &lt;ul&gt;
      &lt;li&gt;消费 LR 消息，用于实现业务逻辑&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Agent
    &lt;ul&gt;
      &lt;li&gt;LR 消息会触发 informer 重新载入数据&lt;/li&gt;
      &lt;li&gt;会根据 cache 中的数据对业务做收敛&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;app-设计&quot;&gt;App 设计&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00040_app_1.png&quot; alt=&quot;app_1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;代表一个业务逻辑的分组，例如虚拟机，块存储等&lt;/li&gt;
  &lt;li&gt;App 是在另外一个维度上把 apiserver, controller 和 agent 联系在了一起&lt;/li&gt;
  &lt;li&gt;API server 和 controller 之间使用 LR 作为联系方式&lt;/li&gt;
  &lt;li&gt;Controller 和 agent 之间使用 informer 作为联系方式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00041_app_2.png&quot; alt=&quot;app_2&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每个 app 会注册一个独立的 publication + slot&lt;/li&gt;
  &lt;li&gt;App 按照顺序处理自己订阅的事件&lt;/li&gt;
  &lt;li&gt;不同的 app 会处理同一个事件
    &lt;ul&gt;
      &lt;li&gt;更新数据库时，需要使用 etag 这类乐观锁机制&lt;/li&gt;
      &lt;li&gt;遇到 etag 冲突时，自动重试&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cdc-封装与应用&quot;&gt;CDC 封装与应用&lt;/h2&gt;

&lt;h3 id=&quot;cdc-event&quot;&gt;CDC Event&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00042_cdc_event_flow.png&quot; alt=&quot;cdc_event_flow&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Postgres 的 LR 消息过于原始，不利于应用开发&lt;/li&gt;
  &lt;li&gt;Event and EventGroup
    &lt;ul&gt;
      &lt;li&gt;Event: Insert/Update 消息，Relation 用于触发一个 cache 的更新，Commit 被映射为 FlushLSN&lt;/li&gt;
      &lt;li&gt;EventGroup: 一个事务中的所有 数据操作 Event 的集合&lt;/li&gt;
      &lt;li&gt;CDC Manager 会将 LR 消息转化为对应的 ORM Model&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cdc-的应用&quot;&gt;CDC 的应用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;App
    &lt;ul&gt;
      &lt;li&gt;消费 event，根据 event 执行数据库的 update 操作&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;API Client Manager
    &lt;ul&gt;
      &lt;li&gt;监听 Node 和 Service 资源的 event，对所管理的 API Client 进行操作：创建、删除、failover 等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Websocket 通知
    &lt;ul&gt;
      &lt;li&gt;监听所有资源的 event，一旦资源有变动就可以发送 websocket 通知。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Informer Monitor
    &lt;ul&gt;
      &lt;li&gt;监听所有资源的 event，通过 etcd 通知 agent reload 相关的缓存数据&lt;/li&gt;
      &lt;li&gt;Agent 不直接消费 CDC event 的原因
        &lt;ul&gt;
          &lt;li&gt;为了实现 agent 的 scale-out，agent 不直接访问数据库&lt;/li&gt;
          &lt;li&gt;Agent 中的 executor 需要一次载入某个时刻 (RR Transaction) 的多个表的数据&lt;/li&gt;
          &lt;li&gt;Executor 的运行需要综合定时器触发和 CDC event 触发等多种原因&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00043_informer_architecture_1.png&quot; alt=&quot;informer_architecture_1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;关键问题处理&quot;&gt;关键问题处理&lt;/h2&gt;

&lt;h3 id=&quot;slot-的管理--未使用-patroni-时&quot;&gt;Slot 的管理 – 未使用 Patroni 时&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在我们的 controller 程序中进行管理（在 controller leader 节点进行管理）。
    &lt;ul&gt;
      &lt;li&gt;基本的做法是在 controller 启动时，检查 app 对应的 slot 是否存在，如果不存在则创建。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;存在三个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第一次启动耗时间较长，可能会丢 CDC event&lt;/li&gt;
  &lt;li&gt;Controller failover 时会漏掉一些 CDC event&lt;/li&gt;
  &lt;li&gt;Patroni 会尝试 drop 掉它不认识的 slot&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;slot-的管理--使用-patroni&quot;&gt;Slot 的管理 – 使用 Patroni&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;我们将 slot 管理交给 Patroni 来做，同时解决了上面这些问题：
    &lt;ul&gt;
      &lt;li&gt;我们实现了一个 slot sync 命令，会在系统安装时通过 Patroni 创建好 slot。因为所有的程序都是在这个过程之后启动的，所以避免了 CDC 事件的丢失。&lt;/li&gt;
      &lt;li&gt;Patroni 管理 slots 后，它会在 primary/replicas 之间自动同步 slot 的 restart_lsn(10s 一次)。
        &lt;ul&gt;
          &lt;li&gt;Failover 后会收到重复的 CDC 事件，需要做幂等处理。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;所有 slot 受 Patroni 管控，所以 Patroni 也不会再去 drop slots。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;临时-slot-的应用&quot;&gt;临时 slot 的应用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;临时 slot
    &lt;ul&gt;
      &lt;li&gt;不会将 slot 的信息持久化&lt;/li&gt;
      &lt;li&gt;会话结束或者发生错误时，会自动销毁。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用场景
    &lt;ul&gt;
      &lt;li&gt;允许 CDC 事件丢失的场景
        &lt;ul&gt;
          &lt;li&gt;Websocket&lt;/li&gt;
          &lt;li&gt;API Client Manager&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;更换为临时 slot 的原因
    &lt;ul&gt;
      &lt;li&gt;非 Patroni 管理的持久化 slot，会被 Patroni 尝试 drop，会产生很多 log。&lt;/li&gt;
      &lt;li&gt;Patroni 在管理 slot 的时候，会过滤掉所有的临时 slot。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;升级&quot;&gt;升级&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00044_upgrade.png&quot; alt=&quot;upgrade&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Publication 必须在 slot 之前创建，否则 subscribe 时，server 会报找不到 publication (Postgres 实现导致的):&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://postgrespro.com/list/thread-id/2471266&quot;&gt;Thread: How is this possible “publication does not exist”&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;cdc-事件丢失&quot;&gt;CDC 事件丢失&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;丢失原因
    &lt;ul&gt;
      &lt;li&gt;WAL 满了，drop 掉老数据&lt;/li&gt;
      &lt;li&gt;Bug&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CDC 事件重放机制
    &lt;ul&gt;
      &lt;li&gt;避免线上出现数据丢失的情况时，需要手动去做数据库操作&lt;/li&gt;
      &lt;li&gt;需要能够区分原始事件和重放的事件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cdc-事件重放机制---insert&quot;&gt;CDC 事件重放机制 - Insert&lt;/h4&gt;

&lt;p&gt;数据库的 insert 事件只能通过插入新的记录来触发。如果我们要触发一个 insert 事件，那么就得把记录先删除，然后再插入一次。这个方案有几个问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;因为重新插入记录，所以无法区分一条记录是否被重放了。&lt;/li&gt;
  &lt;li&gt;删除记录会导致一条需要回收的记录产生，这会增大数据库的空间。虽然这个数量不会很多，但是还是尽量避免。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;方案：在 model 中统一加入一个字段 CdcInserted ，类型是 *time.Time 。重放的流程如下：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00045_cdc_replay_insert.png&quot; alt=&quot;cdc_replay_insert&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cdc-事件重放机制---update&quot;&gt;CDC 事件重放机制 - Update&lt;/h4&gt;

&lt;p&gt;Update event 的重放其实可以直接通过更新 UpdatedAt 字段来触发，不过这样不会保存重放的记录，也无法标记是一个重放的事件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方案：在 model 中统一加入一个字段 CdcUpdated ，类型是 *time.Time 。重放的流程如下：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00046_cdc_replay_update.png&quot; alt=&quot;cdc_replay_update&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cdc-事件重放机制--replay-命令&quot;&gt;CDC 事件重放机制 – replay 命令&lt;/h4&gt;

&lt;p&gt;为了可以在线上方便的进行操作，我们按照资源的视角开发了一个命令行工具：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sddc-manage cdc replay --help 
NAME: 
    manage cdc replay - Replay CDC events 
USAGE: 
    manage cdc replay [command options] [arguments...] 
OPTIONS: 
    --object-type value, -t value Object type to be replayed (required) 
    --event value, -e value Replay event type (required) (insert|update) 
    --id value Filter: ID of object to be replayed 
    --from-id value Filter: Object id &amp;gt;= from-id will be replayed 
    --to-id value Filter: Object id &amp;lt;= to-id will be replayed 
    --help, -h show help

$ sddc-manage cdc replay --id 1 -t VmImageSpec -e insert 
$ sddc-manage cdc replay --id 1 -t VirtualMachineSpec -e update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;h3 id=&quot;运行数据&quot;&gt;运行数据&lt;/h3&gt;

&lt;p&gt;当前版本的 slot 数量：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Persistent: 40&lt;/li&gt;
  &lt;li&gt;Temporary: 6&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个内部使用的生产环境。Controller leader 运行了 18 天，接收的 LR 消息数量：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Update: 966961&lt;/li&gt;
  &lt;li&gt;Insert: 6276&lt;/li&gt;
  &lt;li&gt;Relation: 1149&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;总结-1&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;亮点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Postgres 的逻辑复制很适合在分布式系统中使用
    &lt;ul&gt;
      &lt;li&gt;可以在很大程度上免去对消息队列的使用，简化系统架构&lt;/li&gt;
      &lt;li&gt;性能不错&lt;/li&gt;
      &lt;li&gt;稳定性不错&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Golang 的生态对于逻辑复制的支持已经比较不错&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的地方：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;需要了解逻辑复制的原理，并且能够管理 publication 和 slot&lt;/li&gt;
  &lt;li&gt;消费 LR 消息的时候，尽可能的不阻塞，避免 WAL 被 drop&lt;/li&gt;
  &lt;li&gt;需要理解 CDC 的思想，不能将逻辑复制当成消息队列来使用&lt;/li&gt;
  &lt;li&gt;LR 消息的消费者，尽可能实现幂等操作&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 20 Mar 2023 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2023/03/20/PGConfChina-2023-logical-replication-and-cdc/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2023/03/20/PGConfChina-2023-logical-replication-and-cdc/</guid>
        
        <category>database</category>
        
        <category>distributed-computing</category>
        
        
      </item>
    
      <item>
        <title>Sysfs Note -- 2</title>
        <description>&lt;p&gt;本文的内容对于一个 block device 设备的 sysfs 文件，如何找到对应的代码。&lt;/p&gt;

&lt;h2 id=&quot;kobject-的相关函数&quot;&gt;kobject 的相关函数&lt;/h2&gt;

&lt;p&gt;在 kernel 的文档 &lt;em&gt;Documentation/core-api/kobject.rst&lt;/em&gt; 中，可以读到 kobject 操作的一些函数，对于阅读内核代码来说，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kobject_add&lt;/code&gt; 函数是比较重要的，它表示添加了一个目录到 sysfs 下。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    int kobject_add(struct kobject *kobj, struct kobject *parent,
                    const char *fmt, ...);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;如何找到一个-block-device-sysfs-文件对应的操作代码&quot;&gt;如何找到一个 block device sysfs 文件对应的操作代码&lt;/h2&gt;

&lt;h3 id=&quot;queue-目录&quot;&gt;&lt;em&gt;queue&lt;/em&gt; 目录&lt;/h3&gt;

&lt;p&gt;Sysfs 中的目录对应的是 kobject，该目录下的文件对应的是这个 kobject 的属性。&lt;/p&gt;

&lt;p&gt;我们以一个 nvme 硬盘的 &lt;em&gt;queue/discard_max_bytes&lt;/em&gt; 文件为例，来找到对应的代码。首先在 block 目录下搜索 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kobject_add&lt;/code&gt; 的调用，找到将 queue 添加到 sysfs 的地方，在 &lt;em&gt;block/blk-sysfs.c&lt;/em&gt; 文件中&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * blk_register_queue - register a block layer queue with sysfs
 * @disk: Disk of which the request queue should be registered with sysfs.
 */
int blk_register_queue(struct gendisk *disk)
{
        struct request_queue *q = disk-&amp;gt;queue;
        int ret;

        mutex_lock(&amp;amp;q-&amp;gt;sysfs_dir_lock);
        kobject_init(&amp;amp;disk-&amp;gt;queue_kobj, &amp;amp;blk_queue_ktype);
        ret = kobject_add(&amp;amp;disk-&amp;gt;queue_kobj, &amp;amp;disk_to_dev(disk)-&amp;gt;kobj, &quot;queue&quot;);
        if (ret &amp;lt; 0)
                goto out_put_queue_kobj;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后你可以搜索调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blk_register_queue&lt;/code&gt; 的地方，是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;device_add_disk&lt;/code&gt; 函数，然后再到 nvme 驱动目录下搜索调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;device_add_disk&lt;/code&gt; 的地方，最终你会得到一个调用链：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nvme_scan_work
  -&amp;gt; nvme_scan_ns_list
    -&amp;gt; nvme_scan_ns
      -&amp;gt; nvme_alloc_ns
        -&amp;gt; device_add_disk
          -&amp;gt; blk_register_queue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;简单的说，驱动发现一个 nvme 硬盘后，就会将信息添加到内核中，然后会在 sysfs 里创建这个硬盘的下的 queue 目录。&lt;/p&gt;

&lt;h3 id=&quot;queuediscard_max_bytes-文件&quot;&gt;&lt;em&gt;queue/discard_max_bytes&lt;/em&gt; 文件&lt;/h3&gt;

&lt;p&gt;我们以 &lt;em&gt;queue/discard_max_bytes&lt;/em&gt; 属性为例，来看看它是如何在代码中实现的。&lt;/p&gt;

&lt;h4 id=&quot;device_attribute&quot;&gt;device_attribute&lt;/h4&gt;

&lt;p&gt;首先，了解一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;attribute&lt;/code&gt;。 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;attribute&lt;/code&gt; 是定义用来对应一个 sysfs 中的文件，即 kobject 的一个属性的。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;attribute&lt;/code&gt; 单独使用时没有意义，一般需要加上操作函数，所以 block device 自己定义了如下的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;device_attribute&lt;/code&gt; ( &lt;em&gt;include/linux/device.h&lt;/em&gt; )：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct device_attribute {
    struct attribute        attr;
    ssize_t (*show)(struct device *dev, struct device_attribute *attr,
        char *buf);
    ssize_t (*store)(struct device *dev, struct device_attribute *attr,
        const char *buf, size_t count);
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个是设备目录下通用的定义，除了基本的属性外，还定义了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store&lt;/code&gt; 两个方法属性，顾名思义，一个是用来展示，一个是用来设置的，也就对应到了一个 sysfs 文件的读写操作。&lt;/p&gt;

&lt;h4 id=&quot;discard_max_bytes-属性&quot;&gt;discard_max_bytes 属性&lt;/h4&gt;

&lt;p&gt;找代码的方式是在 &lt;em&gt;block/&lt;/em&gt; 目录下搜索 &lt;strong&gt;discard_max_bytes&lt;/strong&gt;，你就可以找到很多相关的代码。下面这行代码说明这个是 queue/ 目录下的一个 RW 属性：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;QUEUE_RW_ENTRY(queue_discard_max, &quot;discard_max_bytes&quot;);
QUEUE_RW_ENTRY 这个宏的定义如下：
#define QUEUE_RW_ENTRY(_prefix, _name)                        \
static struct queue_sysfs_entry _prefix##_entry = {        \
        .attr        = { .name = _name, .mode = 0644 },        \
        .show        = _prefix##_show,                        \
        .store        = _prefix##_store,                        \
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到注册的函数名字应该是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queue_discard_max_show&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queue_discard_max_store&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;属性的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show&lt;/code&gt; 函数是被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queue_attr_show&lt;/code&gt; 函数使用的，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store&lt;/code&gt; 函数则是被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queue_attr_store&lt;/code&gt; 函数使用：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static ssize_t
queue_attr_show(struct kobject *kobj, struct attribute *attr, char *page)
{
        struct queue_sysfs_entry *entry = to_queue(attr);
        struct gendisk *disk = container_of(kobj, struct gendisk, queue_kobj);
        struct request_queue *q = disk-&amp;gt;queue;
        ssize_t res;

        if (!entry-&amp;gt;show)
                return -EIO;
        mutex_lock(&amp;amp;q-&amp;gt;sysfs_lock);
        res = entry-&amp;gt;show(q, page);  /* 这行是调用各个属性 show 函数的地方 */
        mutex_unlock(&amp;amp;q-&amp;gt;sysfs_lock);
        return res;
}

static ssize_t
queue_attr_store(struct kobject *kobj, struct attribute *attr,
                    const char *page, size_t length)
{
        struct queue_sysfs_entry *entry = to_queue(attr);
        struct gendisk *disk = container_of(kobj, struct gendisk, queue_kobj);
        struct request_queue *q = disk-&amp;gt;queue;
        ssize_t res;

        if (!entry-&amp;gt;store)
                return -EIO;

        mutex_lock(&amp;amp;q-&amp;gt;sysfs_lock);
        res = entry-&amp;gt;store(q, page, length);  /* 这行是调用各个属性 store 函数的地方 */
        mutex_unlock(&amp;amp;q-&amp;gt;sysfs_lock);
        return res;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;回过头来看 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queue_discard_max_show&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queue_discard_max_store&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show&lt;/code&gt; 函数实现比较简单，就是将内容打印到提供的字符数组里：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static ssize_t queue_discard_max_show(struct request_queue *q, char *page)
{
        return sprintf(page, &quot;%llu\n&quot;,
                       (unsigned long long)q-&amp;gt;limits.max_discard_sectors &amp;lt;&amp;lt; 9);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store&lt;/code&gt; 函数比较长一点，但是逻辑也简单：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static ssize_t queue_discard_max_store(struct request_queue *q,
                                       const char *page, size_t count)
{
        unsigned long max_discard;
        ssize_t ret = queue_var_store(&amp;amp;max_discard, page, count);

        if (ret &amp;lt; 0)
                return ret;

        if (max_discard &amp;amp; (q-&amp;gt;limits.discard_granularity - 1))
                return -EINVAL;

        max_discard &amp;gt;&amp;gt;= 9;  /* 512 bytes 一个 sector */
        if (max_discard &amp;gt; UINT_MAX)
                return -EINVAL;

        if (max_discard &amp;gt; q-&amp;gt;limits.max_hw_discard_sectors)
                max_discard = q-&amp;gt;limits.max_hw_discard_sectors;

        /*    
         * 上面都是关于数据合法性的判断，这里做了设置    
         * 从这里就可以知道，后面要知道设置的 discard_max_bytes 如何使用，
         * 要在代码里搜索 max_discard_sectors
         */
        q-&amp;gt;limits.max_discard_sectors = max_discard;
        return ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;在 kernel 中查找 sysfs 的对应代码还是比较容易的，代码的接口都很规范，而且容易查找。
但是可以发现，sysfs 中的属性的名字和代码中的成员名字不一定一致，所以掌握这个代码查找技能是很必要的。&lt;/p&gt;
</description>
        <pubDate>Fri, 17 Mar 2023 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2023/03/17/sysfs-note-2/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2023/03/17/sysfs-note-2/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Sysfs Note -- 1</title>
        <description>&lt;h2 id=&quot;sysfs&quot;&gt;sysfs&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;sysfs&lt;/strong&gt; 是一个内存文件系统，用于将内核的数据结构暴露出来。&lt;/p&gt;

&lt;p&gt;任何 kobject 在系统中注册，就会有一个目录在 sysfs 中被创建出来。这个目录是作为 kobject 的父对象所在的目录的子目录创建的。每个 kobject 的属性，会以目录中的普通文件的形式出现。&lt;/p&gt;

&lt;h2 id=&quot;kobject&quot;&gt;kobject&lt;/h2&gt;

&lt;p&gt;Kobject 是一个类型为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct kobject&lt;/code&gt; 的对象，它包含 name, ref count, parent pointer 等，使得 kobject 可以被组织成层次结构，并且通过 sysfs 暴露出来。Kobject 本身没有包含其他具体的功能，它主要通过被嵌入到其他的结构体中来使用。&lt;/p&gt;

&lt;h2 id=&quot;uevent&quot;&gt;uevent&lt;/h2&gt;

&lt;p&gt;Sysfs 的 device 目录下有个 &lt;em&gt;*uevent&lt;/em&gt; 文件。uevent 的是 udev event 的缩写。&lt;/p&gt;

&lt;p&gt;uevent 这个文件可读可写，当你读这个文件的时候，会返回这个设备最后一次被 kernel 发送的 udev 事件（这里就是这个设备被 add  event，remove 的不会存在，因为 remove 发生后，整个设备目录都没了）。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@centos8 block]# cat nvme0n1/uevent
MAJOR=259
MINOR=0
DEVNAME=nvme0n1
DEVTYPE=disk
DISKSEQ=1
[root@centos8 block]# cat sdc/uevent
MAJOR=8
MINOR=32
DEVNAME=sdc
DEVTYPE=disk
DISKSEQ=4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;uevent 本身是一个 kernel 的机制，用于通知用户态的 udev 程序，关于设备的相关事件。在新的系统中，用户态的程序是在 systemd 中实现的，即 &lt;strong&gt;systemd-udevd&lt;/strong&gt; ：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@centos8 block]# systemctl cat systemd-udevd
# /usr/lib/systemd/system/systemd-udevd.service
#  SPDX-License-Identifier: LGPL-2.1+
#
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=udev Kernel Device Manager
Documentation=man:systemd-udevd.service(8) man:udev(7)
DefaultDependencies=no
After=systemd-sysusers.service systemd-hwdb-update.service
Before=sysinit.target
ConditionPathIsReadWrite=/sys

[Service]
Type=notify
OOMScoreAdjust=-1000
Sockets=systemd-udevd-control.socket systemd-udevd-kernel.socket
Restart=always
RestartSec=0
ExecStart=/usr/lib/systemd/systemd-udevd
KillMode=mixed
WatchdogSec=3min
TasksMax=infinity
PrivateMounts=yes
MemoryDenyWriteExecute=yes
RestrictAddressFamilies=AF_UNIX AF_NETLINK AF_INET AF_INET6
RestrictRealtime=yes
RestrictSUIDSGID=yes
SystemCallFilter=@system-service @module @raw-io
SystemCallErrorNumber=EPERM
SystemCallArchitectures=native
LockPersonality=yes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个程序并不是通过逐个读取 sysfs 的 uevent 文件的内容来获取信息的，而是通过 &lt;strong&gt;uevent netlink&lt;/strong&gt; 来获得内核发送的 uevent：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@centos8 block]# ps -ef | grep systemd-udevd
root        1830       1  0 Feb18 ?        00:00:01 /usr/lib/systemd/systemd-udevd
root      807799 3741741  0 23:03 pts/93   00:00:00 grep --color=auto systemd-udevd
[root@centos8 block]# lsof -p 1830 | grep -i uevent
systemd-u 1830 root    3u  netlink                         0t0     92397 KOBJECT_UEVENT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;include/uapi/linux/netlink.h&lt;/em&gt; 文件中定义了这个 netlink 类型&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#define NETLINK_KOBJECT_UEVENT        15        /* Kernel messages to userspace */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;既然 udev 是通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NETLINK_KOBJECT_UEVENT&lt;/code&gt; 来接收事件的，为什么还需要 uevent 文件呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个是用于解决开机启动以及 udevd 重启的情况。当 udevd 启动时，它会扫描 sysfs 中所有设备的 uevent 文件，然后针对每个文件写入一个 ADD 内容，这样就可以触发 kernel 再一次通知和该设备有关的事件，然后 udevd 就可以收到该事件，并进行 udev rule 的处理。&lt;/p&gt;

&lt;h2 id=&quot;ref&quot;&gt;Ref&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://documentation.suse.com/sles/12-SP5/html/SLES-all/cha-udev.html&quot;&gt;https://documentation.suse.com/sles/12-SP5/html/SLES-all/cha-udev.html&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://lwn.net/Articles/646617/&quot;&gt;https://lwn.net/Articles/646617/&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://unix.stackexchange.com/questions/550037/how-does-udev-uevent-work&quot;&gt;https://unix.stackexchange.com/questions/550037/how-does-udev-uevent-work&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 01 Mar 2023 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2023/03/01/sysfs-note-1/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2023/03/01/sysfs-note-1/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Kubernetes 代码笔记 -- 2</title>
        <description>&lt;h2 id=&quot;apimachinery-中的概念&quot;&gt;apimachinery 中的概念&lt;/h2&gt;

&lt;p&gt;Kubernetes 的 api 相关代码中有很多概念都是 k8s 独有的，需要专门理解一下，才方便研究 k8s 代码。&lt;/p&gt;

&lt;p&gt;Kubebuilder 项目有一篇文章比较好的介绍了这些关键概念的理解，可以先阅读一下：&lt;em&gt;&lt;a href=&quot;https://book.kubebuilder.io/cronjob-tutorial/gvks.html&quot;&gt;https://book.kubebuilder.io/cronjob-tutorial/gvks.html&lt;/a&gt;&lt;/em&gt;。我这里写的是我个人的理解。&lt;/p&gt;

&lt;h3 id=&quot;gvk-groupversionkind&quot;&gt;GVK: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GroupVersionKind&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;k8s.io/apimachinery/pkg/runtime/schema/group_version.go&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GroupVersionKind unambiguously identifies a kind.  It doesn&apos;t anonymously include GroupVersion
// to avoid automatic coercion.  It doesn&apos;t use a GroupVersion to avoid custom marshalling
type GroupVersionKind struct {
	Group   string
	Version string
	Kind    string
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个结构体包含了 API 的 group, version 和 kind 信息。这里的 kind 是对应的 Go 结构体的 type 名称。比如 &lt;strong&gt;StatefulSet&lt;/strong&gt; 就是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GroupVersionKind{Group: &quot;apps&quot;, Version: &quot;v1&quot;, Kind: &quot;StatefulSet&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;gvr-groupversionresource&quot;&gt;GVR: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GroupVersionResource&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;k8s.io/apimachinery/pkg/runtime/schema/group_version.go&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GroupVersionResource unambiguously identifies a resource.  It doesn&apos;t anonymously include GroupVersion
// to avoid automatic coercion.  It doesn&apos;t use a GroupVersion to avoid custom marshalling
type GroupVersionResource struct {
	Group    string
	Version  string
	Resource string
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GroupVersionResource{Group: &quot;rbac.authorization.k8s.io&quot;, Version: &quot;v1&quot;, Resource: &quot;clusterroles&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个结构体包含了 API 的 group, version 和 resource 信息。这里的 resource 对应的是 API 路径里的名字。很容易会搞混 resource 和 kind 的区别，我觉得可以这么理解：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Resource 是 API 侧的概念，是根据 API 路径推导出来的资源类型名称，例如 pods, deployments 等（下面会说单复数的问题）。&lt;/li&gt;
  &lt;li&gt;Kind 是 API 路径里得到这个资源类型名称所对应的 Go 的结构体的 type 名称。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在现有的代码中，GVR 在 apiserver 端是比较少使用的，反而是在 controller 和 client 中会用得多一些。&lt;/p&gt;

&lt;h4 id=&quot;apiserver-中的使用&quot;&gt;apiserver 中的使用&lt;/h4&gt;

&lt;p&gt;下面这个函数中会添加 API 请求的 handler。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; k8s.io/apiserver/pkg/endpoints/installer.go: func (a *APIInstaller) registerResourceHandlers()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APIInstaller&lt;/code&gt; 中已经包含了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APIGroupVersion&lt;/code&gt;，所以在添加的过程中，可以根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GroupVersion&lt;/code&gt; 直接得到 GVK：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	fqKindToRegister, err := GetResourceKind(a.group.GroupVersion, storage, a.group.Typer)
	if err != nil {
		return nil, nil, err
	}

	...

	reqScope := handlers.RequestScope{
		# 这里也生成了 GVR
		Resource:    a.group.GroupVersion.WithResource(resource),
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;restmapper&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RESTMapper&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;其他地方的使用更多的是依赖于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RESTMapper&lt;/code&gt; 来根据 GVR 获得 GVK。&lt;/p&gt;

&lt;p&gt;有好几种 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RESTMapper&lt;/code&gt;，默认的如下：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;k8s.io/apimachinery/pkg/api/meta/restmapper.go&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// DefaultRESTMapper exposes mappings between the types defined in a
// runtime.Scheme. It assumes that all types defined the provided scheme
// can be mapped with the provided MetadataAccessor and Codec interfaces.
//
// The resource name of a Kind is defined as the lowercase,
// English-plural version of the Kind string.
// When converting from resource to Kind, the singular version of the
// resource name is also accepted for convenience.
//
// TODO: Only accept plural for some operations for increased control?
// (`get pod bar` vs `get pods bar`)
type DefaultRESTMapper struct {
	defaultGroupVersions []schema.GroupVersion

	resourceToKind       map[schema.GroupVersionResource]schema.GroupVersionKind
	kindToPluralResource map[schema.GroupVersionKind]schema.GroupVersionResource
	kindToScope          map[schema.GroupVersionKind]RESTScope
	singularToPlural     map[schema.GroupVersionResource]schema.GroupVersionResource
	pluralToSingular     map[schema.GroupVersionResource]schema.GroupVersionResource
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从它的内容可以看出，它是在 resource 和 kind 之间做映射的。同时，它还指出了，resource name 是根据 kind 来的，小写且是复数。不过，为了方便，也支持单数形式的 resource name。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefaultRESTMapper&lt;/code&gt; 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RESTMapper&lt;/code&gt; interface。这个 interface 定义了一些方法用来实现转换，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KindFor&lt;/code&gt; 根据 GVR 得到 GVK:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	// KindFor takes a partial resource and returns the single match.  Returns an error if there are multiple matches
	KindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;根据使用场景补充，k8s 中还实现了好几个不同的 RESTMapper，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MultiRESTMapper&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefferedDiscoveryRESTMapper&lt;/code&gt; 等。&lt;/p&gt;

&lt;h3 id=&quot;scheme&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;k8s.io/apimachinery/pkg/runtime/scheme.go&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt; 的主要工作就是保存 Go 类型和对应的 API 信息之间的关系。通过它的一些成员可以看出它的设计目标就是保存这种映射关系：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Scheme struct {
	// gvkToType allows one to figure out the go type of an object with
	// the given version and name.
	gvkToType map[schema.GroupVersionKind]reflect.Type

	// typeToGVK allows one to find metadata for a given go object.
	// The reflect.Type we index by should *not* be a pointer.
	typeToGVK map[reflect.Type][]schema.GroupVersionKind

	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一般来说，一大堆的 API 可以共用一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt;，比如 legacy API 都是共用下面这个文件中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt; 对象：&lt;em&gt;pkg/api/legacyscheme/scheme.go&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;代码中一般是使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt; 对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AddKnownTypes&lt;/code&gt; 方法把 Go 对象添加到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt; 中的。搜索这个方法可以找到 API 对象被添加的路径。以 rbac 为例：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;pkg/apis/rbac/register.go&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GroupName is the name of this API group.
const GroupName = &quot;rbac.authorization.k8s.io&quot;

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: GroupName, Version: runtime.APIVersionInternal}

// SchemeBuilder is a function that calls Register for you.
var (
	SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)
	AddToScheme   = SchemeBuilder.AddToScheme
)

// Adds the list of known types to the given scheme.
func addKnownTypes(scheme *runtime.Scheme) error {
	scheme.AddKnownTypes(SchemeGroupVersion,
		&amp;amp;Role{},
		&amp;amp;RoleBinding{},
		&amp;amp;RoleBindingList{},
		&amp;amp;RoleList{},

		&amp;amp;ClusterRole{},
		&amp;amp;ClusterRoleBinding{},
		&amp;amp;ClusterRoleBindingList{},
		&amp;amp;ClusterRoleList{},
	)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外，你可以根据上面代码中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AddToScheme&lt;/code&gt; 方法推导出：当这个方法被调用时，就会执行这些添加操作。因此，也可以在代码中搜索 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rbac.*AddToScheme&lt;/code&gt; 来找到添加的地方：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;pkg/apis/rbac/install/install.go&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func init() {
	Install(legacyscheme.Scheme)
}

// Install registers the API group and adds types to a scheme
func Install(scheme *runtime.Scheme) {
	utilruntime.Must(rbac.AddToScheme(scheme))
	utilruntime.Must(v1.AddToScheme(scheme))
	utilruntime.Must(v1beta1.AddToScheme(scheme))
	utilruntime.Must(v1alpha1.AddToScheme(scheme))
	utilruntime.Must(scheme.SetVersionPriority(v1.SchemeGroupVersion, v1beta1.SchemeGroupVersion, v1alpha1.SchemeGroupVersion))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以，只要这个 pkg 被 import，rbac 的这些信息就会被注册到 legacy 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt; 中。在这个 API Group 的 storage 被初始化的时候，这个 pkg 就会被 import：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; pkg/registry/rbac/rest/storage_rest.go: func (p RESTStorageProvider) NewRESTStorage()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 13 Feb 2023 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2023/02/13/kubernetes-code-note-2/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2023/02/13/kubernetes-code-note-2/</guid>
        
        <category>kubernetes</category>
        
        
      </item>
    
      <item>
        <title>Kubernetes 代码笔记 -- 1</title>
        <description>&lt;h2 id=&quot;apiserver-中的路由注册&quot;&gt;apiserver 中的路由注册&lt;/h2&gt;

&lt;h3 id=&quot;在哪里进行的路由注册&quot;&gt;在哪里进行的路由注册？&lt;/h3&gt;

&lt;p&gt;我们以 core API 为例 (也称为 legacy API)，kube-apiserver 从启动开始，到开始注册 go-restful 之前的代码路径是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; cmd/kube-apiserver/app/server.go: func CreateServerChain()
	-&amp;gt; cmd/kube-apiserver/app/server.go: func CreateKubeAPIServer()
		-&amp;gt; pkg/controlplane/instance.go: func (c *completedConfig) New()
			-&amp;gt; k8s.io/apiserver/pkg/server/config.go func (c completedConfig) New()
				-&amp;gt; k8s.io/apiserver/pkg/server/handler.go NewAPIServerHandler()
					# 这里会初始化 restful.Container
				-&amp;gt; k8s.io/apiserver/pkg/server/config.go installAPI()
					# 这里会添加 profile, metric 等固定的 API
			-&amp;gt; pkg/controlplane/instance.go: func (m *Instance) InstallLegacyAPI()
				-&amp;gt; k8s.io/apiserver/pkg/server/genericapiserver.go: func (s *GenericAPIServer) InstallLegacyAPIGroup()
					-&amp;gt; k8s.io/apiserver/pkg/server/genericapiserver.go: func (s *GenericAPIServer) installAPIResources()
						-&amp;gt; k8s.io/apiserver/pkg/endpoints/groupversion.go: func (g *APIGroupVersion) InstallREST()
							-&amp;gt; k8s.io/apiserver/pkg/endpoints/installer.go: func (a *APIInstaller) Install()
								# 这里会创建 restful.WebService 对象
								-&amp;gt; k8s.io/apiserver/pkg/endpoints/installer.go: func (a *APIInstaller) registerResourceHandlers()
									# 这个函数很长，大概有 800 行，就是根据 API 对象的信息，向 restful.WebService 中添加路由。
							# 将得到的 restful.WebService 添加到 restful.Container 中。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面是大概的流程结束之后，就会开始运行 apiserver，大概流程是如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; cmd/kube-apiserver/app/server.go: Run()
	-&amp;gt; k8s.io/kube-aggregator/pkg/apiserver/apiserver.go: func (s *APIAggregator) PrepareRun()
		-&amp;gt; k8s.io/apiserver/pkg/server/genericapiserver.go: func (s *GenericAPIServer) PrepareRun()
	-&amp;gt; k8s.io/kube-aggregator/pkg/apiserver/apiserver.go: func (s preparedAPIAggregator) Run()
		-&amp;gt; k8s.io/apiserver/pkg/server/genericapiserver.go: func (s preparedGenericAPIServer) Run()
			# 这里最终根据 GenericAPIServer.APIServerHandler 来创建 http server
			# GenericAPIServer.APIServerHandler 则会将请求路由到它内部的 restful.Container 中，
			# 这个 container 包含了我们注册的 API
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;注册了哪些路由&quot;&gt;注册了哪些路由？&lt;/h3&gt;

&lt;p&gt;上一小节提到了，每个资源的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restful.WebService&lt;/code&gt; 中注册的路由都在如下方法中实现：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k8s.io/apiserver/pkg/endpoints/installer.go: func (a *APIInstaller) registerResourceHandlers()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个函数的主要工具就是根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APIGroupVersion&lt;/code&gt; 的信息生成需要添加到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restful.WebService&lt;/code&gt; 中的 route 内容，最主要部分就是指定 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handler&lt;/code&gt;，如下代码所示：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;			route := ws.GET(action.Path).To(handler).	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为 kubernetes 的所有资源的 API 都是统一的，所以你可以在这个函数里看到所有 API 的路由实现。&lt;/p&gt;

&lt;h3 id=&quot;路由的-handler-在哪里&quot;&gt;路由的 handler 在哪里？&lt;/h3&gt;

&lt;p&gt;找到一个路由后，我们就知道了 path，解析来还需要知道它是如何被 handle 的，也就是要找到 handler 的实现。&lt;/p&gt;

&lt;p&gt;只要你继续跟进 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func (a *APIInstaller) registerResourceHandlers()&lt;/code&gt; 的代码，就会发现，所有的 handler 都是在&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k8s.io/apiserver/pkg/endpoints/handlers&lt;/code&gt; 这个模块中实现的。比如资源的 List 接口，就是在如下位置实现：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;k8s.io/apiserver/pkg/endpoints/handlers/get.go: func ListResource()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个函数里，你可以看到 List 的实现，以及 Watch 的实现。&lt;/p&gt;

&lt;h3 id=&quot;handler-和资源的实现是如何关联起来的&quot;&gt;Handler 和资源的实现是如何关联起来的？&lt;/h3&gt;

&lt;p&gt;上面提到的功能，都是 apiserver 统一实现的，也就是说，每个资源都不需要自己实现这些部分。每个资源需要实现的部分，主要是数据操作部分。&lt;/p&gt;

&lt;h4 id=&quot;registry&quot;&gt;Registry&lt;/h4&gt;

&lt;p&gt;这就要提到 &lt;strong&gt;registry&lt;/strong&gt;  这个概念了，这个 registry 是 kubernetes 项目内部的代码上的概念，不是容器镜像那个概念。&lt;/p&gt;

&lt;p&gt;在代码中可以找到这个概念的官方说明：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Package registry contains the generic implementation of the storage and system logic.
package registry // import &quot;k8s.io/apiserver/pkg/registry&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再简化一点的说，就是 kubernetes 项目中的 model 层。因为 k8s 使用 etcd 作为存储，所以就是一个使用 etcd 作为存储的 model 层。&lt;/p&gt;

&lt;h4 id=&quot;storage-interface&quot;&gt;Storage Interface&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;k8s.io/apiserver/pkg/registry/rest/rest.go&lt;/em&gt; 这个文件定义了存储的接口，代码中的一段注释说明了这个接口的定义：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Storage interfaces need to be separated into two groups; those that operate
// on collections and those that operate on individually named items.
// Collection interfaces:
// (Method: Current -&amp;gt; Proposed)
//    GET: Lister -&amp;gt; CollectionGetter
//    WATCH: Watcher -&amp;gt; CollectionWatcher
//    CREATE: Creater -&amp;gt; CollectionCreater
//    DELETE: (n/a) -&amp;gt; CollectionDeleter
//    UPDATE: (n/a) -&amp;gt; CollectionUpdater
//
// Single item interfaces:
// (Method: Current -&amp;gt; Proposed)
//    GET: Getter -&amp;gt; NamedGetter
//    WATCH: (n/a) -&amp;gt; NamedWatcher
//    CREATE: (n/a) -&amp;gt; NamedCreater
//    DELETE: Deleter -&amp;gt; NamedDeleter
//    UPDATE: Update -&amp;gt; NamedUpdater
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Storage&lt;/code&gt; 的 interface:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Storage is a generic interface for RESTful storage services.
// Resources which are exported to the RESTful API of apiserver need to implement this interface. It is expected
// that objects may implement any of the below interfaces.
type Storage interface {
	// New returns an empty object that can be used with Create and Update after request data has been put into it.
	// This object must be a pointer type for use with Codec.DecodeInto([]byte, runtime.Object)
	New() runtime.Object

	// Destroy cleans up its resources on shutdown.
	// Destroy has to be implemented in thread-safe way and be prepared
	// for being called more than once.
	Destroy()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个类型，就是传递给上面那个添加路由函数的第二个参数：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (a *APIInstaller) registerResourceHandlers(path string, storage rest.Storage, ws *restful.WebService) (*metav1.APIResource, *storageversion.ResourceInfo, error) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因此，每个通过这个方法添加到 apiserver 的资源，都实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rest.Storage&lt;/code&gt; 这个接口。并且，还有可能实现其他的接口，如果有实现，就会添加对应的 API。&lt;strong&gt;因此，我们要看一个资源如何实现自己的 API 时，应该是去找它的 storage 实现。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;legacy-api-storage&quot;&gt;Legacy API Storage&lt;/h4&gt;

&lt;p&gt;上面提到的这个方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pkg/controlplane/instance.go: func (m *Instance) InstallLegacyAPI()&lt;/code&gt; 会在创建 apiserver 的时候被调用到，其中会添加我们最熟悉的那些资源的 storage，比如 pod。我们来具体看一下 pod 的 storage 添加的过程：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; pkg/controlplane/instance.go: func (m *Instance) InstallLegacyAPI()
	-&amp;gt; pkg/registry/core/rest/storage_ore.go: func (c LegacyRESTStorageProvider) NewLegacyRESTStorage()
		-&amp;gt; pkg/registry/core/pod/storage/storage.go: func NewStorage()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NewStorage()&lt;/code&gt; 函数会返回一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PodStorage&lt;/code&gt; 对象：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// PodStorage includes storage for pods and all sub resources
type PodStorage struct {
	Pod                 *REST
	Binding             *BindingREST
	LegacyBinding       *LegacyBindingREST
	Eviction            *EvictionREST
	Status              *StatusREST
	EphemeralContainers *EphemeralContainersREST
	Log                 *podrest.LogREST
	Proxy               *podrest.ProxyREST
	Exec                *podrest.ExecREST
	Attach              *podrest.AttachREST
	PortForward         *podrest.PortForwardREST
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个对象里的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt; 成员，就是实现了 pod 常规 API 所需的 storage 接口：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// REST implements a RESTStorage for pods
type REST struct {
	*genericregistry.Store
	proxyTransport http.RoundTripper
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它的大部分方法都是内嵌的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;genericregistry.Store&lt;/code&gt; 实现的，所以你可以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Store&lt;/code&gt; 对象中找到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; 方法的实现：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// List returns a list of items matching labels and field according to the
// store&apos;s PredicateFunc.
func (e *Store) List(ctx context.Context, options *metainternalversion.ListOptions) (runtime.Object, error) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个方法就是实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k8s.io/apiserver/pkg/registry/rest/rest.go: ListerInterface&lt;/code&gt;中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; 方法：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Lister is an object that can retrieve resources that match the provided field and label criteria.
type Lister interface {
	// NewList returns an empty object that can be used with the List call.
	// This object must be a pointer type for use with Codec.DecodeInto([]byte, runtime.Object)
	NewList() runtime.Object
	// List selects resources in the storage which match to the selector. &apos;options&apos; can be nil.
	List(ctx context.Context, options *metainternalversion.ListOptions) (runtime.Object, error)
	// TableConvertor ensures all list implementers also implement table conversion
	TableConvertor
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod 是一个很复杂的资源，还有很多其他的 storage 实现，以支持更多的 API：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# pkg/registry/core/rest/storage_ore.go: func (c LegacyRESTStorageProvider) NewLegacyRESTStorage()

	storage := map[string]rest.Storage{}
	if resource := &quot;pods&quot;; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
		storage[resource] = podStorage.Pod
		storage[resource+&quot;/attach&quot;] = podStorage.Attach
		storage[resource+&quot;/status&quot;] = podStorage.Status
		storage[resource+&quot;/log&quot;] = podStorage.Log
		storage[resource+&quot;/exec&quot;] = podStorage.Exec
		storage[resource+&quot;/portforward&quot;] = podStorage.PortForward
		storage[resource+&quot;/proxy&quot;] = podStorage.Proxy
		storage[resource+&quot;/binding&quot;] = podStorage.Binding
		if podStorage.Eviction != nil {
			storage[resource+&quot;/eviction&quot;] = podStorage.Eviction
		}
		storage[resource+&quot;/ephemeralcontainers&quot;] = podStorage.EphemeralContainers

	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;Kubernetes 的 API 实现代码很复杂，看代码是很容易被绕晕的。&lt;/p&gt;

&lt;p&gt;Storage 本身还有 cache 的实现，以及 etcd 访问的实现，本文并没有涉及。&lt;/p&gt;
</description>
        <pubDate>Sat, 11 Feb 2023 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2023/02/11/kubernetes-code-note-1/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2023/02/11/kubernetes-code-note-1/</guid>
        
        <category>kubernetes</category>
        
        
      </item>
    
      <item>
        <title>go-yaml 的默认 map 类型是 map[any]any</title>
        <description>&lt;p&gt;Go 语言的 yaml 库 &lt;em&gt;&amp;lt;github.com/go-yaml/yaml&amp;gt;&lt;/em&gt; 的默认 map 类型是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map[any]any&lt;/code&gt;，而不是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map[string]any&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;V2 代码：&lt;em&gt;&lt;a href=&quot;https://github.com/go-yaml/yaml/blob/v2/decode.go#L241&quot;&gt;https://github.com/go-yaml/yaml/blob/v2/decode.go#L241&lt;/a&gt;&lt;/em&gt;
V3 代码：&lt;em&gt;&lt;a href=&quot;https://github.com/go-yaml/yaml/blob/v3/decode.go#L334&quot;&gt;https://github.com/go-yaml/yaml/blob/v3/decode.go#L334&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;因此，当使用这个库对 yaml 内容进行 unmarshal 的时候，由 go-yaml 自动创建的 map 的类型是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map[any]any&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;fmt&quot;
	&quot;log&quot;

	&quot;gopkg.in/yaml.v2&quot;
)

var content = `
storage:
  settings:
    fs:
      ad:
        username: admin
      ldap:
        password: password

`

type Storage struct {
	Settings map[string]any `yaml:&quot;settings&quot;`
}

type Config struct {
	Storage *Storage `yaml:&quot;storage&quot;`
}

func main() {
	c := new(Config)
	err := yaml.Unmarshal([]byte(content), c)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf(&quot;%T\n&quot;, c.Storage.Settings[&quot;fs&quot;])
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码的输出是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;❯ go run testcmd.go
map[interface {}]interface {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 02 Nov 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/11/02/go-yaml-default-map-type-is-map-any-any/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/11/02/go-yaml-default-map-type-is-map-any-any/</guid>
        
        <category>golang</category>
        
        
      </item>
    
      <item>
        <title>GRUB2 menu and kernel-install</title>
        <description>&lt;h2 id=&quot;bls-boot-loader-specification&quot;&gt;BLS: Boot Loader Specification&lt;/h2&gt;

&lt;p&gt;在新的发行版上，普遍采用了 &lt;strong&gt;GRUB2&lt;/strong&gt; （以下简称 GRUB） 作为 boot loader。GRUB2 现在采用了 &lt;strong&gt;Boot Loader Specification&lt;/strong&gt; （简称 BLS） 来管理启动菜单： &lt;em&gt;&lt;a href=&quot;https://systemd.io/BOOT_LOADER_SPECIFICATION/&quot;&gt;https://systemd.io/BOOT_LOADER_SPECIFICATION/&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;在非 UEFI Secure 启动的情况下，启动菜单直接使用文本文件保存，方便维护。你可以在一个使用该标准的系统上查看这些文件，例如 Rocky Linux 8.5：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ll /boot/loader/entries/
total 12
-rw-r--r--. 1 root root 405 May 10 13:54 a0284538aa5b498cb38b8e530b2a6be4-0-rescue.conf
-rw-r--r--. 1 root root 353 May 10 13:54 a0284538aa5b498cb38b8e530b2a6be4-4.18.0-348.el8.0.2.x86_64.conf

# cat a0284538aa5b498cb38b8e530b2a6be4-4.18.0-348.el8.0.2.x86_64.conf
title Rocky Linux (4.18.0-348.el8.0.2.x86_64) 8.5 (Green Obsidian)
version 4.18.0-348.el8.0.2.x86_64
linux /vmlinuz-4.18.0-348.el8.0.2.x86_64
initrd /initramfs-4.18.0-348.el8.0.2.x86_64.img $tuned_initrd
options $kernelopts $tuned_params
id rocky-20211114010422-4.18.0-348.el8.0.2.x86_64
grub_users $grub_users
grub_arg --unrestricted
grub_class kernel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;machine-id&quot;&gt;Machine ID&lt;/h2&gt;

&lt;p&gt;Machine ID 是一个在系统安装的时候生成的 UUID，用于表示系统的唯一性。它存放在 &lt;em&gt;/etc/machine-id&lt;/em&gt; 文件中&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cat /etc/machine-id
a0284538aa5b498cb38b8e530b2a6be4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以查看 man 手册获取更多信息： &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;man machine-id&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;grub-菜单的生成&quot;&gt;GRUB 菜单的生成&lt;/h2&gt;

&lt;p&gt;GRUB 菜单是在 kernel 安装的时候生成的，在 kernel 卸载的时候删除的，这整个过程是由 &lt;strong&gt;kernel-install&lt;/strong&gt; 命令来完成的。在 RHEL 8 及衍生系统上，这个程序由 &lt;strong&gt;systemd-udev&lt;/strong&gt; 包来提供。&lt;/p&gt;

&lt;h3 id=&quot;kernel-install&quot;&gt;kernel-install&lt;/h3&gt;

&lt;p&gt;这个程序只有两个功能，添加内核，和删除内核：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# kernel-install --help
Usage:
        /usr/bin/kernel-install add KERNEL-VERSION KERNEL-IMAGE
        /usr/bin/kernel-install remove KERNEL-VERSION
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它本身是通过一系列的脚本来实现的，这些脚本存放在：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;/usr/lib/kernel/install.d/&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;/etc/kernel/install.d/&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认脚本存放在 &lt;em&gt;/usr/lib/kernel/install.d&lt;/em&gt; 目录下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@overlord-sz3 install.d]# cd /usr/lib/kernel/install.d/
[root@overlord-sz3 install.d]# ll
total 40
-rwxr-xr-x. 1 root root 7120 Nov 14  2021 20-grub.install
-rwxr-xr-x. 1 root root 2252 Nov  9  2021 20-grubby.install
-rwxr-xr-x. 1 root root  368 Jun 22  2018 50-depmod.install
-rwxr-xr-x. 1 root root 1657 Nov  9  2021 50-dracut.install
-rwxr-xr-x. 1 root root 3338 Nov  9  2021 51-dracut-rescue.install
-rwxr-xr-x. 1 root root  791 Oct 13  2021 60-kdump.install
-rwxr-xr-x. 1 root root 1975 Nov  9  2021 90-loaderentry.install
-rwxr-xr-x. 1 root root  989 Jul 22  2021 92-tuned.install
-rwxr-xr-x. 1 root root  454 Nov 14  2021 99-grub-mkconfig.install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这些都是 shell 脚本，主要是完成一些配置。例如 &lt;em&gt;20-grub.install&lt;/em&gt; 和 &lt;em&gt;90-loaderentry.install&lt;/em&gt; 这两个脚本就是完成 grub 相关的一些配置。&lt;/p&gt;

&lt;p&gt;另外，kernel-install 对于这些脚本返回值做了一个特殊的规定：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;An executable should return 0 on success. It may also return 77 to cause the whole operation to terminate (executables later in lexical order will be skipped).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以，如果一个脚本返回了 77，那么后续的都会被跳过。&lt;/p&gt;

&lt;h3 id=&quot;生成菜单的脚本&quot;&gt;生成菜单的脚本&lt;/h3&gt;

&lt;p&gt;在 RHEL 8 及其衍生系统中，默认安装的 kernel-install 脚本里有两个脚本会负责 GRUB 菜单的生成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;/usr/lib/kernel/install.d/20-grub.install&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;这个文件来自包 grub2-common-2.02-106.el8.0.2.noarch。&lt;em&gt;&lt;a href=&quot;https://git.rockylinux.org/staging/rpms/grub2/-/blob/r8/SOURCES/20-grub.install&quot;&gt;https://git.rockylinux.org/staging/rpms/grub2/-/blob/r8/SOURCES/20-grub.install&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;/usr/lib/kernel/install.d/90-loaderentry.install&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;这个文件来自包 systemd-udev-239-51.el8.x86_64。&lt;em&gt;&lt;a href=&quot;https://github.com/systemd/systemd/blob/v239-50/src/kernel-install/90-loaderentry.install&quot;&gt;https://github.com/systemd/systemd/blob/v239-50/src/kernel-install/90-loaderentry.install&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你观察上面所展示的菜单文件的内容，并且对比这两个脚本，那么你就会发现他们是由 &lt;em&gt;20-grub.install&lt;/em&gt; 这个文件生成的。为什么嗯？&lt;/p&gt;

&lt;p&gt;这个是两个脚本的实现问题，首先 &lt;em&gt;20-grub.install&lt;/em&gt; 脚本会被先执行，并且生成了 entries 目录中的文件。等到 &lt;em&gt;90-loaderentry.install&lt;/em&gt; 被执行时，它有一个判断如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ! [[ -d &quot;$BOOT_DIR_ABS&quot; ]]; then
    exit 0
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BOOT_DIR_ABS&lt;/code&gt; 如果不是一个目录，就不会执行。这个变量如何定义呢？它在这里定义：&lt;em&gt;&lt;a href=&quot;https://github.com/systemd/systemd/blob/v239-50/src/kernel-install/kernel-install#L92&quot;&gt;https://github.com/systemd/systemd/blob/v239-50/src/kernel-install/kernel-install#L92&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ! [[ $MACHINE_ID ]]; then
    BOOT_DIR_ABS=$(mktemp -d /tmp/kernel-install.XXXXX) || exit 1
    trap &quot;rm -rf &apos;$BOOT_DIR_ABS&apos;&quot; EXIT INT QUIT PIPE
elif [[ -d /efi/loader/entries ]] || [[ -d /efi/$MACHINE_ID ]]; then
    BOOT_DIR_ABS=&quot;/efi/$MACHINE_ID/$KERNEL_VERSION&quot;
elif [[ -d /boot/loader/entries ]] || [[ -d /boot/$MACHINE_ID ]]; then
    BOOT_DIR_ABS=&quot;/boot/$MACHINE_ID/$KERNEL_VERSION&quot;                           # ------------- This line
elif [[ -d /boot/efi/loader/entries ]] || [[ -d /boot/efi/$MACHINE_ID ]]; then
    BOOT_DIR_ABS=&quot;/boot/efi/$MACHINE_ID/$KERNEL_VERSION&quot;
elif mountpoint -q /efi; then
    BOOT_DIR_ABS=&quot;/efi/$MACHINE_ID/$KERNEL_VERSION&quot;
elif mountpoint -q /boot/efi; then
    BOOT_DIR_ABS=&quot;/boot/efi/$MACHINE_ID/$KERNEL_VERSION&quot;
else
    BOOT_DIR_ABS=&quot;/boot/$MACHINE_ID/$KERNEL_VERSION&quot;
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/boot/$MACHINE_ID/$KERNEL_VERSION&lt;/code&gt; 这个形式，是 BLS 规范定义的新的形式，即每个系统的启动项都放在自己的独立目录中。因为现在 RHEL 8 及其衍生版本还未用到这个规范，所以他们的 GRUB 菜单项就不是用 &lt;em&gt;90-loaderentry.install&lt;/em&gt; 这个脚本生成的。&lt;/p&gt;

&lt;h3 id=&quot;菜单文件&quot;&gt;菜单文件&lt;/h3&gt;

&lt;p&gt;一个菜单文件的规范涉及两个部分：文件名和内容。&lt;/p&gt;

&lt;p&gt;一般来说，文件名类似：&lt;em&gt;a0284538aa5b498cb38b8e530b2a6be4-4.18.0-348.el8.0.2.x86_64.conf&lt;/em&gt;。这个文件名主要的限制是必须跨系统唯一，所以一般使用如下格式: &lt;strong&gt;{machine_id}-{kernel_version}.conf&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文件的内容可能如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;title Rocky Linux (4.18.0-348.el8.0.2.x86_64) 8.5 (Green Obsidian)
version 4.18.0-348.el8.0.2.x86_64
linux /vmlinuz-4.18.0-348.el8.0.2.x86_64
initrd /initramfs-4.18.0-348.el8.0.2.x86_64.img $tuned_initrd
options $kernelopts $tuned_params
id rocky-20211114010422-4.18.0-348.el8.0.2.x86_64
grub_users $grub_users
grub_arg --unrestricted
grub_class kernel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每行第一个空格之前的就是 key，后面则是 value。其中，title 就是展示在菜单上的内容。这个 title 就是纯文本，所以你可以随意修改。&lt;/p&gt;

&lt;p&gt;从 &lt;em&gt;20-grub.install&lt;/em&gt; 文件可以看出，这里的 title 的内容会使用到来自 &lt;em&gt;/etc/os-release&lt;/em&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NAME&lt;/code&gt; 变量和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VERSION&lt;/code&gt; 变量。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cat /etc/os-release
NAME=&quot;Rocky Linux&quot;
VERSION=&quot;8.5 (Green Obsidian)&quot;
ID=&quot;rocky&quot;
ID_LIKE=&quot;rhel centos fedora&quot;
VERSION_ID=&quot;8.5&quot;
PLATFORM_ID=&quot;platform:el8&quot;
PRETTY_NAME=&quot;Rocky Linux 8.5 (Green Obsidian)&quot;
ANSI_COLOR=&quot;0;32&quot;
CPE_NAME=&quot;cpe:/o:rocky:rocky:8.5:GA&quot;
HOME_URL=&quot;https://rockylinux.org/&quot;
BUG_REPORT_URL=&quot;https://bugs.rockylinux.org/&quot;
ROCKY_SUPPORT_PRODUCT=&quot;Rocky Linux&quot;
ROCKY_SUPPORT_PRODUCT_VERSION=&quot;8&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grub_&lt;/code&gt; 开头的 key，是 GRUB 平台实现的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On grub platforms, the following grub-specific keywords have been implemented:
    &lt;ul&gt;
      &lt;li&gt;the BLS filename is also used for menuentry’s –id parameter, so you can use it in saved_entry&lt;/li&gt;
      &lt;li&gt;grub_hotkey - same as grub’s “–hotkey” menuentry parameter&lt;/li&gt;
      &lt;li&gt;grub_users - same as grub’s “–users” menuentry parameter; used for password protection&lt;/li&gt;
      &lt;li&gt;grub_class - same as grub’s “–class” menuentry paramter&lt;/li&gt;
      &lt;li&gt;grub_arg - passes extra arguments to menuentry&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些是兼容原来 GRUB 的参数：&lt;em&gt;&lt;a href=&quot;https://www.gnu.org/software/grub/manual/grub/grub.html#menuentry&quot;&gt;https://www.gnu.org/software/grub/manual/grub/grub.html#menuentry&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;默认启动项&quot;&gt;默认启动项&lt;/h3&gt;

&lt;p&gt;你可以使用 &lt;strong&gt;grub2-set-default&lt;/strong&gt; 命令修改默认的启动项。&lt;/p&gt;

&lt;p&gt;此外，我们还可以在安装了一个新的 kernel 之后，让 kernel-install 自动将这个新的 kernel 设置为默认 kernel。这个行为的配置，是在文件 &lt;em&gt;/etc/sysconfig/kernel&lt;/em&gt; 文件中控制的：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cat /etc/sysconfig/kernel
# UPDATEDEFAULT specifies if kernel-install should make
# new kernels the default
UPDATEDEFAULT=yes

# DEFAULTKERNEL specifies the default kernel package type
DEFAULTKERNEL=kernel-core
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个注释已经解释得很清楚了。这部分逻辑的实现，也是在 &lt;em&gt;20-grub.install&lt;/em&gt; 中实现的，调用的是 &lt;strong&gt;grub2-editenv&lt;/strong&gt; 命令：&lt;em&gt;&lt;a href=&quot;https://git.rockylinux.org/staging/rpms/grub2/-/blob/r8/SOURCES/20-grub.install#L134&quot;&gt;https://git.rockylinux.org/staging/rpms/grub2/-/blob/r8/SOURCES/20-grub.install#L134&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;顺便说一下，如果你安装的 kernel 采用了另外一个名字来打包，比如 elrepo  的 kernel-lt，那么修改 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DEFAULTKERNEL&lt;/code&gt; 这行即可。&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://fedoraproject.org/wiki/Changes/BootLoaderSpecByDefault&quot;&gt;https://fedoraproject.org/wiki/Changes/BootLoaderSpecByDefault&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://systemd.io/BOOT_LOADER_SPECIFICATION/&quot;&gt;https://systemd.io/BOOT_LOADER_SPECIFICATION/&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 23 May 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/05/23/GRUB2-menu-and-kernel-install/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/05/23/GRUB2-menu-and-kernel-install/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>ISO9660 标准和 genisoimage 命令</title>
        <description>&lt;p&gt;当我们要定制一个 RHEL 及其衍生版的操作系统镜像时，我们会使用 &lt;strong&gt;genisoimage&lt;/strong&gt; 命令来生成最终的 ISO 文件。&lt;/p&gt;

&lt;p&gt;例如，我们基于 Rocky Linux 8.5 版本，定制了一个镜像后，最终我们会执行如下这条命令：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd rocky-linux-8-5-x86_64-dvd/
$ genisoimage -v -U -r -T -J -joliet-long \
  -V Rocky-8-5-x86_64-dvd -volset Rocky-8-5-x86_64-dvd -A Rocky-8-5-x86_64-dvd \
  -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table \
  -eltorito-alt-boot -e images/efiboot.img -no-emul-boot \
  -o ../NEWISO.iso
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这条命令参数很多，我们需要先了解和光盘有关的相关标准才能看懂这个命令。&lt;/p&gt;

&lt;h2 id=&quot;iso9660-及相关标准&quot;&gt;ISO9660 及相关标准&lt;/h2&gt;

&lt;p&gt;ISO9660 就是光盘文件系统的标准，意思就是如何在光盘上存储文件。更多信息可以查看 wiki 链接：&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;随着计算机行业的发展，原来的标准不太适用于新的需求，比如文件名字更长，目录层级更多等。所以业界也一直在扩充 ISO9660 的相关标准。这里我们说三个目前最常用的。&lt;/p&gt;

&lt;h3 id=&quot;rock-ridge&quot;&gt;Rock Ridge&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660#Rock_Ridge&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660#Rock_Ridge&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rock Ridge Interaction Protocol (RRIP)&lt;/strong&gt; 为光盘文件系统增加了 POSIX 文件系统语意。支持这个标准后，操作系统可以更好的跟光盘文件系统进行交互，比如支持更长的文件名，文件 mode, uid 等。&lt;/p&gt;

&lt;p&gt;这个标准的名字是一部电影里的虚构城镇的名字。电影的中文名字是：神枪小子。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fictional town Rock Ridge in Mel Brooks&apos; film Blazing Saddles.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;el-torito&quot;&gt;El Torito&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660#El_Torito&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660#El_Torito&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El Torito 是一个让 PC 可以从 CD-ROM 启动的标准。最初由 IBM 和 Phoenix Technologies （卖 BIOS 的厂商）制定，随后被所有 BIOS 支持。支持这个标准后，BIOS 除了可以加载硬盘上的启动代码，也可以加载光盘上的启动代码。&lt;/p&gt;

&lt;p&gt;据说这个名字是加州一家墨西哥餐馆的名字，这个标准是在这个餐馆里想出来的。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;El Torito restaurant in Irvine, California (33.684722°N 117.852547°W)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;joliet&quot;&gt;Joliet&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660#Joliet&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660#Joliet&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这里由微软提出的标准。原来的标准对于光盘上的文件名字限制太死，比如长度、格式、不支持 Unicode 等，所以用这个标准扩展了一下，方便存放名字更复杂的文件。&lt;/p&gt;

&lt;h3 id=&quot;三个扩展标准的小结&quot;&gt;三个扩展标准的小结&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Standard&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Rock Ridge&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;让光盘文件系统更接近 POSIX 文件系统，操作系统可以更方便的访问。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;El Torito&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;让计算机可以从光盘启动。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Joliet&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;让光盘的文件名可以更复杂，符合现在的计算机系统中的文件名。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;genisoimage-命令的参数&quot;&gt;genisoimage 命令的参数&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ genisoimage -v -U -r -T -J -joliet-long \
  -V Rocky-8-5-x86_64-dvd -volset Rocky-8-5-x86_64-dvd -A Rocky-8-5-x86_64-dvd \
  -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table \
  -eltorito-alt-boot -e images/efiboot.img -no-emul-boot \
  -o ../NEWISO.iso
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这个命令的参数看起来很多，但是可以分组来看。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-v&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-o&lt;/code&gt; 参数比较简单，就不展开说了。&lt;/p&gt;

&lt;h3 id=&quot;和光盘的名字相关的&quot;&gt;和光盘的名字相关的&lt;/h3&gt;

&lt;p&gt;这些参数就是让光盘在系统上有一个友好的展示名字。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-A&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-appid&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;会被写入 volume header 的一个字符串，表示这个光盘中装载的应用程序，最多 128 字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-V&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;将 volume id 写入 master block，长度限制是 32 个字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-volset&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;设置 volume set id，长度限制是 128 字符。Volume set 相当于是一套光盘的意思，所以后续还可以设置当前光盘是一套光盘里的第几张光盘。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;joliet-标准相关&quot;&gt;Joliet 标准相关&lt;/h3&gt;

&lt;p&gt;这些参数用来控制光盘上的文件的文件名的限制，配置这些选项的目的就是尽量不限制文件名。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-J&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;生成 Joliet 目录记录。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-joliet-long&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;允许 Joliet 文件名的最大长度达到 103 个字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-r&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-rational-rock&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;类似 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-R&lt;/code&gt;，生成 SUSP 和 RR 记录，但是 file ownership 会被设置为更有用的值，减少使用 ISO 的人需要处理的文件权限的问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-T&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-translation-table&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;在光盘的每个目录下都生成一个 &lt;em&gt;TRANS.TBL&lt;/em&gt; 的文件，用于帮助在不兼容 RR 标准的系统上使用正确的文件名来访问文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-U&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-untranslated-filenames&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;允许非转换的文件名，这会导致完全不兼容 ISO9660 标准。相当于开启了以下选项：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-d -l -N -allow-leading-dots -relaxed-filenames -allow-lowercase -allow-multidot -no-iso-translate&lt;/code&gt;，就是减少对文件名的限制。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;el-torito-标准相关&quot;&gt;El Torito 标准相关&lt;/h3&gt;

&lt;p&gt;这些参数是用来控制光盘作为启动盘是如何工作的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-b&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-eltorito-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定 El Torito 启动盘使用的启动文件。对于 legacy BIOS，这个就是 &lt;em&gt;isolinux.bin&lt;/em&gt; 文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eltorito-alt-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;开始一组新的 El Torito 启动参数的配置。一般一组用于 isolinux，一组用于 UEFI。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;以下几个参数是和 legacy BIOS 启动方式相关的&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-c&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-eltorito-catalog&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定 El Torito 的 boot catalog 文件的位置。启动需要这个文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-no-emul-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;用于 El Torito 的启动文件是一个非模拟镜像。系统会加载并且直接执行，而不会像使用一个硬盘一样，先通过分区表来查找启动分区。现在计算机都支持这种方式，通过这种方式，就不需要在一个启动文件里模拟硬盘的数据保存格式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-boot-load-size&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定在非模拟的情况下，load 的 virtual sector (512B) 数量。这里一般要求是 4 的倍数，否则在有些系统上无法工作。这个意思是启动的时候，在启动阶段，通过读取启动文件的这么多数据，就可以把控制权转给启动文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-boot-info-table&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定需要在 boot file offset 8 的位置插入一个 56 字节长的内容，这个插入的内容和光盘的 layout 信息有关，如下面所示。主要目的是为了在启动的过程中，找到 boot 文件的位置。&lt;/li&gt;
      &lt;li&gt;LBA：linear block address (given in CD sectors, normally 2048 bytes)。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;         Offset    Name           Size      Meaning
          8        bi_pvd         4 bytes   LBA of primary volume descriptor
         12        bi_file        4 bytes   LBA of boot file
         16        bi_length      4 bytes   Boot file length in bytes
         20        bi_csum        4 bytes   32-bit checksum
         24        bi_reserved    40 bytes  Reserved
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;以下几个参数是和 UEFI 启动方式相关的&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-e&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-efi-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;EFI 启动文件的位置。UEFI 启动文件也需要指定 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-no-emul-boot&lt;/code&gt; 参数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;implantisomd5-命令&quot;&gt;implantisomd5 命令&lt;/h2&gt;

&lt;p&gt;将 ISO 的 md5sum 写入一个没有的 sector，以便随后使用 checkisomd5 命令进行校验。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ implantisomd5 Rocky-Linux-8.5-x86_64-dvd.iso
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;em&gt;checkisomd5&lt;/em&gt; 命令进行校验：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ checkisomd5 --verbose Rocky-Linux-8.5-x86_64-dvd.iso
Rocky-Linux-8.5-x86_64-dvd.iso:   e9ebe80ba90b67c1a4e3ccfd971bd86a
Fragment sums: 6ec3c854976341d15f5425ae13b7e16f5a7df75942a553adb6f29ba6798c
Fragment count: 20
Supported ISO: no
Press [Esc] to abort check.
Checking: 093.3%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 19 May 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/05/19/iso9660-and-genisoimage-command/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/05/19/iso9660-and-genisoimage-command/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>Linux Bridge VLAN Filter Command Explain</title>
        <description>&lt;p&gt;Linux bridge VLAN filter 功能使得 bridge 像一个真正的交换机一样来提供 VLAN 服务。本文解释 Linux &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bridge vlan&lt;/code&gt; 相关的一些命令。&lt;/p&gt;

&lt;h2 id=&quot;bridge-vlan-add&quot;&gt;bridge vlan add&lt;/h2&gt;

&lt;h3 id=&quot;access-port&quot;&gt;Access Port&lt;/h3&gt;

&lt;p&gt;如下图所示，我们要将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tap0&lt;/code&gt; 加入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;br0&lt;/code&gt;，然后要让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tap0&lt;/code&gt; 像一个 access port 一样工作。&lt;/p&gt;

&lt;p&gt;首先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip link set dev tap0 master br0&lt;/code&gt;。然后执行下图所示的命令，下图还说明了命令的每个部分分别表示什么含义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00037_linux_vlan_filter_1.png&quot; alt=&quot;linux_vlan_filter_add_command_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图所描述的行为，就是交换机上一个 access port 的行为。&lt;/p&gt;

&lt;h3 id=&quot;trunk-port&quot;&gt;Trunk Port&lt;/h3&gt;

&lt;p&gt;如下图所示，我们要将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bond0&lt;/code&gt; 加入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;br0&lt;/code&gt;，然后要让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bond0&lt;/code&gt; 像一个 trunk port 一样工作。&lt;/p&gt;

&lt;p&gt;首先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip link set dev bond0 master br0&lt;/code&gt;。然后执行下图所示的命令，下图还说明了命令的每个部分分别表示什么含义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00038_linux_vlan_filter_2.png&quot; alt=&quot;linux_vlan_filter_add_command_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图所描述的行为，就是交换机上一个 trunk port 的行为。&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Apr 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/04/18/linux-vlan-filter-explain/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/04/18/linux-vlan-filter-explain/</guid>
        
        <category>linux</category>
        
        <category>network</category>
        
        
      </item>
    
      <item>
        <title>Dell XPS 9500 电源适配器无法识别的问题</title>
        <description>&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;我的 XPS 9500 是 2020 年买的，目前安装的是 Ubuntu 21.10 系统，最近出现了一次电源适配器无法识别的问题。现象是这样的：&lt;strong&gt;前一天正常待机，第二天恢复后，无法识别电源适配器，只能一直消耗电池的电量，直到耗尽关机&lt;/strong&gt;。之前，我的电脑也出现过在休眠时，直接掉电关机的情况，就像电源和电池同时拔掉的情况。看起来，应该是电脑本身的电源模块的问题。通过致电 Dell 技术支持，他们告知我这个是个系统电源管理模块的 bug，Dell 提供的故障描述如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;问题描述：xps 9500 type c充电器无法识别充电，dpm电池设置其他方式和关闭高级充电依旧，交换电脑三个type c口都无法识别充电，进入bios下也是一样无法识别电源适配器，没有其他的ac交换，一开始以为是ac 问题 ，后续客户自己重新到dpm检查开启的设置，发现dpm的峰值偏移功能开启影响了ac和电池的充电计划。&lt;/p&gt;

  &lt;p&gt;解决方法：后续遇到无法识别ac充电的情况，建议可以先到打开dell power manager，点击峰值偏移，关闭这个功能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;问题是由&lt;strong&gt;峰值偏移&lt;/strong&gt;这个功能引起的，解决办法有两个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Windows 系统可以使用 Power Manager 这个程序，关闭峰值偏移功能。&lt;/li&gt;
  &lt;li&gt;更新 BIOS。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我的故障和 Dell 提供的描述有一个地方不太一样，就是我的电池充电模式被我修改成了 &lt;strong&gt;Primarily AC Use&lt;/strong&gt;。在出现了无法识别电源适配器的问题后，我又改回了 &lt;strong&gt;Adaptive&lt;/strong&gt;，然后发现在 BIOS 中，电池可以开始充电了。此外，我记得我没有开启过峰值偏移功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00036_dell_xps9500_bios_power.jpg&quot; alt=&quot;dell_xps_9500_bios_power&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;dell-command-configure&quot;&gt;Dell Command Configure&lt;/h2&gt;

&lt;p&gt;因为我不是 Windows 系统，所以无法使用 Power Manager 这个程序。而且，我也不想升级 BIOS。国内的技术支持并不知道在 Ubuntu 系统下如何解决这个问题。经过搜索，我发现，Dell 自己是有个命令行程序支持在 Linux 下修改这些 BIOS 设置的，这个程序就是 &lt;strong&gt;Dell Command Configure&lt;/strong&gt;，下载路径如下： &lt;em&gt;&lt;a href=&quot;https://www.dell.com/support/kbdoc/zh-cn/000178000/dell-command-configure&quot;&gt;https://www.dell.com/support/kbdoc/zh-cn/000178000/dell-command-configure&lt;/a&gt;&lt;/em&gt;。Ubuntu 版本包含两个 dep 包，先安装 &lt;em&gt;srvadmin-hapi&lt;/em&gt;，再安装 &lt;em&gt;command-configure&lt;/em&gt;：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-r--r-- 1 diabloneo diabloneo 1696256 Sep 15 20:41 command-configure_4.6.0-277.ubuntu20_amd64.deb
-rw-r--r-- 1 diabloneo diabloneo  297940 Sep 15 20:41 srvadmin-hapi_9.5.0_amd64.deb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个命令的使用手册可以从这里下载： &lt;em&gt;&lt;a href=&quot;https://dl.dell.com/topicspdf/command-configure_users-guide4_en-us.pdf&quot;&gt;https://dl.dell.com/topicspdf/command-configure_users-guide4_en-us.pdf&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;使用这个命令关闭峰值偏移功能：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd /opt/dell/dcc
$ sudo ./cctk --PeakShiftCfg=Disabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不过，虽然我关闭了这个功能，但是并不知道这个问题是否还会再出现。&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Feb 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/02/10/Dell-XPS-9500-AC-power-adapter-not-regonized/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/02/10/Dell-XPS-9500-AC-power-adapter-not-regonized/</guid>
        
        <category>linux</category>
        
        
      </item>
    
  </channel>
</rss>
