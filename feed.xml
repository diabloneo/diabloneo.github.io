<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coffee, Coke and Code</title>
    <description>Archive diabloneo's articles.
</description>
    <link>http://diabloneo.github.io//</link>
    <atom:link href="http://diabloneo.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 26 Aug 2019 23:05:50 +0800</pubDate>
    <lastBuildDate>Mon, 26 Aug 2019 23:05:50 +0800</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>在 VIM 中配置 fzf 使用 find</title>
        <description>&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/junegunn/fzf&quot;&gt;https://github.com/junegunn/fzf&lt;/a&gt;&lt;/em&gt; 是 VIM 常用的文件查找工具。fzf 可以使用 find 或者 &lt;em&gt;&lt;a href=&quot;https://github.com/sharkdp/fd&quot;&gt;https://github.com/sharkdp/fd&lt;/a&gt;&lt;/em&gt; 作为查找工具，官方的文档里给了很多 fd 的配置，但是 find 的较少。这里提供了一个使用 find 的配置，可以根据自己需要修改：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-vim&quot; data-lang=&quot;vim&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; $FZF_DEFAULT_COMMAND&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&quot;find &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;regextype egrep
&lt;span class=&quot;se&quot;&gt;			\&lt;/span&gt;    \\&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;path &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;/vendor &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;prune \\&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;             ;; ignore some dirs
&lt;span class=&quot;se&quot;&gt;			\&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;o&lt;/span&gt; \\&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;path &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;/_site &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;prune \\&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;se&quot;&gt;			\&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;o&lt;/span&gt; \\&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;path &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;/_output &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;prune \\&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;se&quot;&gt;			\&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;o&lt;/span&gt; \\&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;path &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;/&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;git &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;prune \\&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;se&quot;&gt;			\&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;o&lt;/span&gt; \\&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;path &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;/&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;svn &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;prune \\&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;se&quot;&gt;			\&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;o&lt;/span&gt; \\&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;path &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;/&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;tox &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;prune \\&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;se&quot;&gt;			\&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;o&lt;/span&gt; \\&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;type &lt;span class=&quot;k&quot;&gt;f&lt;/span&gt; 
&lt;span class=&quot;se&quot;&gt;			\&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;a&lt;/span&gt; \\&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;not &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;regex &lt;span class=&quot;s1&quot;&gt;'.*\.(pyc|pyo)$'&lt;/span&gt; \\&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   ;; ignore some &lt;span class=&quot;k&quot;&gt;files&lt;/span&gt;
&lt;span class=&quot;se&quot;&gt;			\&lt;/span&gt;    \\&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;se&quot;&gt;			\&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;print&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Mon, 26 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2019/08/26/Using-fzf-with-find/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2019/08/26/Using-fzf-with-find/</guid>
        
        <category>vim</category>
        
        
      </item>
    
      <item>
        <title>使用 Python mock call 表示一个类示例</title>
        <description>&lt;p&gt;&lt;em&gt;以下内容对于 Python 2 或者 Python 3 均适用。术语 &lt;strong&gt;mock 对象&lt;/strong&gt; 表示用于替换代码中实际对象的 &lt;code class=&quot;highlighter-rouge&quot;&gt;mock.Mock&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;mock.MagicMock&lt;/code&gt; 对象&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mock&lt;/strong&gt; 库是 Python 中用来进行单元测试模拟的一个库。&lt;code class=&quot;highlighter-rouge&quot;&gt;mock.call&lt;/code&gt; 是 mock 库中用来表示 mock 对象调用的一个辅助对象，通常我们使用一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;mock.call&lt;/code&gt; 对象或者一个含有多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;mock.call&lt;/code&gt; 对象的列表来表示我们期望发生在 mock 对象上的调用，这样不仅可以判断一个 mock 对象是否执行了期望的调用，还确认这些调用是按照期望的顺序执行的。在测试代码中，我们会将所期望的调用和 mock 对象的 &lt;code class=&quot;highlighter-rouge&quot;&gt;call_args&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;call_args_list&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mock_calls&lt;/code&gt; 以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;method_calls&lt;/code&gt; 这些记录内容做比较。&lt;/p&gt;

&lt;p&gt;有一点需要注意，&lt;code class=&quot;highlighter-rouge&quot;&gt;mock.call&lt;/code&gt; 本身就是一个 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mock._Call&lt;/code&gt; 类的实例&lt;/strong&gt;，所以它本身，即不加调用符号 (&lt;code class=&quot;highlighter-rouge&quot;&gt;mock.call()&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;mock.call(*args, **kwargs)&lt;/code&gt;) 时，表示的是 &lt;strong&gt;mock 对象本身&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;下面来看个个例子。假设 &lt;code class=&quot;highlighter-rouge&quot;&gt;app.util.SSH&lt;/code&gt; 是我们封装的一个用于管理 SSH 连接，并且提供某些命令封装的类。现在 SSH 提供了两个实例方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;hostname()&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;restart_service(service)&lt;/code&gt;。我们一般会这么 mock 它：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;patch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;app.util.SSH&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mocked_conn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;return_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mocked_conn&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;# test logics&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;# do assert with mocked_conn object&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这样，我们就可以让代码中对一个 SSH 实例的调用，转换成对我们的 mock 对象 mocked_conn 的调用。这样，代码中对 mock 对象的使用和 &lt;code class=&quot;highlighter-rouge&quot;&gt;mock.call&lt;/code&gt; 的对应关系如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SSH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;# conn == mock.call&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hostname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;                  &lt;span class=&quot;c&quot;&gt;# mock.call.hostname()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;restart_service&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;service1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;# mock.call.restart_service(service1)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;restart_service&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;service2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;# mock.call.restart_service(service2)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;所以 &lt;code class=&quot;highlighter-rouge&quot;&gt;mocked_conn.mock_calls&lt;/code&gt; 的内容就是&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hostname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;restart_service&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;service1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;restart_service&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;service2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;要进行 assert 时，你需要提供上面这个 call list。&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2019/08/20/use-python-mock-call-to-represent-a-class-instance/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2019/08/20/use-python-mock-call-to-represent-a-class-instance/</guid>
        
        <category>Python</category>
        
        
      </item>
    
      <item>
        <title>smartctl 设置硬盘的 write-caching</title>
        <description>&lt;p&gt;在 &lt;a href=&quot;http://diabloneo.github.io//2019/06/16/hdparm-and-sdparm&quot;&gt;hdparm and sdparm&lt;/a&gt; 中，提到了 SATA 盘和 SAS 盘可以分别通过 &lt;em&gt;hdparm&lt;/em&gt; 和 &lt;em&gt;sdparm&lt;/em&gt; 来设置它的 &lt;strong&gt;write-caching&lt;/strong&gt; 属性。&lt;/p&gt;

&lt;p&gt;但是在有的情况下，系统上没有安装这两个工具，还可以考虑使用 &lt;strong&gt;smartctl&lt;/strong&gt; 工具来设置。smartctl 的 &lt;strong&gt;–get&lt;/strong&gt; 和 &lt;strong&gt;–set&lt;/strong&gt; 参数可以用来查询和设置非 SMART 的属性，其中就包括了写缓存属性 &lt;strong&gt;wcache&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;查看当前硬盘当前的 wcache 值：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@chenhong204 ~]# smartctl --get=wcache /dev/sdc
smartctl 6.2 2013-07-26 r3841 [x86_64-linux-3.10.0-693.el7.x86_64] (local build)
Copyright (C) 2002-13, Bruce Allen, Christian Franke, www.smartmontools.org

Writeback Cache is:   Enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关闭写缓存：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@chenhong204 ~]# smartctl --set=wcache,off /dev/sdc
smartctl 6.2 2013-07-26 r3841 [x86_64-linux-3.10.0-693.el7.x86_64] (local build)
Copyright (C) 2002-13, Bruce Allen, Christian Franke, www.smartmontools.org

Write cache disabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;开启写缓存：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@chenhong204 ~]# smartctl --set=wcache,on /dev/sdc
smartctl 6.2 2013-07-26 r3841 [x86_64-linux-3.10.0-693.el7.x86_64] (local build)
Copyright (C) 2002-13, Bruce Allen, Christian Franke, www.smartmontools.org

Write cache enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;特别需要注意的是，用 smartctl 设置的值不能持久化，即重启后会恢复默认值。&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2019/08/20/smartctl-wcache/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2019/08/20/smartctl-wcache/</guid>
        
        <category>storage</category>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>在 PEX 程序中访问项目代码 --not-zip-safe</title>
        <description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

&lt;p&gt;当使用 PEX (&lt;em&gt;&lt;a href=&quot;https://github.com/pantsbuild/pex&quot;&gt;https://github.com/pantsbuild/pex&lt;/a&gt;&lt;/em&gt;) 来打包一个 Python 项目时，会发现有些动态的源码访问方式无法使用。例如下面这段代码，通过动态遍历 Python 源文件来载入一个 package 下的所有模块：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;glob&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os.path&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;basename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isfile&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;modules&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glob&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;glob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__file__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;*.py&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__all__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;basename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modules&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__init__.py&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# noqa&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当使用 PEX 进行打包的时候，程序默认会使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--zip-safe&lt;/code&gt; 参数，即在 PEX 程序执行的过程中，源码不会存在到磁盘上，因此 &lt;code class=&quot;highlighter-rouge&quot;&gt;glob.glob()&lt;/code&gt; 会返回一个空列表，所以就无法载入任何模块。如果遇到这个情况，当你需要访问某些子模块时，就会触发如下的错误：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AttributeError: 'module' object has no attribute 'submodule_name'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;如果要支持这样的代码逻辑，需要使用 PEX 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;--not-zip-safe&lt;/code&gt; 模式。当启用该模式时，PEX 在运行程序前，会先把程序的代码解压到 &lt;code class=&quot;highlighter-rouge&quot;&gt;${PEX_ROOT}/code&lt;/code&gt; 目录下 （ PEX_ROOT 可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;--pex-root&lt;/code&gt; 参数指定，默认值是 &lt;em&gt;~/.pex/&lt;/em&gt;），然后再运行程序。这样代码中就可以使用上面这样的逻辑来动态的访问源码文件了。&lt;/p&gt;

&lt;p&gt;但是，使用这个方法有个问题，就是每运行一次，代码就会被保留一份到 &lt;code class=&quot;highlighter-rouge&quot;&gt;${PEX_ROOT}/code&lt;/code&gt; 目录下一次，不仅会占用空间，而且会让别人可以方便的访问到源代码（虽然，直接解压 PEX 文件也能获得源代码）。所以，可以使用类似如下的代码，在程序退出前删除 PEX 解压出来的源代码：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clean_pex_code_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# We use default PEX_ROOT setting.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pex_root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expanduser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;~/.pex&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;code_path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pex_root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;code&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deco&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;# It's necessary to raise catched exception for dumping traceback.&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;code_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;shutil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rmtree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;code_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deco&lt;/span&gt;


&lt;span class=&quot;nd&quot;&gt;@clean_pex_code_dir&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 11 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2019/08/11/pex-vist-source-files/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2019/08/11/pex-vist-source-files/</guid>
        
        <category>python</category>
        
        
      </item>
    
      <item>
        <title>想到什么写什么周报 第46期 - 2019-06-16</title>
        <description>&lt;h2 id=&quot;lessons-learned-porting-50k-loc-from-java-to-go&quot;&gt;Lessons learned porting 50k loc from Java to Go&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://blog.kowalczyk.info/article/19f2fe97f06a47c3b1f118fd06851fad/lessons-learned-porting-50k-loc-from-java-to-go.html&quot;&gt;https://blog.kowalczyk.info/article/19f2fe97f06a47c3b1f118fd06851fad/lessons-learned-porting-50k-loc-from-java-to-go.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;作者使用将 RavenDB 的 Java Client 移植了一个 Go 版本，文章列举了一些移植策略，以及如何使用 Go 实现一些 Java 的特性，比如异常和泛型。&lt;/p&gt;

&lt;h2 id=&quot;stack-history-a-timeline-of-ubers-tech-stack-evolution&quot;&gt;Stack History: A Timeline of Uber’s Tech Stack Evolution&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://stackshare.io/stack-history-timeline-uber-tech-stack-evolution&quot;&gt;https://stackshare.io/stack-history-timeline-uber-tech-stack-evolution&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Uber 的架构进化史。&lt;/p&gt;

&lt;h2 id=&quot;how-to-use-sorted-and-sort-in-python&quot;&gt;How to Use sorted() and sort() in Python&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://realpython.com/python-sort/&quot;&gt;https://realpython.com/python-sort/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;一篇很详细的介绍 Python 的 sorted() 和 sort() 的用法的文章。&lt;/p&gt;

&lt;h2 id=&quot;goodbye-microservices-from-100s-of-problem-children-to-1-superstar&quot;&gt;Goodbye Microservices: From 100s of problem children to 1 superstar&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://segment.com/blog/goodbye-microservices/&quot;&gt;https://segment.com/blog/goodbye-microservices/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;先从一个单体服务变成 100 多个微服务，好处是做到了服务隔离。但是随着服务数量不断的上升，维护成本开始增加，运营效率下降。最后又改回了单体的服务，采用了一些技术来保证单体服务的可靠性，虽然损失了一些微服务的优点，但是获得了巨大的运营效益。&lt;/p&gt;

&lt;p&gt;这个算是一个架构设计的失败案例么？&lt;/p&gt;

&lt;h2 id=&quot;introducing-pg_auto_failover-open-source-extension-for-automated-failover-and-high-availability-in-postgresql&quot;&gt;Introducing pg_auto_failover: Open source extension for automated failover and high-availability in PostgreSQL&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://cloudblogs.microsoft.com/opensource/2019/05/06/introducing-pg_auto_failover-postgresql-open-source-extension-automated-failover-high-availability/&quot;&gt;https://cloudblogs.microsoft.com/opensource/2019/05/06/introducing-pg_auto_failover-postgresql-open-source-extension-automated-failover-high-availability/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Citus （已经被微软收购）出的一个 Postgres 自动 failover 方案，通过一个 monitor 来监控主备数据库，在主挂掉的时候，将备切换为主。同时，从 Postgres 10 开始，一个客户端可以连接多个服务端，会自动选择可以写入的服务端。所以，这个是一套完整的 failover 方案。&lt;/p&gt;

&lt;h2 id=&quot;is-high-quality-software-worth-the-cost&quot;&gt;Is HIgh Quality Software Worth the Cost?&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://martinfowler.com/articles/is-quality-worth-cost.html&quot;&gt;https://martinfowler.com/articles/is-quality-worth-cost.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;作者把软件质量分为外部质量（UI 或者 缺陷，用户可以看到的）和内部质量（架构等用户看不到的）。用户很容易就能看出一个软件是否有很高的外部质量，但是无法看出其内部质量的水平。&lt;/p&gt;

&lt;p&gt;内部质量不好，会导致技术债务快速累积，技术债务会这导致增加新功能的速度变慢，并且容易导致缺陷。所以提升内部质量有助于增加新功能。增加新功能的速度越快，质量越好，软件就越便宜。&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2019/06/16/write-what-i-have-046/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2019/06/16/write-what-i-have-046/</guid>
        
        <category>cloud</category>
        
        <category>golang</category>
        
        <category>python</category>
        
        <category>database</category>
        
        <category>distributed-computing</category>
        
        
      </item>
    
      <item>
        <title>hdparm and sdparm</title>
        <description>&lt;p&gt;&lt;strong&gt;hdparm&lt;/strong&gt; 和 &lt;strong&gt;sdparm&lt;/strong&gt; 是 Linux 下常用的两个查询和设置硬盘参数的工具，这两个工具分别适用于不同的硬盘类型。&lt;/p&gt;

&lt;h2 id=&quot;硬盘类型&quot;&gt;硬盘类型&lt;/h2&gt;

&lt;p&gt;不考虑早起的 IDE 硬盘，以及最新的 NVME 等硬盘，目前主流的硬盘分为两个类型：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;SATA&lt;/strong&gt;: Serial Advanced Technoogy Attachment&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SAS&lt;/strong&gt;: Serial Attached SCSI&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 Linux 系统中，可以用 &lt;strong&gt;smartctl&lt;/strong&gt; 命令查看硬盘的类型。 这里，我们不看这两种接口的标准和实现的差异，重点关注的是使用上的差异。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;转速差距&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SATA 一般是 7200 rpm&lt;/li&gt;
  &lt;li&gt;SAS 一般是 10k 或者 15k rpm&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;IOPS (小 IO)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;7.2k rpm 的 SATA 盘一般是 IOPS 80&lt;/li&gt;
  &lt;li&gt;10k rpm 的 SAS 盘一般是 IOPS 120&lt;/li&gt;
  &lt;li&gt;10k rpm 的 SAS 盘一般是 IOPS 180&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;可靠性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可靠性上，SAS 更可靠。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;SAS drives are more reliable than SATA drives. The industry accepted Mean Time Between Failure (MTBF) for SAS drives is 1.2 million hours vs 700,000 hours MTBF for SATA drives.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;容量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SATA 盘的容量可以做得更大。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In terms of capacity though, SATA drives win hands down. 3TB SATA hard drives are not uncommon and there are 8TB disk offerings in a 3.5 inch format. Generally though they are most cost effective in the 1TB to 3TB range. SAS drives on the other hand tend to max at around 900GB although the most popular configuration is around 450GB to 500GB.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SATA 的线缆长度很短，最多 1 米；SAS 可达 10 米。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;From a physical perspective the data cables are also significantly different. SATA cables are limited to 1 metre in length and the data and power are separate whereas SAS cables can be up to 10 metres in length with power and data provided through the same cable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;hdparm&quot;&gt;hdparm&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;hdparm&lt;/strong&gt; 工具是通过 kernel 的 &lt;strong&gt;libata&lt;/strong&gt; 子系统和 IDE 子系统来和硬盘交互，达到读取或者设置硬盘参数的目的。这个工具并不能百分百兼容 SAS 硬盘，只有部分选项对 SAS 硬盘是有效的，比如 &lt;em&gt;write-caching&lt;/em&gt; 参数就不兼容 SAS 盘。&lt;/p&gt;

&lt;p&gt;hdparm 直接通过指定参数即可和硬盘交互，更详细的文档请参考： &lt;em&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/hdparm&quot;&gt;https://wiki.archlinux.org/index.php/hdparm&lt;/a&gt;&lt;/em&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;man hdparm&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;例如可以用 &lt;strong&gt;-W&lt;/strong&gt; 来设置 SATA 盘的 &lt;em&gt;write-caching&lt;/em&gt; 属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root ~]# hdparm -W 1 /dev/sda
[root ~]# hdparm -W /dev/sda

/dev/sda:
 write-caching =  1 (on)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;sdparm&quot;&gt;sdparm&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;sdparm&lt;/strong&gt; 是一个 SCSI 协议交互工具，用于访问 SCSI mode pages，读取 VPD pages，以及发送简单的 SCSI 命令。因此这个工具一般被用来控制 SAS 盘。这里只是简单说明下几个主要的概念和工具用法，更详细的内容，推荐阅读 &lt;em&gt;&lt;a href=&quot;http://sg.danny.cz/sg/sdparm.html#mozTocId871473&quot;&gt;http://sg.danny.cz/sg/sdparm.html#mozTocId871473&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;h3 id=&quot;scsi-mode-pages&quot;&gt;SCSI mode pages&lt;/h3&gt;

&lt;p&gt;SCSI mode pages 包含了一些 SCSI 设备的元数据，用户可以通过设置这些元数据来改变设备的行为。SCSI 协议在 SPC 中定义了 mode page 相关的内容。&lt;/p&gt;

&lt;p&gt;sdparm 可以使用 &lt;strong&gt;-all&lt;/strong&gt; 参数来查看设备所支持的 page:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root ~]# sdparm --all --long /dev/sdb | grep page
Read write error recovery [rw] mode page:
Disconnect-reconnect (SPC + transports) [dr] mode page:
Format (SBC) [fo] mode page:
Rigid disk (SBC) [rd] mode page:
Verify error recovery (SBC) [ve] mode page:
Caching (SBC) [ca] mode page:
Control [co] mode page:
  ATMPE       0  [cha: n, def:  0, sav:  0]  Application tag mode page enabled
Protocol specific logical unit [pl] mode page:
Protocol specific port [pp] mode page:
Power condition [po] mode page:
Informational exceptions control [ie] mode page:
Background control (SBC) [bc] mode page:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每一行是一个 mode page，其中中括号内的是 page 的缩写。要查询一个 page 的指定内容，每行一个域：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root ~]# sdparm --all --page=ca /dev/sdb
    /dev/sdb: TOSHIBA   MG03SCA200        5702
Caching (SBC) mode page:
  IC          0  [cha: y, def:  0, sav:  0]
  ABPF        0  [cha: n, def:  0, sav:  0]
  CAP         0  [cha: n, def:  0, sav:  0]
  DISC        1  [cha: n, def:  1, sav:  1]
  SIZE        0  [cha: n, def:  0, sav:  0]
  WCE         0  [cha: y, def:  0, sav:  0]
  MF          0  [cha: n, def:  0, sav:  0]
  RCD         0  [cha: y, def:  0, sav:  0]
  DRRP        0  [cha: n, def:  0, sav:  0]
  WRP         0  [cha: n, def:  0, sav:  0]
  DPTL       -1  [cha: n, def: -1, sav: -1]
  MIPF        0  [cha: n, def:  0, sav:  0]
  MAPF        0  [cha: n, def:  0, sav:  0]
  MAPFC      -1  [cha: n, def: -1, sav: -1]
  FSW         1  [cha: y, def:  1, sav:  1]
  LBCSS       0  [cha: n, def:  0, sav:  0]
  DRA         0  [cha: n, def:  0, sav:  0]
  SYNC_PROG   0  [cha: n, def:  0, sav:  0]
  NV_DIS      0  [cha: n, def:  0, sav:  0]
  NCS         8  [cha: y, def:  8, sav:  8]
  CSS         0  [cha: n, def:  0, sav:  0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;--get&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;--set&lt;/code&gt; 来设置一个指定域的值。域的缩写就是上面第一列的大写字母，这个缩写是全局唯一的，在不同的 page 内也不重复。比如查看和设置一个硬盘的 write-caching 的方法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root ~]# sdparm --set WCE=0 --save /dev/sdb
    /dev/sdb: TOSHIBA   MG03SCA200        5702
[root ~]#
[root ~]# sdparm --get=WCE /dev/sdb
    /dev/sdb: TOSHIBA   MG03SCA200        5702
WCE         0  [cha: y, def:  0, sav:  0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;vpd-pages&quot;&gt;VPD pages&lt;/h3&gt;

&lt;p&gt;VPD (Vital Product Data) 是指软件或者硬件提供的一组配置和信息，一般在硬件中都用来存储硬件的关键信息。SCSI 协议是在 SBC 中定义了 VPD 相关的内容，最重要的就是 &lt;strong&gt;Device Identification VPD page (page number: 0x83)&lt;/strong&gt;，这个 page 包含了磁盘序列号等信息。&lt;/p&gt;

&lt;p&gt;在 sdparm 参数中，可以通过指定 &lt;code class=&quot;highlighter-rouge&quot;&gt;--inquiry&lt;/code&gt; 参数来指定要查询的是 VPD pages：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root ~]# sdparm --inquiry --all /dev/sdb
    /dev/sdb: TOSHIBA   MG03SCA200        5702
Supported VPD pages VPD page:
  Supported VPD pages [sv]
  Unit serial number [sn]
  Device identification [di]
  Extended inquiry data [ei]
  Power condition [pc]
  Protocol-specific logical unit information [pslu]
  Block device characteristics (SBC) [bdc]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一般我们是通过 &lt;strong&gt;sn&lt;/strong&gt; page 来查询硬盘的序列号：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root ~]# sdparm --inquiry --page=sn /dev/sdb
    /dev/sdb: TOSHIBA   MG03SCA200        5702
Unit serial number VPD page:
  Z3M0AXXXXXU6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://www.pickaweb.co.uk/kb/difference-between-sata-sas-hard-drives/&quot;&gt;https://www.pickaweb.co.uk/kb/difference-between-sata-sas-hard-drives/&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://www.intel.com/content/www/us/en/support/articles/000005782/server-products.html&quot;&gt;https://www.intel.com/content/www/us/en/support/articles/000005782/server-products.html&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://www.kernel.org/doc/html/v4.13/driver-api/libata.html&quot;&gt;https://www.kernel.org/doc/html/v4.13/driver-api/libata.html&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/SCSI_mode_page&quot;&gt;https://en.wikipedia.org/wiki/SCSI_mode_page&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Vital_Product_Data&quot;&gt;https://en.wikipedia.org/wiki/Vital_Product_Data&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Working Draft SCSI Block Commands - 3 (SBC-3) &lt;em&gt;&lt;a href=&quot;http://t10.org/ftp/t10/document.05/05-344r0.pdf&quot;&gt;http://t10.org/ftp/t10/document.05/05-344r0.pdf&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Working Draft SCSI Primary Commands - 4 (SPC-4) &lt;em&gt;&lt;a href=&quot;http://caxapa.ru/thumbs/563550/spc4r31.pdf&quot;&gt;http://caxapa.ru/thumbs/563550/spc4r31.pdf&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://www.systutorials.com/docs/linux/man/8-sg_vpd/&quot;&gt;https://www.systutorials.com/docs/linux/man/8-sg_vpd/&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 16 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2019/06/16/hdparm-and-sdparm/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2019/06/16/hdparm-and-sdparm/</guid>
        
        <category>storage</category>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>想到什么写什么周报 第45期 - 2019-05-01</title>
        <description>&lt;h2 id=&quot;nginx-add_header-configuration-pitfall&quot;&gt;Nginx add_header configuration pitfall&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://blog.g3rt.nl/nginx-add_header-pitfall.html&quot;&gt;https://blog.g3rt.nl/nginx-add_header-pitfall.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Nginx 的 add_header 指令会清除所有父级的 add_header 指令添加的 header，解决办法写到一个 conf 文件里，在每一级的 block 里 include 进来。&lt;/p&gt;

&lt;h2 id=&quot;understanding-python-metaclasses&quot;&gt;Understanding Python metaclasses&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/&quot;&gt;http://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;一篇很好的关于 Python metaclass 的教程。&lt;/p&gt;

&lt;h2 id=&quot;cloudpinginfo&quot;&gt;CloudPing.info&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.cloudping.info/&quot;&gt;https://www.cloudping.info/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;测试你的浏览器到 AWS 各个region 的延迟。&lt;/p&gt;

&lt;h2 id=&quot;h2nonfiletype&quot;&gt;h2non/filetype&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/h2non/filetype&quot;&gt;https://github.com/h2non/filetype&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;纯 Go 实现的用于推断文件类型的库。&lt;/p&gt;

&lt;h2 id=&quot;boltdb-vs-badger-a-comparison-of-go-key-value-databases&quot;&gt;BoltDB vs Badger: A Comparison of Go Key-Value databases&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://tech.townsourced.com/post/boltdb-vs-badger/&quot;&gt;https://tech.townsourced.com/post/boltdb-vs-badger/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;BoltHold  和 BadgerHold  的作者介绍了 BoltDB 和 Bager 之间的区别，并且提供了选择的建议。&lt;/p&gt;

&lt;h2 id=&quot;katrina-ellison-geltman-code-generation-gos-secret-weapon&quot;&gt;Katrina Ellison Geltman Code Generation: Go’s Secret Weapon&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=3llI65DQB_w&quot;&gt;https://www.youtube.com/watch?v=3llI65DQB_w&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;用 Go 自己的 template 功能来生成 Go 代码，是一个非常使用且方便的做法。&lt;/p&gt;
</description>
        <pubDate>Wed, 01 May 2019 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2019/05/01/write-what-i-have-045/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2019/05/01/write-what-i-have-045/</guid>
        
        <category>cloud</category>
        
        <category>golang</category>
        
        <category>python</category>
        
        <category>storage</category>
        
        
      </item>
    
      <item>
        <title>想到什么写什么周报 第44期 - 2019-03-17</title>
        <description>&lt;h2 id=&quot;happy-fibonacci-day-here-is-how-to-generate-a-fibonacci-sequence-in-postgresql&quot;&gt;Happy Fibonacci day, here is how to generate a Fibonacci sequence in PostgreSQL&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://denisgobo.blogspot.com/2018/11/happy-fibonacci-day-here-is-how-to.html&quot;&gt;https://denisgobo.blogspot.com/2018/11/happy-fibonacci-day-here-is-how-to.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;使用 Fbonacci 数列介绍如何使用 Postgres 的 WITH RECURSIVE 特性。建议去看一下官方文档中关于 WITH 语句递归的计算方法 &lt;em&gt;&lt;a href=&quot;https://www.postgresql.org/docs/9.6/queries-with.html&quot;&gt;https://www.postgresql.org/docs/9.6/queries-with.html&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;h2 id=&quot;a-better-nerdtree-setup&quot;&gt;A better NERDTree setup&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://medium.com/@victormours/a-better-nerdtree-setup-3d3921abc0b9&quot;&gt;https://medium.com/@victormours/a-better-nerdtree-setup-3d3921abc0b9&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;介绍了几个不错的 NERDTree 配置。看了之后，我就从 NERDTreeToggle 换成了  NERDTreeFind。&lt;/p&gt;

&lt;h2 id=&quot;10-awesome-features-of-python-that-you-cant-use-because-you-refuse-to-upgrade-to-python-3&quot;&gt;10 awesome features of Python that you can’t use because you refuse to upgrade to Python 3&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.asmeurer.com/python3-presentation/slides.html&quot;&gt;https://www.asmeurer.com/python3-presentation/slides.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;介绍了 Python3 相对于 Python2 有改进的 10 个地方，让你觉得升级到 Python3 是值得的。至少新项目应该用 Python3.&lt;/p&gt;

&lt;h2 id=&quot;python-3-using-yield-from-in-generators&quot;&gt;Python 3: Using “yield from” in Generators&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://simeonvisser.com/posts/python-3-using-yield-from-in-generators-part-1.html&quot;&gt;http://simeonvisser.com/posts/python-3-using-yield-from-in-generators-part-1.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://simeonvisser.com/posts/python-3-using-yield-from-in-generators-part-2.html&quot;&gt;http://simeonvisser.com/posts/python-3-using-yield-from-in-generators-part-2.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Python 3.3 增加了 yield from 关键字，这两篇文章解释了这个关键字的用途。简单的说，就是方便你写一个生成器，里面用 yield from 包装多个生成器，代码会比较简洁。我觉得在组合多个生成器时，必须要考虑生成器参数的一致性问题。&lt;/p&gt;

&lt;h2 id=&quot;the-state-of-caching-in-go&quot;&gt;The State of Caching in Go&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://blog.dgraph.io/post/caching-in-go/&quot;&gt;https://blog.dgraph.io/post/caching-in-go/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Go 领域最近的网红文章，由 DGraph 公司出品，介绍了目前所有 Go 实现的 cache 系统的特点，然后比较了文中提出的 5 个 cache 系统需要满足的特性。结论是，现在用 Go 实现的 cache 系统都不够好，和 Java 界的 caffine ( &lt;em&gt;&lt;a href=&quot;https://github.com/ben-manes/caffeine&quot;&gt;https://github.com/ben-manes/caffeine&lt;/a&gt;&lt;/em&gt; ) 有些差距。所以 dgraph 打算尝试实现一个 Go 版本的 caffine。&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Mar 2019 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2019/03/17/write-what-i-have-044/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2019/03/17/write-what-i-have-044/</guid>
        
        <category>linux</category>
        
        <category>golang</category>
        
        <category>python</category>
        
        <category>database</category>
        
        
      </item>
    
      <item>
        <title>想到什么写什么周报 第43期 - 2019-02-25</title>
        <description>&lt;h2 id=&quot;an-introduction-to-join-ordering&quot;&gt;An Introduction to Join Ordering&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.cockroachlabs.com/blog/join-ordering-pt1/&quot;&gt;https://www.cockroachlabs.com/blog/join-ordering-pt1/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;介绍了 SQL join 的概念以及 join 操作的数学特性。&lt;/p&gt;

&lt;h2 id=&quot;my-favorite-postgresql-queries-and-why-they-matter&quot;&gt;My Favorite PostgreSQL Queries and Why They Matter&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://severalnines.com/blog/my-favorite-postgresql-queries-and-why-they-matter&quot;&gt;https://severalnines.com/blog/my-favorite-postgresql-queries-and-why-they-matter&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;介绍了 8 个很用的 Postgres 查询技术：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Left join&lt;/li&gt;
  &lt;li&gt;String Cancatenation&lt;/li&gt;
  &lt;li&gt;Supplying IN values list with Subquery’s&lt;/li&gt;
  &lt;li&gt;generate_series()&lt;/li&gt;
  &lt;li&gt;Query’s with the COUNT() aggregate function&lt;/li&gt;
  &lt;li&gt;UPDATE multiple rows with a CASE expression&lt;/li&gt;
  &lt;li&gt;COPY and \copy&lt;/li&gt;
  &lt;li&gt;psql \help meta-command&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;postgrs-window-functions&quot;&gt;Postgrs Window Functions&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://thoughtbot.com/blog/postgres-window-functions&quot;&gt;https://thoughtbot.com/blog/postgres-window-functions&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;用一个 blog 的例子来说明 window function 的用法，是我见过最好的一个例子。&lt;/p&gt;

&lt;h2 id=&quot;life-of-a-sql-query&quot;&gt;Life of a SQL query&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://numeracy.co/blog/life-of-a-sql-query&quot;&gt;https://numeracy.co/blog/life-of-a-sql-query&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;一篇很好的科普文章，介绍了一条 sql 查询从客户端发起到返回的整个过程，包括简单的展示了 Postgres 网络协议的内容，以及数据的存储格式。&lt;/p&gt;

&lt;h2 id=&quot;parsing-logs-230x-faster-with-rust&quot;&gt;Parsing logs 230x faster with Rust&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://andre.arko.net/2018/10/25/parsing-logs-230x-faster-with-rust/&quot;&gt;https://andre.arko.net/2018/10/25/parsing-logs-230x-faster-with-rust/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;使用 Rust 写了一个解析 RubyGems.org 的 log 的程序，比使用 Python 写的快了 78 倍，而且使用 aws lambda 来运行，发现分析 500GB 的 log 文件不用花钱（在 free tier 内）。&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2019/02/25/write-what-i-have-043/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2019/02/25/write-what-i-have-043/</guid>
        
        <category>cloud</category>
        
        <category>database</category>
        
        
      </item>
    
      <item>
        <title>想到什么写什么周报 第42期 - 2019-02-04</title>
        <description>&lt;h2 id=&quot;introducing-the-next-generation-influxdb-20-platform&quot;&gt;Introducing the Next-Generation InfluxDB 2.0 Platform&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.influxdata.com/blog/introducing-the-next-generation-influxdb-2-0-platform/&quot;&gt;https://www.influxdata.com/blog/introducing-the-next-generation-influxdb-2-0-platform/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;InfluxDB 2.0 alpha 版本发布。把原来 TICK 的 4 个功能集中到一个软件里，新的数据查询器，增加了 task 的支持等。&lt;/p&gt;

&lt;h2 id=&quot;why-not-to-build-a-time-series-database&quot;&gt;Why NOT to Build a Time-Series Database&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.outlyer.com/blog/why-not-to-build-a-time-series-database/&quot;&gt;https://www.outlyer.com/blog/why-not-to-build-a-time-series-database/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Outlyer 的广告文。OUtlyer 是一家 TSDB 服务提供商，试图说服你不要自己开发和维护时间序列存储方案 (TSDB)，不过挺有意思的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;介绍了自家做的三代 TSDB 的情况，以及前两代遇到的问题。&lt;/li&gt;
  &lt;li&gt;介绍了为什么开发 TSDB 是困难的，同时说明了，市面上的所有 TSDB 都有优缺点，不可能有完美的方案，需要根据自己的业务进行选择。&lt;/li&gt;
  &lt;li&gt;介绍了 4 个时间序列数据的特点（在其他文章中也常提到）：
    &lt;ul&gt;
      &lt;li&gt;大部分的查询只会查询过去一个小时内的数据。&lt;/li&gt;
      &lt;li&gt;数据点是不可变的。&lt;/li&gt;
      &lt;li&gt;你可以丢一点数据。&lt;/li&gt;
      &lt;li&gt;新查询的数据和上次查询的数据相比只有一点变化，或者基本不变。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;最后介绍了自家的第三代 TSDB 的架构。重要的一点是使用镜像而不是集群方式来备份数据，镜像很简单，集群很复杂（被 DalmatinerDB 坑怕了）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;materialized-views-vs-rollup-tables-in-postgres&quot;&gt;Materialized views vs. Rollup tables in Postgres&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.citusdata.com/blog/2018/10/31/materialized-views-vs-rollup-tables/&quot;&gt;https://www.citusdata.com/blog/2018/10/31/materialized-views-vs-rollup-tables/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;介绍了 Materialzed View 的使用。但是每次 refresh 都需要重新计算数据，对于大表来说性能可能太差，所以有一种变通的办法就是自己建一张 table ，然后使用  upsert 的方式来进行增量更新可以提升性能。&lt;/p&gt;

&lt;h2 id=&quot;sqlite-in-2018-a-state-of-the-art-sql-dialect&quot;&gt;SQLite in 2018: A state of the art SQL dialect&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://modern-sql.com/blog/2019-01/sqlite-in-2018&quot;&gt;https://modern-sql.com/blog/2019-01/sqlite-in-2018&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;SQLite 在 2018 年增加了许多功能，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Boolean Literals and Tests&lt;/li&gt;
  &lt;li&gt;Windos Functions&lt;/li&gt;
  &lt;li&gt;Filter Clause&lt;/li&gt;
  &lt;li&gt;Upsert&lt;/li&gt;
  &lt;li&gt;Rename Column&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gophercon-2014-high-performance-systems-in-go-by-derek-collison&quot;&gt;GopherCon 2014 High Performance Systems in Go by Derek Collison&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://youtu.be/ylRKac5kSOk&quot;&gt;https://youtu.be/ylRKac5kSOk&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;CNCF 项目 NATS 的作者 2014 年在 GopherCon 上的演讲。介绍了几个优化系统性能的事件，把 NATS 的性能从 500k msg/s 提升到了 5 - 6m msg/s&lt;/p&gt;

&lt;h2 id=&quot;top-50-developer-tools-of-2018&quot;&gt;TOP 50 DEVELOPER TOOLS OF 2018&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://stackshare.io/posts/top-developer-tools-2018&quot;&gt;https://stackshare.io/posts/top-developer-tools-2018&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;stackshare 评选出来的 2018 年 50 大开发者工具。&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2019/02/04/write-what-i-have-042/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2019/02/04/write-what-i-have-042/</guid>
        
        <category>cloud</category>
        
        <category>golang</category>
        
        <category>distributed-computing</category>
        
        <category>database</category>
        
        
      </item>
    
  </channel>
</rss>
