<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coffee, Coke and Code</title>
    <description>Archive diabloneo&apos;s articles.
</description>
    <link>http://diabloneo.github.io//</link>
    <atom:link href="http://diabloneo.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 01 Mar 2023 19:29:05 +0800</pubDate>
    <lastBuildDate>Wed, 01 Mar 2023 19:29:05 +0800</lastBuildDate>
    <generator>Jekyll v4.3.1</generator>
    
      <item>
        <title>Sysfs Note -- 1</title>
        <description>&lt;h2 id=&quot;sysfs&quot;&gt;sysfs&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;sysfs&lt;/strong&gt; 是一个内存文件系统，用于将内核的数据结构暴露出来。&lt;/p&gt;

&lt;p&gt;任何 kobject 在系统中注册，就会有一个目录在 sysfs 中被创建出来。这个目录是作为 kobject 的父对象所在的目录的子目录创建的。每个 kobject 的属性，会以目录中的普通文件的形式出现。&lt;/p&gt;

&lt;h2 id=&quot;kobject&quot;&gt;kobject&lt;/h2&gt;

&lt;p&gt;Kobject 是一个类型为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct kobject&lt;/code&gt; 的对象，它包含 name, ref count, parent pointer 等，使得 kobject 可以被组织成层次结构，并且通过 sysfs 暴露出来。Kobject 本身没有包含其他具体的功能，它主要通过被嵌入到其他的结构体中来使用。&lt;/p&gt;

&lt;h2 id=&quot;uevent&quot;&gt;uevent&lt;/h2&gt;

&lt;p&gt;Sysfs 的 device 目录下有个 &lt;em&gt;*uevent&lt;/em&gt; 文件。uevent 的是 udev event 的缩写。&lt;/p&gt;

&lt;p&gt;uevent 这个文件可读可写，当你读这个文件的时候，会返回这个设备最后一次被 kernel 发送的 udev 事件（这里就是这个设备被 add  event，remove 的不会存在，因为 remove 发生后，整个设备目录都没了）。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@centos8 block]# cat nvme0n1/uevent
MAJOR=259
MINOR=0
DEVNAME=nvme0n1
DEVTYPE=disk
DISKSEQ=1
[root@centos8 block]# cat sdc/uevent
MAJOR=8
MINOR=32
DEVNAME=sdc
DEVTYPE=disk
DISKSEQ=4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;uevent 本身是一个 kernel 的机制，用于通知用户态的 udev 程序，关于设备的相关事件。在新的系统中，用户态的程序是在 systemd 中实现的，即 &lt;strong&gt;systemd-udevd&lt;/strong&gt; ：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@centos8 block]# systemctl cat systemd-udevd
# /usr/lib/systemd/system/systemd-udevd.service
#  SPDX-License-Identifier: LGPL-2.1+
#
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=udev Kernel Device Manager
Documentation=man:systemd-udevd.service(8) man:udev(7)
DefaultDependencies=no
After=systemd-sysusers.service systemd-hwdb-update.service
Before=sysinit.target
ConditionPathIsReadWrite=/sys

[Service]
Type=notify
OOMScoreAdjust=-1000
Sockets=systemd-udevd-control.socket systemd-udevd-kernel.socket
Restart=always
RestartSec=0
ExecStart=/usr/lib/systemd/systemd-udevd
KillMode=mixed
WatchdogSec=3min
TasksMax=infinity
PrivateMounts=yes
MemoryDenyWriteExecute=yes
RestrictAddressFamilies=AF_UNIX AF_NETLINK AF_INET AF_INET6
RestrictRealtime=yes
RestrictSUIDSGID=yes
SystemCallFilter=@system-service @module @raw-io
SystemCallErrorNumber=EPERM
SystemCallArchitectures=native
LockPersonality=yes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个程序并不是通过逐个读取 sysfs 的 uevent 文件的内容来获取信息的，而是通过 &lt;strong&gt;uevent netlink&lt;/strong&gt; 来获得内核发送的 uevent：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@centos8 block]# ps -ef | grep systemd-udevd
root        1830       1  0 Feb18 ?        00:00:01 /usr/lib/systemd/systemd-udevd
root      807799 3741741  0 23:03 pts/93   00:00:00 grep --color=auto systemd-udevd
[root@centos8 block]# lsof -p 1830 | grep -i uevent
systemd-u 1830 root    3u  netlink                         0t0     92397 KOBJECT_UEVENT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;include/uapi/linux/netlink.h&lt;/em&gt; 文件中定义了这个 netlink 类型&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#define NETLINK_KOBJECT_UEVENT        15        /* Kernel messages to userspace */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;既然 udev 是通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NETLINK_KOBJECT_UEVENT&lt;/code&gt; 来接收事件的，为什么还需要 uevent 文件呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个是用于解决开机启动以及 udevd 重启的情况。当 udevd 启动时，它会扫描 sysfs 中所有设备的 uevent 文件，然后针对每个文件写入一个 ADD 内容，这样就可以触发 kernel 再一次通知和该设备有关的事件，然后 udevd 就可以收到该事件，并进行 udev rule 的处理。&lt;/p&gt;

&lt;h2 id=&quot;ref&quot;&gt;Ref&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://documentation.suse.com/sles/12-SP5/html/SLES-all/cha-udev.html&quot;&gt;https://documentation.suse.com/sles/12-SP5/html/SLES-all/cha-udev.html&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://lwn.net/Articles/646617/&quot;&gt;https://lwn.net/Articles/646617/&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://unix.stackexchange.com/questions/550037/how-does-udev-uevent-work&quot;&gt;https://unix.stackexchange.com/questions/550037/how-does-udev-uevent-work&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 01 Mar 2023 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2023/03/01/sysfs-note-1/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2023/03/01/sysfs-note-1/</guid>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>Kubernetes 代码笔记 -- 2</title>
        <description>&lt;h2 id=&quot;apimachinery-中的概念&quot;&gt;apimachinery 中的概念&lt;/h2&gt;

&lt;p&gt;Kubernetes 的 api 相关代码中有很多概念都是 k8s 独有的，需要专门理解一下，才方便研究 k8s 代码。&lt;/p&gt;

&lt;p&gt;Kubebuilder 项目有一篇文章比较好的介绍了这些关键概念的理解，可以先阅读一下：&lt;em&gt;&lt;a href=&quot;https://book.kubebuilder.io/cronjob-tutorial/gvks.html&quot;&gt;https://book.kubebuilder.io/cronjob-tutorial/gvks.html&lt;/a&gt;&lt;/em&gt;。我这里写的是我个人的理解。&lt;/p&gt;

&lt;h3 id=&quot;gvk-groupversionkind&quot;&gt;GVK: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GroupVersionKind&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;k8s.io/apimachinery/pkg/runtime/schema/group_version.go&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GroupVersionKind unambiguously identifies a kind.  It doesn&apos;t anonymously include GroupVersion
// to avoid automatic coercion.  It doesn&apos;t use a GroupVersion to avoid custom marshalling
type GroupVersionKind struct {
	Group   string
	Version string
	Kind    string
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个结构体包含了 API 的 group, version 和 kind 信息。这里的 kind 是对应的 Go 结构体的 type 名称。比如 &lt;strong&gt;StatefulSet&lt;/strong&gt; 就是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GroupVersionKind{Group: &quot;apps&quot;, Version: &quot;v1&quot;, Kind: &quot;StatefulSet&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;gvr-groupversionresource&quot;&gt;GVR: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GroupVersionResource&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;k8s.io/apimachinery/pkg/runtime/schema/group_version.go&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GroupVersionResource unambiguously identifies a resource.  It doesn&apos;t anonymously include GroupVersion
// to avoid automatic coercion.  It doesn&apos;t use a GroupVersion to avoid custom marshalling
type GroupVersionResource struct {
	Group    string
	Version  string
	Resource string
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GroupVersionResource{Group: &quot;rbac.authorization.k8s.io&quot;, Version: &quot;v1&quot;, Resource: &quot;clusterroles&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个结构体包含了 API 的 group, version 和 resource 信息。这里的 resource 对应的是 API 路径里的名字。很容易会搞混 resource 和 kind 的区别，我觉得可以这么理解：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Resource 是 API 侧的概念，是根据 API 路径推导出来的资源类型名称，例如 pods, deployments 等（下面会说单复数的问题）。&lt;/li&gt;
  &lt;li&gt;Kind 是 API 路径里得到这个资源类型名称所对应的 Go 的结构体的 type 名称。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在现有的代码中，GVR 在 apiserver 端是比较少使用的，反而是在 controller 和 client 中会用得多一些。&lt;/p&gt;

&lt;h4 id=&quot;apiserver-中的使用&quot;&gt;apiserver 中的使用&lt;/h4&gt;

&lt;p&gt;下面这个函数中会添加 API 请求的 handler。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; k8s.io/apiserver/pkg/endpoints/installer.go: func (a *APIInstaller) registerResourceHandlers()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APIInstaller&lt;/code&gt; 中已经包含了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APIGroupVersion&lt;/code&gt;，所以在添加的过程中，可以根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GroupVersion&lt;/code&gt; 直接得到 GVK：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	fqKindToRegister, err := GetResourceKind(a.group.GroupVersion, storage, a.group.Typer)
	if err != nil {
		return nil, nil, err
	}

	...

	reqScope := handlers.RequestScope{
		# 这里也生成了 GVR
		Resource:    a.group.GroupVersion.WithResource(resource),
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;restmapper&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RESTMapper&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;其他地方的使用更多的是依赖于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RESTMapper&lt;/code&gt; 来根据 GVR 获得 GVK。&lt;/p&gt;

&lt;p&gt;有好几种 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RESTMapper&lt;/code&gt;，默认的如下：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;k8s.io/apimachinery/pkg/api/meta/restmapper.go&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// DefaultRESTMapper exposes mappings between the types defined in a
// runtime.Scheme. It assumes that all types defined the provided scheme
// can be mapped with the provided MetadataAccessor and Codec interfaces.
//
// The resource name of a Kind is defined as the lowercase,
// English-plural version of the Kind string.
// When converting from resource to Kind, the singular version of the
// resource name is also accepted for convenience.
//
// TODO: Only accept plural for some operations for increased control?
// (`get pod bar` vs `get pods bar`)
type DefaultRESTMapper struct {
	defaultGroupVersions []schema.GroupVersion

	resourceToKind       map[schema.GroupVersionResource]schema.GroupVersionKind
	kindToPluralResource map[schema.GroupVersionKind]schema.GroupVersionResource
	kindToScope          map[schema.GroupVersionKind]RESTScope
	singularToPlural     map[schema.GroupVersionResource]schema.GroupVersionResource
	pluralToSingular     map[schema.GroupVersionResource]schema.GroupVersionResource
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从它的内容可以看出，它是在 resource 和 kind 之间做映射的。同时，它还指出了，resource name 是根据 kind 来的，小写且是复数。不过，为了方便，也支持单数形式的 resource name。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefaultRESTMapper&lt;/code&gt; 实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RESTMapper&lt;/code&gt; interface。这个 interface 定义了一些方法用来实现转换，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KindFor&lt;/code&gt; 根据 GVR 得到 GVK:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	// KindFor takes a partial resource and returns the single match.  Returns an error if there are multiple matches
	KindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;根据使用场景补充，k8s 中还实现了好几个不同的 RESTMapper，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MultiRESTMapper&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefferedDiscoveryRESTMapper&lt;/code&gt; 等。&lt;/p&gt;

&lt;h3 id=&quot;scheme&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;k8s.io/apimachinery/pkg/runtime/scheme.go&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt; 的主要工作就是保存 Go 类型和对应的 API 信息之间的关系。通过它的一些成员可以看出它的设计目标就是保存这种映射关系：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Scheme struct {
	// gvkToType allows one to figure out the go type of an object with
	// the given version and name.
	gvkToType map[schema.GroupVersionKind]reflect.Type

	// typeToGVK allows one to find metadata for a given go object.
	// The reflect.Type we index by should *not* be a pointer.
	typeToGVK map[reflect.Type][]schema.GroupVersionKind

	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一般来说，一大堆的 API 可以共用一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt;，比如 legacy API 都是共用下面这个文件中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt; 对象：&lt;em&gt;pkg/api/legacyscheme/scheme.go&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;代码中一般是使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt; 对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AddKnownTypes&lt;/code&gt; 方法把 Go 对象添加到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt; 中的。搜索这个方法可以找到 API 对象被添加的路径。以 rbac 为例：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;pkg/apis/rbac/register.go&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GroupName is the name of this API group.
const GroupName = &quot;rbac.authorization.k8s.io&quot;

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: GroupName, Version: runtime.APIVersionInternal}

// SchemeBuilder is a function that calls Register for you.
var (
	SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)
	AddToScheme   = SchemeBuilder.AddToScheme
)

// Adds the list of known types to the given scheme.
func addKnownTypes(scheme *runtime.Scheme) error {
	scheme.AddKnownTypes(SchemeGroupVersion,
		&amp;amp;Role{},
		&amp;amp;RoleBinding{},
		&amp;amp;RoleBindingList{},
		&amp;amp;RoleList{},

		&amp;amp;ClusterRole{},
		&amp;amp;ClusterRoleBinding{},
		&amp;amp;ClusterRoleBindingList{},
		&amp;amp;ClusterRoleList{},
	)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外，你可以根据上面代码中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AddToScheme&lt;/code&gt; 方法推导出：当这个方法被调用时，就会执行这些添加操作。因此，也可以在代码中搜索 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rbac.*AddToScheme&lt;/code&gt; 来找到添加的地方：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;pkg/apis/rbac/install/install.go&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func init() {
	Install(legacyscheme.Scheme)
}

// Install registers the API group and adds types to a scheme
func Install(scheme *runtime.Scheme) {
	utilruntime.Must(rbac.AddToScheme(scheme))
	utilruntime.Must(v1.AddToScheme(scheme))
	utilruntime.Must(v1beta1.AddToScheme(scheme))
	utilruntime.Must(v1alpha1.AddToScheme(scheme))
	utilruntime.Must(scheme.SetVersionPriority(v1.SchemeGroupVersion, v1beta1.SchemeGroupVersion, v1alpha1.SchemeGroupVersion))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以，只要这个 pkg 被 import，rbac 的这些信息就会被注册到 legacy 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheme&lt;/code&gt; 中。在这个 API Group 的 storage 被初始化的时候，这个 pkg 就会被 import：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; pkg/registry/rbac/rest/storage_rest.go: func (p RESTStorageProvider) NewRESTStorage()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 13 Feb 2023 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2023/02/13/kubernetes-code-note-2/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2023/02/13/kubernetes-code-note-2/</guid>
        
        <category>kubernetes</category>
        
        
      </item>
    
      <item>
        <title>Kubernetes 代码笔记 -- 1</title>
        <description>&lt;h2 id=&quot;apiserver-中的路由注册&quot;&gt;apiserver 中的路由注册&lt;/h2&gt;

&lt;h3 id=&quot;在哪里进行的路由注册&quot;&gt;在哪里进行的路由注册？&lt;/h3&gt;

&lt;p&gt;我们以 core API 为例 (也称为 legacy API)，kube-apiserver 从启动开始，到开始注册 go-restful 之前的代码路径是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; cmd/kube-apiserver/app/server.go: func CreateServerChain()
	-&amp;gt; cmd/kube-apiserver/app/server.go: func CreateKubeAPIServer()
		-&amp;gt; pkg/controlplane/instance.go: func (c *completedConfig) New()
			-&amp;gt; k8s.io/apiserver/pkg/server/config.go func (c completedConfig) New()
				-&amp;gt; k8s.io/apiserver/pkg/server/handler.go NewAPIServerHandler()
					# 这里会初始化 restful.Container
				-&amp;gt; k8s.io/apiserver/pkg/server/config.go installAPI()
					# 这里会添加 profile, metric 等固定的 API
			-&amp;gt; pkg/controlplane/instance.go: func (m *Instance) InstallLegacyAPI()
				-&amp;gt; k8s.io/apiserver/pkg/server/genericapiserver.go: func (s *GenericAPIServer) InstallLegacyAPIGroup()
					-&amp;gt; k8s.io/apiserver/pkg/server/genericapiserver.go: func (s *GenericAPIServer) installAPIResources()
						-&amp;gt; k8s.io/apiserver/pkg/endpoints/groupversion.go: func (g *APIGroupVersion) InstallREST()
							-&amp;gt; k8s.io/apiserver/pkg/endpoints/installer.go: func (a *APIInstaller) Install()
								# 这里会创建 restful.WebService 对象
								-&amp;gt; k8s.io/apiserver/pkg/endpoints/installer.go: func (a *APIInstaller) registerResourceHandlers()
									# 这个函数很长，大概有 800 行，就是根据 API 对象的信息，向 restful.WebService 中添加路由。
							# 将得到的 restful.WebService 添加到 restful.Container 中。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面是大概的流程结束之后，就会开始运行 apiserver，大概流程是如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; cmd/kube-apiserver/app/server.go: Run()
	-&amp;gt; k8s.io/kube-aggregator/pkg/apiserver/apiserver.go: func (s *APIAggregator) PrepareRun()
		-&amp;gt; k8s.io/apiserver/pkg/server/genericapiserver.go: func (s *GenericAPIServer) PrepareRun()
	-&amp;gt; k8s.io/kube-aggregator/pkg/apiserver/apiserver.go: func (s preparedAPIAggregator) Run()
		-&amp;gt; k8s.io/apiserver/pkg/server/genericapiserver.go: func (s preparedGenericAPIServer) Run()
			# 这里最终根据 GenericAPIServer.APIServerHandler 来创建 http server
			# GenericAPIServer.APIServerHandler 则会将请求路由到它内部的 restful.Container 中，
			# 这个 container 包含了我们注册的 API
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;注册了哪些路由&quot;&gt;注册了哪些路由？&lt;/h3&gt;

&lt;p&gt;上一小节提到了，每个资源的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restful.WebService&lt;/code&gt; 中注册的路由都在如下方法中实现：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k8s.io/apiserver/pkg/endpoints/installer.go: func (a *APIInstaller) registerResourceHandlers()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个函数的主要工具就是根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APIGroupVersion&lt;/code&gt; 的信息生成需要添加到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restful.WebService&lt;/code&gt; 中的 route 内容，最主要部分就是指定 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handler&lt;/code&gt;，如下代码所示：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;			route := ws.GET(action.Path).To(handler).	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为 kubernetes 的所有资源的 API 都是统一的，所以你可以在这个函数里看到所有 API 的路由实现。&lt;/p&gt;

&lt;h3 id=&quot;路由的-handler-在哪里&quot;&gt;路由的 handler 在哪里？&lt;/h3&gt;

&lt;p&gt;找到一个路由后，我们就知道了 path，解析来还需要知道它是如何被 handle 的，也就是要找到 handler 的实现。&lt;/p&gt;

&lt;p&gt;只要你继续跟进 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func (a *APIInstaller) registerResourceHandlers()&lt;/code&gt; 的代码，就会发现，所有的 handler 都是在&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k8s.io/apiserver/pkg/endpoints/handlers&lt;/code&gt; 这个模块中实现的。比如资源的 List 接口，就是在如下位置实现：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;k8s.io/apiserver/pkg/endpoints/handlers/get.go: func ListResource()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个函数里，你可以看到 List 的实现，以及 Watch 的实现。&lt;/p&gt;

&lt;h3 id=&quot;handler-和资源的实现是如何关联起来的&quot;&gt;Handler 和资源的实现是如何关联起来的？&lt;/h3&gt;

&lt;p&gt;上面提到的功能，都是 apiserver 统一实现的，也就是说，每个资源都不需要自己实现这些部分。每个资源需要实现的部分，主要是数据操作部分。&lt;/p&gt;

&lt;h4 id=&quot;registry&quot;&gt;Registry&lt;/h4&gt;

&lt;p&gt;这就要提到 &lt;strong&gt;registry&lt;/strong&gt;  这个概念了，这个 registry 是 kubernetes 项目内部的代码上的概念，不是容器镜像那个概念。&lt;/p&gt;

&lt;p&gt;在代码中可以找到这个概念的官方说明：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Package registry contains the generic implementation of the storage and system logic.
package registry // import &quot;k8s.io/apiserver/pkg/registry&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再简化一点的说，就是 kubernetes 项目中的 model 层。因为 k8s 使用 etcd 作为存储，所以就是一个使用 etcd 作为存储的 model 层。&lt;/p&gt;

&lt;h4 id=&quot;storage-interface&quot;&gt;Storage Interface&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;k8s.io/apiserver/pkg/registry/rest/rest.go&lt;/em&gt; 这个文件定义了存储的接口，代码中的一段注释说明了这个接口的定义：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Storage interfaces need to be separated into two groups; those that operate
// on collections and those that operate on individually named items.
// Collection interfaces:
// (Method: Current -&amp;gt; Proposed)
//    GET: Lister -&amp;gt; CollectionGetter
//    WATCH: Watcher -&amp;gt; CollectionWatcher
//    CREATE: Creater -&amp;gt; CollectionCreater
//    DELETE: (n/a) -&amp;gt; CollectionDeleter
//    UPDATE: (n/a) -&amp;gt; CollectionUpdater
//
// Single item interfaces:
// (Method: Current -&amp;gt; Proposed)
//    GET: Getter -&amp;gt; NamedGetter
//    WATCH: (n/a) -&amp;gt; NamedWatcher
//    CREATE: (n/a) -&amp;gt; NamedCreater
//    DELETE: Deleter -&amp;gt; NamedDeleter
//    UPDATE: Update -&amp;gt; NamedUpdater
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Storage&lt;/code&gt; 的 interface:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Storage is a generic interface for RESTful storage services.
// Resources which are exported to the RESTful API of apiserver need to implement this interface. It is expected
// that objects may implement any of the below interfaces.
type Storage interface {
	// New returns an empty object that can be used with Create and Update after request data has been put into it.
	// This object must be a pointer type for use with Codec.DecodeInto([]byte, runtime.Object)
	New() runtime.Object

	// Destroy cleans up its resources on shutdown.
	// Destroy has to be implemented in thread-safe way and be prepared
	// for being called more than once.
	Destroy()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个类型，就是传递给上面那个添加路由函数的第二个参数：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (a *APIInstaller) registerResourceHandlers(path string, storage rest.Storage, ws *restful.WebService) (*metav1.APIResource, *storageversion.ResourceInfo, error) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因此，每个通过这个方法添加到 apiserver 的资源，都实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rest.Storage&lt;/code&gt; 这个接口。并且，还有可能实现其他的接口，如果有实现，就会添加对应的 API。&lt;strong&gt;因此，我们要看一个资源如何实现自己的 API 时，应该是去找它的 storage 实现。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;legacy-api-storage&quot;&gt;Legacy API Storage&lt;/h4&gt;

&lt;p&gt;上面提到的这个方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pkg/controlplane/instance.go: func (m *Instance) InstallLegacyAPI()&lt;/code&gt; 会在创建 apiserver 的时候被调用到，其中会添加我们最熟悉的那些资源的 storage，比如 pod。我们来具体看一下 pod 的 storage 添加的过程：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-&amp;gt; pkg/controlplane/instance.go: func (m *Instance) InstallLegacyAPI()
	-&amp;gt; pkg/registry/core/rest/storage_ore.go: func (c LegacyRESTStorageProvider) NewLegacyRESTStorage()
		-&amp;gt; pkg/registry/core/pod/storage/storage.go: func NewStorage()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NewStorage()&lt;/code&gt; 函数会返回一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PodStorage&lt;/code&gt; 对象：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// PodStorage includes storage for pods and all sub resources
type PodStorage struct {
	Pod                 *REST
	Binding             *BindingREST
	LegacyBinding       *LegacyBindingREST
	Eviction            *EvictionREST
	Status              *StatusREST
	EphemeralContainers *EphemeralContainersREST
	Log                 *podrest.LogREST
	Proxy               *podrest.ProxyREST
	Exec                *podrest.ExecREST
	Attach              *podrest.AttachREST
	PortForward         *podrest.PortForwardREST
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个对象里的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod&lt;/code&gt; 成员，就是实现了 pod 常规 API 所需的 storage 接口：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// REST implements a RESTStorage for pods
type REST struct {
	*genericregistry.Store
	proxyTransport http.RoundTripper
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它的大部分方法都是内嵌的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;genericregistry.Store&lt;/code&gt; 实现的，所以你可以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Store&lt;/code&gt; 对象中找到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; 方法的实现：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// List returns a list of items matching labels and field according to the
// store&apos;s PredicateFunc.
func (e *Store) List(ctx context.Context, options *metainternalversion.ListOptions) (runtime.Object, error) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个方法就是实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k8s.io/apiserver/pkg/registry/rest/rest.go: ListerInterface&lt;/code&gt;中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; 方法：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Lister is an object that can retrieve resources that match the provided field and label criteria.
type Lister interface {
	// NewList returns an empty object that can be used with the List call.
	// This object must be a pointer type for use with Codec.DecodeInto([]byte, runtime.Object)
	NewList() runtime.Object
	// List selects resources in the storage which match to the selector. &apos;options&apos; can be nil.
	List(ctx context.Context, options *metainternalversion.ListOptions) (runtime.Object, error)
	// TableConvertor ensures all list implementers also implement table conversion
	TableConvertor
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pod 是一个很复杂的资源，还有很多其他的 storage 实现，以支持更多的 API：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# pkg/registry/core/rest/storage_ore.go: func (c LegacyRESTStorageProvider) NewLegacyRESTStorage()

	storage := map[string]rest.Storage{}
	if resource := &quot;pods&quot;; apiResourceConfigSource.ResourceEnabled(corev1.SchemeGroupVersion.WithResource(resource)) {
		storage[resource] = podStorage.Pod
		storage[resource+&quot;/attach&quot;] = podStorage.Attach
		storage[resource+&quot;/status&quot;] = podStorage.Status
		storage[resource+&quot;/log&quot;] = podStorage.Log
		storage[resource+&quot;/exec&quot;] = podStorage.Exec
		storage[resource+&quot;/portforward&quot;] = podStorage.PortForward
		storage[resource+&quot;/proxy&quot;] = podStorage.Proxy
		storage[resource+&quot;/binding&quot;] = podStorage.Binding
		if podStorage.Eviction != nil {
			storage[resource+&quot;/eviction&quot;] = podStorage.Eviction
		}
		storage[resource+&quot;/ephemeralcontainers&quot;] = podStorage.EphemeralContainers

	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;Kubernetes 的 API 实现代码很复杂，看代码是很容易被绕晕的。&lt;/p&gt;

&lt;p&gt;Storage 本身还有 cache 的实现，以及 etcd 访问的实现，本文并没有涉及。&lt;/p&gt;
</description>
        <pubDate>Sat, 11 Feb 2023 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2023/02/11/kubernetes-code-note-1/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2023/02/11/kubernetes-code-note-1/</guid>
        
        <category>kubernetes</category>
        
        
      </item>
    
      <item>
        <title>go-yaml 的默认 map 类型是 map[any]any</title>
        <description>&lt;p&gt;Go 语言的 yaml 库 &lt;em&gt;&amp;lt;github.com/go-yaml/yaml&amp;gt;&lt;/em&gt; 的默认 map 类型是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map[any]any&lt;/code&gt;，而不是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map[string]any&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;V2 代码：&lt;em&gt;&lt;a href=&quot;https://github.com/go-yaml/yaml/blob/v2/decode.go#L241&quot;&gt;https://github.com/go-yaml/yaml/blob/v2/decode.go#L241&lt;/a&gt;&lt;/em&gt;
V3 代码：&lt;em&gt;&lt;a href=&quot;https://github.com/go-yaml/yaml/blob/v3/decode.go#L334&quot;&gt;https://github.com/go-yaml/yaml/blob/v3/decode.go#L334&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;因此，当使用这个库对 yaml 内容进行 unmarshal 的时候，由 go-yaml 自动创建的 map 的类型是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map[any]any&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;fmt&quot;
	&quot;log&quot;

	&quot;gopkg.in/yaml.v2&quot;
)

var content = `
storage:
  settings:
    fs:
      ad:
        username: admin
      ldap:
        password: password

`

type Storage struct {
	Settings map[string]any `yaml:&quot;settings&quot;`
}

type Config struct {
	Storage *Storage `yaml:&quot;storage&quot;`
}

func main() {
	c := new(Config)
	err := yaml.Unmarshal([]byte(content), c)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf(&quot;%T\n&quot;, c.Storage.Settings[&quot;fs&quot;])
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码的输出是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;❯ go run testcmd.go
map[interface {}]interface {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 02 Nov 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/11/02/go-yaml-default-map-type-is-map-any-any/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/11/02/go-yaml-default-map-type-is-map-any-any/</guid>
        
        <category>golang</category>
        
        
      </item>
    
      <item>
        <title>GRUB2 menu and kernel-install</title>
        <description>&lt;h2 id=&quot;bls-boot-loader-specification&quot;&gt;BLS: Boot Loader Specification&lt;/h2&gt;

&lt;p&gt;在新的发行版上，普遍采用了 &lt;strong&gt;GRUB2&lt;/strong&gt; （以下简称 GRUB） 作为 boot loader。GRUB2 现在采用了 &lt;strong&gt;Boot Loader Specification&lt;/strong&gt; （简称 BLS） 来管理启动菜单： &lt;em&gt;&lt;a href=&quot;https://systemd.io/BOOT_LOADER_SPECIFICATION/&quot;&gt;https://systemd.io/BOOT_LOADER_SPECIFICATION/&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;在非 UEFI Secure 启动的情况下，启动菜单直接使用文本文件保存，方便维护。你可以在一个使用该标准的系统上查看这些文件，例如 Rocky Linux 8.5：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ll /boot/loader/entries/
total 12
-rw-r--r--. 1 root root 405 May 10 13:54 a0284538aa5b498cb38b8e530b2a6be4-0-rescue.conf
-rw-r--r--. 1 root root 353 May 10 13:54 a0284538aa5b498cb38b8e530b2a6be4-4.18.0-348.el8.0.2.x86_64.conf

# cat a0284538aa5b498cb38b8e530b2a6be4-4.18.0-348.el8.0.2.x86_64.conf
title Rocky Linux (4.18.0-348.el8.0.2.x86_64) 8.5 (Green Obsidian)
version 4.18.0-348.el8.0.2.x86_64
linux /vmlinuz-4.18.0-348.el8.0.2.x86_64
initrd /initramfs-4.18.0-348.el8.0.2.x86_64.img $tuned_initrd
options $kernelopts $tuned_params
id rocky-20211114010422-4.18.0-348.el8.0.2.x86_64
grub_users $grub_users
grub_arg --unrestricted
grub_class kernel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;machine-id&quot;&gt;Machine ID&lt;/h2&gt;

&lt;p&gt;Machine ID 是一个在系统安装的时候生成的 UUID，用于表示系统的唯一性。它存放在 &lt;em&gt;/etc/machine-id&lt;/em&gt; 文件中&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cat /etc/machine-id
a0284538aa5b498cb38b8e530b2a6be4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以查看 man 手册获取更多信息： &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;man machine-id&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;grub-菜单的生成&quot;&gt;GRUB 菜单的生成&lt;/h2&gt;

&lt;p&gt;GRUB 菜单是在 kernel 安装的时候生成的，在 kernel 卸载的时候删除的，这整个过程是由 &lt;strong&gt;kernel-install&lt;/strong&gt; 命令来完成的。在 RHEL 8 及衍生系统上，这个程序由 &lt;strong&gt;systemd-udev&lt;/strong&gt; 包来提供。&lt;/p&gt;

&lt;h3 id=&quot;kernel-install&quot;&gt;kernel-install&lt;/h3&gt;

&lt;p&gt;这个程序只有两个功能，添加内核，和删除内核：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# kernel-install --help
Usage:
        /usr/bin/kernel-install add KERNEL-VERSION KERNEL-IMAGE
        /usr/bin/kernel-install remove KERNEL-VERSION
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它本身是通过一系列的脚本来实现的，这些脚本存放在：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;/usr/lib/kernel/install.d/&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;/etc/kernel/install.d/&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认脚本存放在 &lt;em&gt;/usr/lib/kernel/install.d&lt;/em&gt; 目录下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@overlord-sz3 install.d]# cd /usr/lib/kernel/install.d/
[root@overlord-sz3 install.d]# ll
total 40
-rwxr-xr-x. 1 root root 7120 Nov 14  2021 20-grub.install
-rwxr-xr-x. 1 root root 2252 Nov  9  2021 20-grubby.install
-rwxr-xr-x. 1 root root  368 Jun 22  2018 50-depmod.install
-rwxr-xr-x. 1 root root 1657 Nov  9  2021 50-dracut.install
-rwxr-xr-x. 1 root root 3338 Nov  9  2021 51-dracut-rescue.install
-rwxr-xr-x. 1 root root  791 Oct 13  2021 60-kdump.install
-rwxr-xr-x. 1 root root 1975 Nov  9  2021 90-loaderentry.install
-rwxr-xr-x. 1 root root  989 Jul 22  2021 92-tuned.install
-rwxr-xr-x. 1 root root  454 Nov 14  2021 99-grub-mkconfig.install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这些都是 shell 脚本，主要是完成一些配置。例如 &lt;em&gt;20-grub.install&lt;/em&gt; 和 &lt;em&gt;90-loaderentry.install&lt;/em&gt; 这两个脚本就是完成 grub 相关的一些配置。&lt;/p&gt;

&lt;p&gt;另外，kernel-install 对于这些脚本返回值做了一个特殊的规定：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;An executable should return 0 on success. It may also return 77 to cause the whole operation to terminate (executables later in lexical order will be skipped).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以，如果一个脚本返回了 77，那么后续的都会被跳过。&lt;/p&gt;

&lt;h3 id=&quot;生成菜单的脚本&quot;&gt;生成菜单的脚本&lt;/h3&gt;

&lt;p&gt;在 RHEL 8 及其衍生系统中，默认安装的 kernel-install 脚本里有两个脚本会负责 GRUB 菜单的生成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;/usr/lib/kernel/install.d/20-grub.install&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;这个文件来自包 grub2-common-2.02-106.el8.0.2.noarch。&lt;em&gt;&lt;a href=&quot;https://git.rockylinux.org/staging/rpms/grub2/-/blob/r8/SOURCES/20-grub.install&quot;&gt;https://git.rockylinux.org/staging/rpms/grub2/-/blob/r8/SOURCES/20-grub.install&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;/usr/lib/kernel/install.d/90-loaderentry.install&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;这个文件来自包 systemd-udev-239-51.el8.x86_64。&lt;em&gt;&lt;a href=&quot;https://github.com/systemd/systemd/blob/v239-50/src/kernel-install/90-loaderentry.install&quot;&gt;https://github.com/systemd/systemd/blob/v239-50/src/kernel-install/90-loaderentry.install&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你观察上面所展示的菜单文件的内容，并且对比这两个脚本，那么你就会发现他们是由 &lt;em&gt;20-grub.install&lt;/em&gt; 这个文件生成的。为什么嗯？&lt;/p&gt;

&lt;p&gt;这个是两个脚本的实现问题，首先 &lt;em&gt;20-grub.install&lt;/em&gt; 脚本会被先执行，并且生成了 entries 目录中的文件。等到 &lt;em&gt;90-loaderentry.install&lt;/em&gt; 被执行时，它有一个判断如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ! [[ -d &quot;$BOOT_DIR_ABS&quot; ]]; then
    exit 0
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BOOT_DIR_ABS&lt;/code&gt; 如果不是一个目录，就不会执行。这个变量如何定义呢？它在这里定义：&lt;em&gt;&lt;a href=&quot;https://github.com/systemd/systemd/blob/v239-50/src/kernel-install/kernel-install#L92&quot;&gt;https://github.com/systemd/systemd/blob/v239-50/src/kernel-install/kernel-install#L92&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ! [[ $MACHINE_ID ]]; then
    BOOT_DIR_ABS=$(mktemp -d /tmp/kernel-install.XXXXX) || exit 1
    trap &quot;rm -rf &apos;$BOOT_DIR_ABS&apos;&quot; EXIT INT QUIT PIPE
elif [[ -d /efi/loader/entries ]] || [[ -d /efi/$MACHINE_ID ]]; then
    BOOT_DIR_ABS=&quot;/efi/$MACHINE_ID/$KERNEL_VERSION&quot;
elif [[ -d /boot/loader/entries ]] || [[ -d /boot/$MACHINE_ID ]]; then
    BOOT_DIR_ABS=&quot;/boot/$MACHINE_ID/$KERNEL_VERSION&quot;                           # ------------- This line
elif [[ -d /boot/efi/loader/entries ]] || [[ -d /boot/efi/$MACHINE_ID ]]; then
    BOOT_DIR_ABS=&quot;/boot/efi/$MACHINE_ID/$KERNEL_VERSION&quot;
elif mountpoint -q /efi; then
    BOOT_DIR_ABS=&quot;/efi/$MACHINE_ID/$KERNEL_VERSION&quot;
elif mountpoint -q /boot/efi; then
    BOOT_DIR_ABS=&quot;/boot/efi/$MACHINE_ID/$KERNEL_VERSION&quot;
else
    BOOT_DIR_ABS=&quot;/boot/$MACHINE_ID/$KERNEL_VERSION&quot;
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/boot/$MACHINE_ID/$KERNEL_VERSION&lt;/code&gt; 这个形式，是 BLS 规范定义的新的形式，即每个系统的启动项都放在自己的独立目录中。因为现在 RHEL 8 及其衍生版本还未用到这个规范，所以他们的 GRUB 菜单项就不是用 &lt;em&gt;90-loaderentry.install&lt;/em&gt; 这个脚本生成的。&lt;/p&gt;

&lt;h3 id=&quot;菜单文件&quot;&gt;菜单文件&lt;/h3&gt;

&lt;p&gt;一个菜单文件的规范涉及两个部分：文件名和内容。&lt;/p&gt;

&lt;p&gt;一般来说，文件名类似：&lt;em&gt;a0284538aa5b498cb38b8e530b2a6be4-4.18.0-348.el8.0.2.x86_64.conf&lt;/em&gt;。这个文件名主要的限制是必须跨系统唯一，所以一般使用如下格式: &lt;strong&gt;{machine_id}-{kernel_version}.conf&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文件的内容可能如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;title Rocky Linux (4.18.0-348.el8.0.2.x86_64) 8.5 (Green Obsidian)
version 4.18.0-348.el8.0.2.x86_64
linux /vmlinuz-4.18.0-348.el8.0.2.x86_64
initrd /initramfs-4.18.0-348.el8.0.2.x86_64.img $tuned_initrd
options $kernelopts $tuned_params
id rocky-20211114010422-4.18.0-348.el8.0.2.x86_64
grub_users $grub_users
grub_arg --unrestricted
grub_class kernel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每行第一个空格之前的就是 key，后面则是 value。其中，title 就是展示在菜单上的内容。这个 title 就是纯文本，所以你可以随意修改。&lt;/p&gt;

&lt;p&gt;从 &lt;em&gt;20-grub.install&lt;/em&gt; 文件可以看出，这里的 title 的内容会使用到来自 &lt;em&gt;/etc/os-release&lt;/em&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NAME&lt;/code&gt; 变量和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VERSION&lt;/code&gt; 变量。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cat /etc/os-release
NAME=&quot;Rocky Linux&quot;
VERSION=&quot;8.5 (Green Obsidian)&quot;
ID=&quot;rocky&quot;
ID_LIKE=&quot;rhel centos fedora&quot;
VERSION_ID=&quot;8.5&quot;
PLATFORM_ID=&quot;platform:el8&quot;
PRETTY_NAME=&quot;Rocky Linux 8.5 (Green Obsidian)&quot;
ANSI_COLOR=&quot;0;32&quot;
CPE_NAME=&quot;cpe:/o:rocky:rocky:8.5:GA&quot;
HOME_URL=&quot;https://rockylinux.org/&quot;
BUG_REPORT_URL=&quot;https://bugs.rockylinux.org/&quot;
ROCKY_SUPPORT_PRODUCT=&quot;Rocky Linux&quot;
ROCKY_SUPPORT_PRODUCT_VERSION=&quot;8&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grub_&lt;/code&gt; 开头的 key，是 GRUB 平台实现的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On grub platforms, the following grub-specific keywords have been implemented:
    &lt;ul&gt;
      &lt;li&gt;the BLS filename is also used for menuentry’s –id parameter, so you can use it in saved_entry&lt;/li&gt;
      &lt;li&gt;grub_hotkey - same as grub’s “–hotkey” menuentry parameter&lt;/li&gt;
      &lt;li&gt;grub_users - same as grub’s “–users” menuentry parameter; used for password protection&lt;/li&gt;
      &lt;li&gt;grub_class - same as grub’s “–class” menuentry paramter&lt;/li&gt;
      &lt;li&gt;grub_arg - passes extra arguments to menuentry&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些是兼容原来 GRUB 的参数：&lt;em&gt;&lt;a href=&quot;https://www.gnu.org/software/grub/manual/grub/grub.html#menuentry&quot;&gt;https://www.gnu.org/software/grub/manual/grub/grub.html#menuentry&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;默认启动项&quot;&gt;默认启动项&lt;/h3&gt;

&lt;p&gt;你可以使用 &lt;strong&gt;grub2-set-default&lt;/strong&gt; 命令修改默认的启动项。&lt;/p&gt;

&lt;p&gt;此外，我们还可以在安装了一个新的 kernel 之后，让 kernel-install 自动将这个新的 kernel 设置为默认 kernel。这个行为的配置，是在文件 &lt;em&gt;/etc/sysconfig/kernel&lt;/em&gt; 文件中控制的：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cat /etc/sysconfig/kernel
# UPDATEDEFAULT specifies if kernel-install should make
# new kernels the default
UPDATEDEFAULT=yes

# DEFAULTKERNEL specifies the default kernel package type
DEFAULTKERNEL=kernel-core
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个注释已经解释得很清楚了。这部分逻辑的实现，也是在 &lt;em&gt;20-grub.install&lt;/em&gt; 中实现的，调用的是 &lt;strong&gt;grub2-editenv&lt;/strong&gt; 命令：&lt;em&gt;&lt;a href=&quot;https://git.rockylinux.org/staging/rpms/grub2/-/blob/r8/SOURCES/20-grub.install#L134&quot;&gt;https://git.rockylinux.org/staging/rpms/grub2/-/blob/r8/SOURCES/20-grub.install#L134&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;顺便说一下，如果你安装的 kernel 采用了另外一个名字来打包，比如 elrepo  的 kernel-lt，那么修改 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DEFAULTKERNEL&lt;/code&gt; 这行即可。&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://fedoraproject.org/wiki/Changes/BootLoaderSpecByDefault&quot;&gt;https://fedoraproject.org/wiki/Changes/BootLoaderSpecByDefault&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://systemd.io/BOOT_LOADER_SPECIFICATION/&quot;&gt;https://systemd.io/BOOT_LOADER_SPECIFICATION/&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 23 May 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/05/23/GRUB2-menu-and-kernel-install/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/05/23/GRUB2-menu-and-kernel-install/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>ISO9660 标准和 genisoimage 命令</title>
        <description>&lt;p&gt;当我们要定制一个 RHEL 及其衍生版的操作系统镜像时，我们会使用 &lt;strong&gt;genisoimage&lt;/strong&gt; 命令来生成最终的 ISO 文件。&lt;/p&gt;

&lt;p&gt;例如，我们基于 Rocky Linux 8.5 版本，定制了一个镜像后，最终我们会执行如下这条命令：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd rocky-linux-8-5-x86_64-dvd/
$ genisoimage -v -U -r -T -J -joliet-long \
  -V Rocky-8-5-x86_64-dvd -volset Rocky-8-5-x86_64-dvd -A Rocky-8-5-x86_64-dvd \
  -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table \
  -eltorito-alt-boot -e images/efiboot.img -no-emul-boot \
  -o ../NEWISO.iso
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这条命令参数很多，我们需要先了解和光盘有关的相关标准才能看懂这个命令。&lt;/p&gt;

&lt;h2 id=&quot;iso9660-及相关标准&quot;&gt;ISO9660 及相关标准&lt;/h2&gt;

&lt;p&gt;ISO9660 就是光盘文件系统的标准，意思就是如何在光盘上存储文件。更多信息可以查看 wiki 链接：&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;随着计算机行业的发展，原来的标准不太适用于新的需求，比如文件名字更长，目录层级更多等。所以业界也一直在扩充 ISO9660 的相关标准。这里我们说三个目前最常用的。&lt;/p&gt;

&lt;h3 id=&quot;rock-ridge&quot;&gt;Rock Ridge&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660#Rock_Ridge&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660#Rock_Ridge&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rock Ridge Interaction Protocol (RRIP)&lt;/strong&gt; 为光盘文件系统增加了 POSIX 文件系统语意。支持这个标准后，操作系统可以更好的跟光盘文件系统进行交互，比如支持更长的文件名，文件 mode, uid 等。&lt;/p&gt;

&lt;p&gt;这个标准的名字是一部电影里的虚构城镇的名字。电影的中文名字是：神枪小子。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fictional town Rock Ridge in Mel Brooks&apos; film Blazing Saddles.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;el-torito&quot;&gt;El Torito&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660#El_Torito&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660#El_Torito&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El Torito 是一个让 PC 可以从 CD-ROM 启动的标准。最初由 IBM 和 Phoenix Technologies （卖 BIOS 的厂商）制定，随后被所有 BIOS 支持。支持这个标准后，BIOS 除了可以加载硬盘上的启动代码，也可以加载光盘上的启动代码。&lt;/p&gt;

&lt;p&gt;据说这个名字是加州一家墨西哥餐馆的名字，这个标准是在这个餐馆里想出来的。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;El Torito restaurant in Irvine, California (33.684722°N 117.852547°W)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;joliet&quot;&gt;Joliet&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660#Joliet&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660#Joliet&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这里由微软提出的标准。原来的标准对于光盘上的文件名字限制太死，比如长度、格式、不支持 Unicode 等，所以用这个标准扩展了一下，方便存放名字更复杂的文件。&lt;/p&gt;

&lt;h3 id=&quot;三个扩展标准的小结&quot;&gt;三个扩展标准的小结&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Standard&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Rock Ridge&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;让光盘文件系统更接近 POSIX 文件系统，操作系统可以更方便的访问。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;El Torito&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;让计算机可以从光盘启动。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Joliet&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;让光盘的文件名可以更复杂，符合现在的计算机系统中的文件名。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;genisoimage-命令的参数&quot;&gt;genisoimage 命令的参数&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ genisoimage -v -U -r -T -J -joliet-long \
  -V Rocky-8-5-x86_64-dvd -volset Rocky-8-5-x86_64-dvd -A Rocky-8-5-x86_64-dvd \
  -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table \
  -eltorito-alt-boot -e images/efiboot.img -no-emul-boot \
  -o ../NEWISO.iso
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这个命令的参数看起来很多，但是可以分组来看。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-v&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-o&lt;/code&gt; 参数比较简单，就不展开说了。&lt;/p&gt;

&lt;h3 id=&quot;和光盘的名字相关的&quot;&gt;和光盘的名字相关的&lt;/h3&gt;

&lt;p&gt;这些参数就是让光盘在系统上有一个友好的展示名字。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-A&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-appid&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;会被写入 volume header 的一个字符串，表示这个光盘中装载的应用程序，最多 128 字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-V&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;将 volume id 写入 master block，长度限制是 32 个字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-volset&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;设置 volume set id，长度限制是 128 字符。Volume set 相当于是一套光盘的意思，所以后续还可以设置当前光盘是一套光盘里的第几张光盘。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;joliet-标准相关&quot;&gt;Joliet 标准相关&lt;/h3&gt;

&lt;p&gt;这些参数用来控制光盘上的文件的文件名的限制，配置这些选项的目的就是尽量不限制文件名。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-J&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;生成 Joliet 目录记录。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-joliet-long&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;允许 Joliet 文件名的最大长度达到 103 个字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-r&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-rational-rock&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;类似 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-R&lt;/code&gt;，生成 SUSP 和 RR 记录，但是 file ownership 会被设置为更有用的值，减少使用 ISO 的人需要处理的文件权限的问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-T&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-translation-table&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;在光盘的每个目录下都生成一个 &lt;em&gt;TRANS.TBL&lt;/em&gt; 的文件，用于帮助在不兼容 RR 标准的系统上使用正确的文件名来访问文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-U&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-untranslated-filenames&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;允许非转换的文件名，这会导致完全不兼容 ISO9660 标准。相当于开启了以下选项：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-d -l -N -allow-leading-dots -relaxed-filenames -allow-lowercase -allow-multidot -no-iso-translate&lt;/code&gt;，就是减少对文件名的限制。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;el-torito-标准相关&quot;&gt;El Torito 标准相关&lt;/h3&gt;

&lt;p&gt;这些参数是用来控制光盘作为启动盘是如何工作的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-b&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-eltorito-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定 El Torito 启动盘使用的启动文件。对于 legacy BIOS，这个就是 &lt;em&gt;isolinux.bin&lt;/em&gt; 文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eltorito-alt-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;开始一组新的 El Torito 启动参数的配置。一般一组用于 isolinux，一组用于 UEFI。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;以下几个参数是和 legacy BIOS 启动方式相关的&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-c&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-eltorito-catalog&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定 El Torito 的 boot catalog 文件的位置。启动需要这个文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-no-emul-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;用于 El Torito 的启动文件是一个非模拟镜像。系统会加载并且直接执行，而不会像使用一个硬盘一样，先通过分区表来查找启动分区。现在计算机都支持这种方式，通过这种方式，就不需要在一个启动文件里模拟硬盘的数据保存格式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-boot-load-size&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定在非模拟的情况下，load 的 virtual sector (512B) 数量。这里一般要求是 4 的倍数，否则在有些系统上无法工作。这个意思是启动的时候，在启动阶段，通过读取启动文件的这么多数据，就可以把控制权转给启动文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-boot-info-table&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定需要在 boot file offset 8 的位置插入一个 56 字节长的内容，这个插入的内容和光盘的 layout 信息有关，如下面所示。主要目的是为了在启动的过程中，找到 boot 文件的位置。&lt;/li&gt;
      &lt;li&gt;LBA：linear block address (given in CD sectors, normally 2048 bytes)。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;         Offset    Name           Size      Meaning
          8        bi_pvd         4 bytes   LBA of primary volume descriptor
         12        bi_file        4 bytes   LBA of boot file
         16        bi_length      4 bytes   Boot file length in bytes
         20        bi_csum        4 bytes   32-bit checksum
         24        bi_reserved    40 bytes  Reserved
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;以下几个参数是和 UEFI 启动方式相关的&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-e&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-efi-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;EFI 启动文件的位置。UEFI 启动文件也需要指定 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-no-emul-boot&lt;/code&gt; 参数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;implantisomd5-命令&quot;&gt;implantisomd5 命令&lt;/h2&gt;

&lt;p&gt;将 ISO 的 md5sum 写入一个没有的 sector，以便随后使用 checkisomd5 命令进行校验。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ implantisomd5 Rocky-Linux-8.5-x86_64-dvd.iso
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;em&gt;checkisomd5&lt;/em&gt; 命令进行校验：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ checkisomd5 --verbose Rocky-Linux-8.5-x86_64-dvd.iso
Rocky-Linux-8.5-x86_64-dvd.iso:   e9ebe80ba90b67c1a4e3ccfd971bd86a
Fragment sums: 6ec3c854976341d15f5425ae13b7e16f5a7df75942a553adb6f29ba6798c
Fragment count: 20
Supported ISO: no
Press [Esc] to abort check.
Checking: 093.3%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 19 May 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/05/19/iso9660-and-genisoimage-command/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/05/19/iso9660-and-genisoimage-command/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>Linux Bridge VLAN Filter Command Explain</title>
        <description>&lt;p&gt;Linux bridge VLAN filter 功能使得 bridge 像一个真正的交换机一样来提供 VLAN 服务。本文解释 Linux &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bridge vlan&lt;/code&gt; 相关的一些命令。&lt;/p&gt;

&lt;h2 id=&quot;bridge-vlan-add&quot;&gt;bridge vlan add&lt;/h2&gt;

&lt;h3 id=&quot;access-port&quot;&gt;Access Port&lt;/h3&gt;

&lt;p&gt;如下图所示，我们要将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tap0&lt;/code&gt; 加入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;br0&lt;/code&gt;，然后要让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tap0&lt;/code&gt; 像一个 access port 一样工作。&lt;/p&gt;

&lt;p&gt;首先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip link set dev tap0 master br0&lt;/code&gt;。然后执行下图所示的命令，下图还说明了命令的每个部分分别表示什么含义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00037_linux_vlan_filter_1.png&quot; alt=&quot;linux_vlan_filter_add_command_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图所描述的行为，就是交换机上一个 access port 的行为。&lt;/p&gt;

&lt;h3 id=&quot;trunk-port&quot;&gt;Trunk Port&lt;/h3&gt;

&lt;p&gt;如下图所示，我们要将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bond0&lt;/code&gt; 加入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;br0&lt;/code&gt;，然后要让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bond0&lt;/code&gt; 像一个 trunk port 一样工作。&lt;/p&gt;

&lt;p&gt;首先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip link set dev bond0 master br0&lt;/code&gt;。然后执行下图所示的命令，下图还说明了命令的每个部分分别表示什么含义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00038_linux_vlan_filter_2.png&quot; alt=&quot;linux_vlan_filter_add_command_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图所描述的行为，就是交换机上一个 trunk port 的行为。&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Apr 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/04/18/linux-vlan-filter-explain/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/04/18/linux-vlan-filter-explain/</guid>
        
        <category>linux</category>
        
        <category>network</category>
        
        
      </item>
    
      <item>
        <title>Dell XPS 9500 电源适配器无法识别的问题</title>
        <description>&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;我的 XPS 9500 是 2020 年买的，目前安装的是 Ubuntu 21.10 系统，最近出现了一次电源适配器无法识别的问题。现象是这样的：&lt;strong&gt;前一天正常待机，第二天恢复后，无法识别电源适配器，只能一直消耗电池的电量，直到耗尽关机&lt;/strong&gt;。之前，我的电脑也出现过在休眠时，直接掉电关机的情况，就像电源和电池同时拔掉的情况。看起来，应该是电脑本身的电源模块的问题。通过致电 Dell 技术支持，他们告知我这个是个系统电源管理模块的 bug，Dell 提供的故障描述如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;问题描述：xps 9500 type c充电器无法识别充电，dpm电池设置其他方式和关闭高级充电依旧，交换电脑三个type c口都无法识别充电，进入bios下也是一样无法识别电源适配器，没有其他的ac交换，一开始以为是ac 问题 ，后续客户自己重新到dpm检查开启的设置，发现dpm的峰值偏移功能开启影响了ac和电池的充电计划。&lt;/p&gt;

  &lt;p&gt;解决方法：后续遇到无法识别ac充电的情况，建议可以先到打开dell power manager，点击峰值偏移，关闭这个功能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;问题是由&lt;strong&gt;峰值偏移&lt;/strong&gt;这个功能引起的，解决办法有两个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Windows 系统可以使用 Power Manager 这个程序，关闭峰值偏移功能。&lt;/li&gt;
  &lt;li&gt;更新 BIOS。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我的故障和 Dell 提供的描述有一个地方不太一样，就是我的电池充电模式被我修改成了 &lt;strong&gt;Primarily AC Use&lt;/strong&gt;。在出现了无法识别电源适配器的问题后，我又改回了 &lt;strong&gt;Adaptive&lt;/strong&gt;，然后发现在 BIOS 中，电池可以开始充电了。此外，我记得我没有开启过峰值偏移功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00036_dell_xps9500_bios_power.jpg&quot; alt=&quot;dell_xps_9500_bios_power&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;dell-command-configure&quot;&gt;Dell Command Configure&lt;/h2&gt;

&lt;p&gt;因为我不是 Windows 系统，所以无法使用 Power Manager 这个程序。而且，我也不想升级 BIOS。国内的技术支持并不知道在 Ubuntu 系统下如何解决这个问题。经过搜索，我发现，Dell 自己是有个命令行程序支持在 Linux 下修改这些 BIOS 设置的，这个程序就是 &lt;strong&gt;Dell Command Configure&lt;/strong&gt;，下载路径如下： &lt;em&gt;&lt;a href=&quot;https://www.dell.com/support/kbdoc/zh-cn/000178000/dell-command-configure&quot;&gt;https://www.dell.com/support/kbdoc/zh-cn/000178000/dell-command-configure&lt;/a&gt;&lt;/em&gt;。Ubuntu 版本包含两个 dep 包，先安装 &lt;em&gt;srvadmin-hapi&lt;/em&gt;，再安装 &lt;em&gt;command-configure&lt;/em&gt;：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-r--r-- 1 diabloneo diabloneo 1696256 Sep 15 20:41 command-configure_4.6.0-277.ubuntu20_amd64.deb
-rw-r--r-- 1 diabloneo diabloneo  297940 Sep 15 20:41 srvadmin-hapi_9.5.0_amd64.deb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个命令的使用手册可以从这里下载： &lt;em&gt;&lt;a href=&quot;https://dl.dell.com/topicspdf/command-configure_users-guide4_en-us.pdf&quot;&gt;https://dl.dell.com/topicspdf/command-configure_users-guide4_en-us.pdf&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;使用这个命令关闭峰值偏移功能：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd /opt/dell/dcc
$ sudo ./cctk --PeakShiftCfg=Disabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不过，虽然我关闭了这个功能，但是并不知道这个问题是否还会再出现。&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Feb 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/02/10/Dell-XPS-9500-AC-power-adapter-not-regonized/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/02/10/Dell-XPS-9500-AC-power-adapter-not-regonized/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>jemalloc 3.6 版本导致的性能问题</title>
        <description>&lt;p&gt;最近我们有一个服务在测试过程中发现了性能问题，最终定位到是因为 jemalloc 使用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MADV_DONTNEED&lt;/code&gt; 导致的，这里分享一下定位过程。&lt;/p&gt;

&lt;h2 id=&quot;测试环境和问题描述&quot;&gt;测试环境和问题描述&lt;/h2&gt;

&lt;p&gt;测试程序通过网络接受 RPC 请求后，执行处理逻辑，程序运行环境如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CentOS 7.6 + kernel 3.10&lt;/li&gt;
  &lt;li&gt;程序运行在 docker 容器内&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Benchmark 过程很简单，就是通过客户端程序发起请求，然后看看测试过程能达到的服务带宽有多少。在获得结果后，我们发现，使用 jemalloc 的版本性能下降了差不多 20%（不过我们一开始并不知道是 jemalloc 导致的）。&lt;/p&gt;

&lt;h2 id=&quot;定位过程&quot;&gt;定位过程&lt;/h2&gt;

&lt;h3 id=&quot;获取-profile-数据生成火焰图&quot;&gt;获取 profile 数据，生成火焰图&lt;/h3&gt;

&lt;p&gt;这里使用 bcc 的 profile 工具来生成 profile stack 文件，然后使用 Brendan Gregg 的 FlameGraph 工具将其转换成火焰图 (&lt;em&gt;&lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot;&gt;https://github.com/brendangregg/FlameGraph&lt;/a&gt;&lt;/em&gt;)。&lt;/p&gt;

&lt;p&gt;Profile 命令如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# /usr/share/bcc/tools/profile -F 99 -f -a -p $PID 30 &amp;gt; profile.stack
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;FlameGraph 命令如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./flamegraph.pl profile.stack &amp;gt; profile.svg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;得到的火焰图中的关键部分如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00035_flame_graph_recvmsg_madvise.png&quot; alt=&quot;flame_graph_recvmsg_madvise&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图中可以看出两个奇怪的地方：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;有很多 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 调用。&lt;/li&gt;
  &lt;li&gt;收包的时候经常伴随着内存申请操作 (page_fault 的处理)。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;minor-page-fault-有多少&quot;&gt;minor page fault 有多少&lt;/h3&gt;

&lt;p&gt;因为从火焰图中看到了很多 page fault，所以可以通过其他工具来看一下 page fault 的类型和产生速率。因为我们的系统上是关闭了 swap 的，所以肯定都是 minor page fault，这里主要是要查看一下速率。可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sar&lt;/code&gt; 命令来查看：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sar -B 1
Linux 3.10.0-957.el7.x86_64 (node)   01/16/2022      _x86_64_        (40 CPU)

11:49:13 AM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff
11:49:14 AM      0.00    100.00 608239.00      0.00 869641.00      0.00      0.00      0.00      0.00
11:49:15 AM      0.00   3692.00 737822.00      0.00 971933.00      0.00      0.00      0.00      0.00
11:49:16 AM      0.00    104.00 466154.00      0.00 781245.00      0.00      0.00      0.00      0.00
11:49:17 AM      0.00    124.00 460824.00      0.00 769351.00      0.00      0.00      0.00      0.00
11:49:18 AM      0.00    136.00 510035.00      0.00 806849.00      0.00      0.00      0.00      0.00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以发现，每秒钟产生了 50w 次以上的 minor page fault。&lt;/p&gt;

&lt;h3 id=&quot;查看-socket-rmem-的使用情况&quot;&gt;查看 socket rmem 的使用情况&lt;/h3&gt;

&lt;p&gt;此外，因为是在收包的过程中发生了内存申请操作，我们还可以使用 sormem.bt 这个 bpftrace 程序 (&lt;em&gt;&lt;a href=&quot;https://github.com/brendangregg/bpf-perf-tools-book/blob/master/originals/Ch10_Networking/sormem.bt&quot;&gt;https://github.com/brendangregg/bpf-perf-tools-book/blob/master/originals/Ch10_Networking/sormem.bt&lt;/a&gt;&lt;/em&gt;) 来进行查看一下进程的 socket recv buffer 的情况：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./sormem.bt
Attaching 4 probes...
Tracing socket receive buffer size. Hit Ctrl-C to end.
^C

@rmem_alloc:
[0]                15638 |@                                                   |
[1]                    0 |                                                    |
[2, 4)                 0 |                                                    |
[4, 8)                 0 |                                                    |
[8, 16)                0 |                                                    |
[16, 32)               0 |                                                    |
[32, 64)               0 |                                                    |
[64, 128)              0 |                                                    |
[128, 256)             0 |                                                    |
[256, 512)             0 |                                                    |
[512, 1K)            699 |                                                    |
[1K, 2K)            1136 |                                                    |
[2K, 4K)          433243 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[4K, 8K)            7037 |                                                    |
[8K, 16K)           3750 |                                                    |
[16K, 32K)           219 |                                                    |
[32K, 64K)            18 |                                                    |
[64K, 128K)          191 |                                                    |
[128K, 256K)         200 |                                                    |
[256K, 512K)         118 |                                                    |
[512K, 1M)            19 |                                                    |
[1M, 2M)               2 |                                                    |
[2M, 4M)          192207 |@@@@@@@@@@@@@@@@@@@@@@@                             |
[4M, 8M)            8551 |@                                                   |

@rmem_limit:
[128K, 256K)        8580 |                                                    |
[256K, 512K)        6030 |                                                    |
[512K, 1M)             0 |                                                    |
[1M, 2M)           33400 |@@                                                  |
[2M, 4M)            7956 |                                                    |
[4M, 8M)          605235 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[8M, 16M)              0 |                                                    |
[16M, 32M)          1187 |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从 &lt;strong&gt;rmem_alloc&lt;/strong&gt; 的数据可以看出，服务端程序在 benchmark 过程中大量使用了小块的内存。不过，这个数据无法直接推导出一些结论，只能说这可能和内存管理的行为有关。&lt;/p&gt;

&lt;h3 id=&quot;查看-madvise-调用情况&quot;&gt;查看 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 调用情况&lt;/h3&gt;

&lt;p&gt;在查看了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 的 man 手册之后，我发现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 的参数选择对于程序的性能影响很大，所以我们需要知道这里执行的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 调用的参数是什么。这里我写了一个 bpftrace 的程序来获取程序调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 时使用的参数：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat trace_madvise.bt
#!/usr/bin/bpftrace

BEGIN
{
        printf(&quot;trace syscall madvise of pid %d\n&quot;, $1);
}

t:syscalls:sys_enter_madvise /pid == $1/
{
        printf(&quot;pid %d, comm %s, arg1 %lx, arg2 %ld, arg3 %ld\n&quot;, pid, comm, args-&amp;gt;start, args-&amp;gt;len_in, args-&amp;gt;behavior);
}

t:syscalls:sys_exit_madvise /pid == $1/
{
        printf(&quot;pid %d, comm %s, retval %d\n&quot;, pid, comm, args-&amp;gt;ret);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 benchmark 的过程中执行这个脚本，得到的结果主要内容如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pid 336963, comm cmdname, arg1 7fcd81dab000, arg2 1048576, arg3 4
pid 336963, comm cmdname, retval 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arg3 4&lt;/code&gt; 表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;advice&lt;/code&gt; 参数，这里 &lt;strong&gt;4&lt;/strong&gt; 对应的是 &lt;strong&gt;MADV_DONTNEED&lt;/strong&gt;。另外，我还统计了一下 benchmark 过程中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 调用的数量，达到了 22w 次。&lt;/p&gt;

&lt;h3 id=&quot;madv_dontneed-这个坑&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MADV_DONTNEED&lt;/code&gt; 这个坑&lt;/h3&gt;

&lt;p&gt;这个参数的行为很诡异，会直接导致 Linux 立刻回收内存，然后再次访问这块内存，会触发一个内存分配操作，它的行为基本上等于 free 了。man 手册中的关键内容如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;After a successful MADV_DONTNEED operation, the semantics of memory access in the specified region are changed: subsequent accesses of pages in the range will succeed, but will result in either repopulating the memory contents from the up-to-date contents of the underlying mapped file (for shared file mappings, shared anonymous mappings, and shmem-based techniques such as  System V shared memory segments) or zero-fill-on-demand pages for anonymous private mappings.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我去搜下了下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://youjiali1995.github.io/allocator/jemalloc-purge/&quot;&gt;jemalloc purge改进&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/6844904084957315086&quot;&gt;深入理解 Linux 内核–jemalloc 引起的 TLB shootdown 及优化&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;这里要提一下，我们的这个问题并没有 TLB shotdown。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/jemalloc/jemalloc/issues/1422&quot;&gt;madivse MADV_DONTNEED causes bad performence in KVM virtual machine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这个视频我更是强烈推荐，吐嘈之余，让你也能理解这个参数的历史： &lt;em&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=bg6-LVCHmGM&amp;amp;t=3518s&quot;&gt;https://www.youtube.com/watch?v=bg6-LVCHmGM&amp;amp;t=3518s&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;问题总结&quot;&gt;问题总结&lt;/h3&gt;

&lt;p&gt;了解了程序的行为以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 这个坑之后，我们就可以得到这个性能问题的结论了： &lt;strong&gt;由于程序使用的 jemalloc 3.6 版本在运行过程中，大量调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise(MADV_DONTNEED)&lt;/code&gt;，导致内存不断被 kernel 回收。因此，在收包的过程中只好又去申请新的内存，导致收包的性能下降&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;关闭-jemalloc-内存回收进行问题确认&quot;&gt;关闭 jemalloc 内存回收进行问题确认&lt;/h3&gt;

&lt;p&gt;可以通过如下的环境变量关闭 jemalloc 的内存回收机制，&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export MALLOC_CONF=&quot;lg_dirty_mult:-1&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个参数在 jemalloc 的如下代码路径上发挥作用：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 在 src/arena.c 中找到如下函数
static inline void
arena_maybe_purge(arena_t *arena)
{
        size_t npurgeable, threshold;

        /* Don&apos;t purge if the option is disabled. */
        if (opt_lg_dirty_mult &amp;lt; 0)
                return;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关闭内存回收之后，我们的程序就不再出现上述的性能问题。&lt;/p&gt;

&lt;h2 id=&quot;kernel-418-的对比测试&quot;&gt;Kernel 4.18 的对比测试&lt;/h2&gt;

&lt;p&gt;随后，我在 &lt;strong&gt;CentOS 7.6 + kernel 4.18&lt;/strong&gt;  的环境上也进行了 benchmark，发现在 kernel 4.18 上，程序的性能下降比较少，大概是 10%。随后写了一个 &lt;em&gt;trace_tcp_recvmsg_time.bt&lt;/em&gt; 的 bpttrace 程序，对比了一下两个版本的 kernel 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tcp_recvmsg&lt;/code&gt; 函数上的性能差异。&lt;/p&gt;

&lt;p&gt;程序如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@node tools]# cat calc_tcp_recvmsg_time.bt
#!/usr/bin/bpftrace

BEGIN
{
        printf(&quot;Calc tcp_recvmsg time of pid %d\n&quot;, $1);
}

kprobe:tcp_recvmsg /pid == $1/
{
        @start[tid] = nsecs;
}

kretprobe:tcp_recvmsg /pid == $1/
{
        if (@start[tid]) {
                @pf_nsecs = hist((nsecs - @start[tid]) / 1000);
                delete(@start[tid]);
        }
}

END
{
        print(@pf_nsecs);
        clear(@start);
        clear(@pf_nsecs);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Kernel 3.10 的结果&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Attaching 4 probes...
Calc tcp_recvmsg time of pid 366959
^C@pf_nsecs:
[1]                  327 |                                                    |
[2, 4)             53761 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      |
[4, 8)              7840 |@@@@                                                |
[8, 16)            39434 |@@@@@@@@@@@@@@@@@@@@@@                              |
[16, 32)            1685 |                                                    |
[32, 64)             223 |                                                    |
[64, 128)            229 |                                                    |
[128, 256)           126 |                                                    |
[256, 512)             9 |                                                    |
[512, 1K)          10484 |@@@@@                                               |
[1K, 2K)           92465 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[2K, 4K)               9 |                                                    |
[4K, 8K)               0 |                                                    |
[8K, 16K)              0 |                                                    |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Kernel 4.18 的结果&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Attaching 4 probes...
Calc tcp_recvmsg time of pid 20607
^C@pf_nsecs:
[0]                   23 |                                                    |
[1]                  274 |                                                    |
[2, 4)             32551 |@@@@@@@@@@@@@@@@                                    |
[4, 8)             52765 |@@@@@@@@@@@@@@@@@@@@@@@@@@                          |
[8, 16)            35111 |@@@@@@@@@@@@@@@@@                                   |
[16, 32)            1375 |                                                    |
[32, 64)             116 |                                                    |
[64, 128)             41 |                                                    |
[128, 256)            15 |                                                    |
[256, 512)            27 |                                                    |
[512, 1K)         103847 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[1K, 2K)           17881 |@@@@@@@@                                            |
[2K, 4K)               2 |                                                    |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;得到的结论是，kernel 4.18 在这个路径上的性能确实比 kernel 3.10 更好。不过，因为不能对 kernel 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_page_fault&lt;/code&gt; 函数进行 kprobe，所以不确定这里的性能改进是哪部分贡献的。&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Jan 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/01/20/Performance-problem-caused-by-jemalloc-3.6/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/01/20/Performance-problem-caused-by-jemalloc-3.6/</guid>
        
        <category>linux</category>
        
        <category>kernel</category>
        
        <category>network</category>
        
        
      </item>
    
      <item>
        <title>CentOS 官方是如何编译一个包的</title>
        <description>&lt;p&gt;CentOS 是企业级开发里常用的 base 操作系统，很多时候，我们会先使用官方源里的包，随着业务的发展，我们会开始自己修改代码。这种时候，我们就希望可以编译出和 CentOS 官方一样的包。那么如何找到 CentOS  官方是如何编译包的呢？&lt;/p&gt;

&lt;h2 id=&quot;koji&quot;&gt;Koji&lt;/h2&gt;

&lt;p&gt;Koji 是 Fedora 平台用来编译 RPM 包和镜像的系统，CentOS/Rocky Linux 也都使用这个平台。这个 wiki 介绍了 Koji 的基本信息：&lt;em&gt;&lt;a href=&quot;https://fedoraproject.org/wiki/Koji&quot;&gt;https://fedoraproject.org/wiki/Koji&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;我们可以找到 CentOS Koji 的链接，然后通过 Koji 来找到我们需要的包的信息。&lt;/p&gt;

&lt;h2 id=&quot;如何找到-centos-8-官方编译-libvirt-的方案&quot;&gt;如何找到 CentOS 8 官方编译 libvirt 的方案&lt;/h2&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进入 Koji 的 build 页面：&lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/koji/builds&quot;&gt;https://koji.mbox.centos.org/koji/builds&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;在里面搜索 libvirt，找到 libvirt 有关的任务&lt;/li&gt;
  &lt;li&gt;找一个最新的：&lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/koji/buildinfo?buildID=19878&quot;&gt;https://koji.mbox.centos.org/koji/buildinfo?buildID=19878&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;进去之后，找到 task，然后进入 task：&lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/koji/taskinfo?taskID=310486&quot;&gt;https://koji.mbox.centos.org/koji/taskinfo?taskID=310486&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;因为会编译多个 arch 的包，所以还有子 task，我们可以进入 x86_64 的查看： &lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/koji/taskinfo?taskID=310489&quot;&gt;https://koji.mbox.centos.org/koji/taskinfo?taskID=310489&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;在这里就可以看到 build.log 的链接，点进去查看： &lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/pkgs/work/tasks/489/310489/build.log&quot;&gt;https://koji.mbox.centos.org/pkgs/work/tasks/489/310489/build.log&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在里面搜索 &lt;strong&gt;meson&lt;/strong&gt;，可以找到 meson 的参数，就知道 CentOS 8 官方如何编译 libvirt 库了：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ /usr/bin/meson --buildtype=plain --prefix=/usr --libdir=/usr/lib64 --libexecdir=/usr/libexec --bindir=/usr/bin --sbindir=/usr/sbin --includedir=/usr/include --datadir=/usr/share --mandir=/usr/share/man --infodir=/usr/share/info --localedir=/usr/share/locale --sysconfdir=/etc --localstatedir=/var --sharedstatedir=/var/lib --wrap-mode=nodownload --auto-features=enabled . x86_64-redhat-linux-gnu -Drunstatedir=/run -Ddriver_qemu=enabled -Ddriver_openvz=disabled -Ddriver_lxc=disabled -Ddriver_vbox=disabled -Ddriver_libxl=disabled -Dsasl=enabled -Dpolkit=enabled -Ddriver_libvirtd=enabled -Ddriver_remote=enabled -Ddriver_test=enabled -Ddriver_esx=enabled -Dcurl=enabled -Ddriver_hyperv=disabled -Dopenwsman=disabled -Ddriver_vmware=disabled -Ddriver_vz=disabled -Ddriver_bhyve=disabled -Ddriver_ch=disabled -Dremote_default_mode=legacy -Ddriver_interface=enabled -Ddriver_network=enabled -Dstorage_fs=enabled -Dstorage_lvm=enabled -Dstorage_iscsi=enabled -Dstorage_iscsi_direct=enabled -Dlibiscsi=enabled -Dstorage_scsi=enabled -Dstorage_disk=enabled -Dstorage_mpath=enabled -Dstorage_rbd=enabled -Dstorage_sheepdog=disabled -Dstorage_gluster=enabled -Dglusterfs=enabled -Dstorage_zfs=disabled -Dstorage_vstorage=disabled -Dnumactl=enabled -Dnumad=enabled -Dcapng=enabled -Dfuse=disabled -Dnetcf=enabled -Dselinux=enabled -Dselinux_mount=/sys/fs/selinux -Dapparmor=disabled -Dapparmor_profiles=disabled -Dsecdriver_apparmor=disabled -Dudev=enabled -Dyajl=enabled -Dsanlock=enabled -Dlibpcap=enabled -Dlibnl=enabled -Daudit=enabled -Ddtrace=enabled -Dfirewalld=enabled -Dfirewalld_zone=enabled -Dwireshark_dissector=enabled -Dlibssh=enabled -Dlibssh2=disabled -Dpm_utils=disabled -Dnss=enabled &apos;-Dpackager=CentOS Buildsys &amp;lt;bugs@centos.org&amp;gt;, 2021-11-09-20:38:08, &apos; -Dpackager_version=1.module_el8.6.0+983+a7505f3f -Dqemu_user=qemu -Dqemu_group=qemu -Dtls_priority=@LIBVIRT,SYSTEM -Dwerror=true -Dexpensive_tests=enabled -Dinit_script=systemd -Ddocs=enabled -Dtests=enabled -Drpath=disabled -Dlogin_shell=disabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在里面搜索 &lt;strong&gt;rpmbuild&lt;/strong&gt; 就可以知道它用什么命令打包的了。&lt;/p&gt;

&lt;p&gt;同样的，Fedora 和 Rocky Linux 也可以用这个方法找到他们的打包细节。&lt;/p&gt;
</description>
        <pubDate>Tue, 07 Dec 2021 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2021/12/07/How-CentOS-build-rpm-packages/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2021/12/07/How-CentOS-build-rpm-packages/</guid>
        
        <category>linux</category>
        
        
      </item>
    
  </channel>
</rss>
