<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coffee, Coke and Code</title>
    <description>Archive diabloneo's articles.
</description>
    <link>http://diabloneo.github.io//</link>
    <atom:link href="http://diabloneo.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 19 May 2022 14:26:25 +0800</pubDate>
    <lastBuildDate>Thu, 19 May 2022 14:26:25 +0800</lastBuildDate>
    <generator>Jekyll v3.9.0</generator>
    
      <item>
        <title>ISO9660 标准和 genisoimage 命令</title>
        <description>&lt;p&gt;当我们要定制一个 RHEL 及其衍生版的操作系统镜像时，我们会使用 &lt;strong&gt;genisoimage&lt;/strong&gt; 命令来生成最终的 ISO 文件。&lt;/p&gt;

&lt;p&gt;例如，我们基于 Rocky Linux 8.5 版本，定制了一个镜像后，最终我们会执行如下这条命令：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd rocky-linux-8-5-x86_64-dvd/
$ genisoimage -v -U -r -T -J -joliet-long \
  -V Rocky-8-5-x86_64-dvd -volset Rocky-8-5-x86_64-dvd -A Rocky-8-5-x86_64-dvd \
  -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table \
  -eltorito-alt-boot -e images/efiboot.img -no-emul-boot \
  -o ../NEWISO.iso
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这条命令参数很多，我们需要先了解和光盘有关的相关标准才能看懂这个命令。&lt;/p&gt;

&lt;h2 id=&quot;iso9660-及相关标准&quot;&gt;ISO9660 及相关标准&lt;/h2&gt;

&lt;p&gt;ISO9660 就是光盘文件系统的标准，意思就是如何在光盘上存储文件。更多信息可以查看 wiki 链接：&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;随着计算机行业的发展，原来的标准不太适用于新的需求，比如文件名字更长，目录层级更多等。所以业界也一直在扩充 ISO9660 的相关标准。这里我们说三个目前最常用的。&lt;/p&gt;

&lt;h3 id=&quot;rock-ridge&quot;&gt;Rock Ridge&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660#Rock_Ridge&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660#Rock_Ridge&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rock Ridge Interaction Protocol (RRIP)&lt;/strong&gt; 为光盘文件系统增加了 POSIX 文件系统语意。支持这个标准后，操作系统可以更好的跟光盘文件系统进行交互，比如支持更长的文件名，文件 mode, uid 等。&lt;/p&gt;

&lt;p&gt;这个标准的名字是一部电影里的虚构城镇的名字。电影的中文名字是：神枪小子。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fictional town Rock Ridge in Mel Brooks' film Blazing Saddles.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;el-torito&quot;&gt;El Torito&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660#El_Torito&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660#El_Torito&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El Torito 是一个让 PC 可以从 CD-ROM 启动的标准。最初由 IBM 和 Phoenix Technologies （卖 BIOS 的厂商）制定，随后被所有 BIOS 支持。支持这个标准后，BIOS 除了可以加载硬盘上的启动代码，也可以加载光盘上的启动代码。&lt;/p&gt;

&lt;p&gt;据说这个名字是加州一家墨西哥餐馆的名字，这个标准是在这个餐馆里想出来的。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;El Torito restaurant in Irvine, California (33.684722°N 117.852547°W)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;joliet&quot;&gt;Joliet&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660#Joliet&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660#Joliet&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这里由微软提出的标准。原来的标准对于光盘上的文件名字限制太死，比如长度、格式、不支持 Unicode 等，所以用这个标准扩展了一下，方便存放名字更复杂的文件。&lt;/p&gt;

&lt;h3 id=&quot;三个扩展标准的小结&quot;&gt;三个扩展标准的小结&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Standard&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Rock Ridge&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;让光盘文件系统更接近 POSIX 文件系统，操作系统可以更方便的访问。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;El Torito&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;让计算机可以从光盘启动。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Joliet&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;让光盘的文件名可以更复杂，符合现在的计算机系统中的文件名。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;genisoimage-命令的参数&quot;&gt;genisoimage 命令的参数&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ genisoimage -v -U -r -T -J -joliet-long \
  -V Rocky-8-5-x86_64-dvd -volset Rocky-8-5-x86_64-dvd -A Rocky-8-5-x86_64-dvd \
  -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table \
  -eltorito-alt-boot -e images/efiboot.img -no-emul-boot \
  -o ../NEWISO.iso
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这个命令的参数看起来很多，但是可以分组来看。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-v&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-o&lt;/code&gt; 参数比较简单，就不展开说了。&lt;/p&gt;

&lt;h3 id=&quot;和光盘的名字相关的&quot;&gt;和光盘的名字相关的&lt;/h3&gt;

&lt;p&gt;这些参数就是让光盘在系统上有一个友好的展示名字。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-A&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-appid&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;会被写入 volume header 的一个字符串，表示这个光盘中装载的应用程序，最多 128 字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-V&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;将 volume id 写入 master block，长度限制是 32 个字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-volset&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;设置 volume set id，长度限制是 128 字符。Volume set 相当于是一套光盘的意思，所以后续还可以设置当前光盘是一套光盘里的第几张光盘。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;joliet-标准相关&quot;&gt;Joliet 标准相关&lt;/h3&gt;

&lt;p&gt;这些参数用来控制光盘上的文件的文件名的限制，配置这些选项的目的就是尽量不限制文件名。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-J&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;生成 Joliet 目录记录。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-joliet-long&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;允许 Joliet 文件名的最大长度达到 103 个字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-r&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-rational-rock&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;类似 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-R&lt;/code&gt;，生成 SUSP 和 RR 记录，但是 file ownership 会被设置为更有用的值，减少使用 ISO 的人需要处理的文件权限的问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-T&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-translation-table&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;在光盘的每个目录下都生成一个 &lt;em&gt;TRANS.TBL&lt;/em&gt; 的文件，用于帮助在不兼容 RR 标准的系统上使用正确的文件名来访问文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-U&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-untranslated-filenames&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;允许非转换的文件名，这会导致完全不兼容 ISO9660 标准。相当于开启了以下选项：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-d -l -N -allow-leading-dots -relaxed-filenames -allow-lowercase -allow-multidot -no-iso-translate&lt;/code&gt;，就是减少对文件名的限制。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;el-torito-标准相关&quot;&gt;El Torito 标准相关&lt;/h3&gt;

&lt;p&gt;这些参数是用来控制光盘作为启动盘是如何工作的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-b&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-eltorito-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定 El Torito 启动盘使用的启动文件。对于 legacy BIOS，这个就是 &lt;em&gt;isolinux.bin&lt;/em&gt; 文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eltorito-alt-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;开始一组新的 El Torito 启动参数的配置。一般一组用于 isolinux，一组用于 UEFI。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;以下几个参数是和 legacy BIOS 启动方式相关的&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-c&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-eltorito-catalog&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定 El Torito 的 boot catalog 文件的位置。启动需要这个文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-no-emul-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;用于 El Torito 的启动文件是一个非模拟镜像。系统会加载并且直接执行，而不会像使用一个硬盘一样，先通过分区表来查找启动分区。现在计算机都支持这种方式，通过这种方式，就不需要在一个启动文件里模拟硬盘的数据保存格式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-boot-load-size&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定在非模拟的情况下，load 的 virtual sector (512B) 数量。这里一般要求是 4 的倍数，否则在有些系统上无法工作。这个意思是启动的时候，在启动阶段，通过读取启动文件的这么多数据，就可以把控制权转给启动文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-boot-info-table&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定需要在 boot file offset 8 的位置插入一个 56 字节长的内容，这个插入的内容和光盘的 layout 信息有关，如下面所示。主要目的是为了在启动的过程中，找到 boot 文件的位置。&lt;/li&gt;
      &lt;li&gt;LBA：linear block address (given in CD sectors, normally 2048 bytes)。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;         Offset    Name           Size      Meaning
          8        bi_pvd         4 bytes   LBA of primary volume descriptor
         12        bi_file        4 bytes   LBA of boot file
         16        bi_length      4 bytes   Boot file length in bytes
         20        bi_csum        4 bytes   32-bit checksum
         24        bi_reserved    40 bytes  Reserved
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;以下几个参数是和 UEFI 启动方式相关的&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-e&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-efi-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;EFI 启动文件的位置。UEFI 启动文件也需要指定 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-no-emul-boot&lt;/code&gt; 参数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;implantisomd5-命令&quot;&gt;implantisomd5 命令&lt;/h2&gt;

&lt;p&gt;将 ISO 的 md5sum 写入一个没有的 sector，以便随后使用 checkisomd5 命令进行校验。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ implantisomd5 Rocky-Linux-8.5-x86_64-dvd.iso
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;em&gt;checkisomd5&lt;/em&gt; 命令进行校验：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ checkisomd5 --verbose Rocky-Linux-8.5-x86_64-dvd.iso
Rocky-Linux-8.5-x86_64-dvd.iso:   e9ebe80ba90b67c1a4e3ccfd971bd86a
Fragment sums: 6ec3c854976341d15f5425ae13b7e16f5a7df75942a553adb6f29ba6798c
Fragment count: 20
Supported ISO: no
Press [Esc] to abort check.
Checking: 093.3%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 19 May 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/05/19/iso9660-and-genisoimage-command/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/05/19/iso9660-and-genisoimage-command/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>Linux Bridge VLAN Filter Command Explain</title>
        <description>&lt;p&gt;Linux bridge VLAN filter 功能使得 bridge 像一个真正的交换机一样来提供 VLAN 服务。本文解释 Linux &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bridge vlan&lt;/code&gt; 相关的一些命令。&lt;/p&gt;

&lt;h2 id=&quot;bridge-vlan-add&quot;&gt;bridge vlan add&lt;/h2&gt;

&lt;h3 id=&quot;access-port&quot;&gt;Access Port&lt;/h3&gt;

&lt;p&gt;如下图所示，我们要将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tap0&lt;/code&gt; 加入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;br0&lt;/code&gt;，然后要让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tap0&lt;/code&gt; 像一个 access port 一样工作。&lt;/p&gt;

&lt;p&gt;首先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip link set dev tap0 master br0&lt;/code&gt;。然后执行下图所示的命令，下图还说明了命令的每个部分分别表示什么含义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00037_linux_vlan_filter_1.png&quot; alt=&quot;linux_vlan_filter_add_command_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图所描述的行为，就是交换机上一个 access port 的行为。&lt;/p&gt;

&lt;h3 id=&quot;trunk-port&quot;&gt;Trunk Port&lt;/h3&gt;

&lt;p&gt;如下图所示，我们要将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bond0&lt;/code&gt; 加入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;br0&lt;/code&gt;，然后要让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bond0&lt;/code&gt; 像一个 trunk port 一样工作。&lt;/p&gt;

&lt;p&gt;首先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip link set dev bond0 master br0&lt;/code&gt;。然后执行下图所示的命令，下图还说明了命令的每个部分分别表示什么含义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00038_linux_vlan_filter_2.png&quot; alt=&quot;linux_vlan_filter_add_command_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图所描述的行为，就是交换机上一个 trunk port 的行为。&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Apr 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/04/18/linux-vlan-filter-explain/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/04/18/linux-vlan-filter-explain/</guid>
        
        <category>linux</category>
        
        <category>network</category>
        
        
      </item>
    
      <item>
        <title>Dell XPS 9500 电源适配器无法识别的问题</title>
        <description>&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;我的 XPS 9500 是 2020 年买的，目前安装的是 Ubuntu 21.10 系统，最近出现了一次电源适配器无法识别的问题。现象是这样的：&lt;strong&gt;前一天正常待机，第二天恢复后，无法识别电源适配器，只能一直消耗电池的电量，直到耗尽关机&lt;/strong&gt;。之前，我的电脑也出现过在休眠时，直接掉电关机的情况，就像电源和电池同时拔掉的情况。看起来，应该是电脑本身的电源模块的问题。通过致电 Dell 技术支持，他们告知我这个是个系统电源管理模块的 bug，Dell 提供的故障描述如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;问题描述：xps 9500 type c充电器无法识别充电，dpm电池设置其他方式和关闭高级充电依旧，交换电脑三个type c口都无法识别充电，进入bios下也是一样无法识别电源适配器，没有其他的ac交换，一开始以为是ac 问题 ，后续客户自己重新到dpm检查开启的设置，发现dpm的峰值偏移功能开启影响了ac和电池的充电计划。&lt;/p&gt;

  &lt;p&gt;解决方法：后续遇到无法识别ac充电的情况，建议可以先到打开dell power manager，点击峰值偏移，关闭这个功能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;问题是由&lt;strong&gt;峰值偏移&lt;/strong&gt;这个功能引起的，解决办法有两个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Windows 系统可以使用 Power Manager 这个程序，关闭峰值偏移功能。&lt;/li&gt;
  &lt;li&gt;更新 BIOS。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我的故障和 Dell 提供的描述有一个地方不太一样，就是我的电池充电模式被我修改成了 &lt;strong&gt;Primarily AC Use&lt;/strong&gt;。在出现了无法识别电源适配器的问题后，我又改回了 &lt;strong&gt;Adaptive&lt;/strong&gt;，然后发现在 BIOS 中，电池可以开始充电了。此外，我记得我没有开启过峰值偏移功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00036_dell_xps9500_bios_power.jpg&quot; alt=&quot;dell_xps_9500_bios_power&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;dell-command-configure&quot;&gt;Dell Command Configure&lt;/h2&gt;

&lt;p&gt;因为我不是 Windows 系统，所以无法使用 Power Manager 这个程序。而且，我也不想升级 BIOS。国内的技术支持并不知道在 Ubuntu 系统下如何解决这个问题。经过搜索，我发现，Dell 自己是有个命令行程序支持在 Linux 下修改这些 BIOS 设置的，这个程序就是 &lt;strong&gt;Dell Command Configure&lt;/strong&gt;，下载路径如下： &lt;em&gt;&lt;a href=&quot;https://www.dell.com/support/kbdoc/zh-cn/000178000/dell-command-configure&quot;&gt;https://www.dell.com/support/kbdoc/zh-cn/000178000/dell-command-configure&lt;/a&gt;&lt;/em&gt;。Ubuntu 版本包含两个 dep 包，先安装 &lt;em&gt;srvadmin-hapi&lt;/em&gt;，再安装 &lt;em&gt;command-configure&lt;/em&gt;：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-r--r-- 1 diabloneo diabloneo 1696256 Sep 15 20:41 command-configure_4.6.0-277.ubuntu20_amd64.deb
-rw-r--r-- 1 diabloneo diabloneo  297940 Sep 15 20:41 srvadmin-hapi_9.5.0_amd64.deb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个命令的使用手册可以从这里下载： &lt;em&gt;&lt;a href=&quot;https://dl.dell.com/topicspdf/command-configure_users-guide4_en-us.pdf&quot;&gt;https://dl.dell.com/topicspdf/command-configure_users-guide4_en-us.pdf&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;使用这个命令关闭峰值偏移功能：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd /opt/dell/dcc
$ sudo ./cctk --PeakShiftCfg=Disabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不过，虽然我关闭了这个功能，但是并不知道这个问题是否还会再出现。&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Feb 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/02/10/Dell-XPS-9500-AC-power-adapter-not-regonized/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/02/10/Dell-XPS-9500-AC-power-adapter-not-regonized/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>jemalloc 3.6 版本导致的性能问题</title>
        <description>&lt;p&gt;最近我们有一个服务在测试过程中发现了性能问题，最终定位到是因为 jemalloc 使用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MADV_DONTNEED&lt;/code&gt; 导致的，这里分享一下定位过程。&lt;/p&gt;

&lt;h2 id=&quot;测试环境和问题描述&quot;&gt;测试环境和问题描述&lt;/h2&gt;

&lt;p&gt;测试程序通过网络接受 RPC 请求后，执行处理逻辑，程序运行环境如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CentOS 7.6 + kernel 3.10&lt;/li&gt;
  &lt;li&gt;程序运行在 docker 容器内&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Benchmark 过程很简单，就是通过客户端程序发起请求，然后看看测试过程能达到的服务带宽有多少。在获得结果后，我们发现，使用 jemalloc 的版本性能下降了差不多 20%（不过我们一开始并不知道是 jemalloc 导致的）。&lt;/p&gt;

&lt;h2 id=&quot;定位过程&quot;&gt;定位过程&lt;/h2&gt;

&lt;h3 id=&quot;获取-profile-数据生成火焰图&quot;&gt;获取 profile 数据，生成火焰图&lt;/h3&gt;

&lt;p&gt;这里使用 bcc 的 profile 工具来生成 profile stack 文件，然后使用 Brendan Gregg 的 FlameGraph 工具将其转换成火焰图 (&lt;em&gt;&lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot;&gt;https://github.com/brendangregg/FlameGraph&lt;/a&gt;&lt;/em&gt;)。&lt;/p&gt;

&lt;p&gt;Profile 命令如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# /usr/share/bcc/tools/profile -F 99 -f -a -p $PID 30 &amp;gt; profile.stack
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;FlameGraph 命令如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./flamegraph.pl profile.stack &amp;gt; profile.svg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;得到的火焰图中的关键部分如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00035_flame_graph_recvmsg_madvise.png&quot; alt=&quot;flame_graph_recvmsg_madvise&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图中可以看出两个奇怪的地方：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;有很多 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 调用。&lt;/li&gt;
  &lt;li&gt;收包的时候经常伴随着内存申请操作 (page_fault 的处理)。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;minor-page-fault-有多少&quot;&gt;minor page fault 有多少&lt;/h3&gt;

&lt;p&gt;因为从火焰图中看到了很多 page fault，所以可以通过其他工具来看一下 page fault 的类型和产生速率。因为我们的系统上是关闭了 swap 的，所以肯定都是 minor page fault，这里主要是要查看一下速率。可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sar&lt;/code&gt; 命令来查看：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sar -B 1
Linux 3.10.0-957.el7.x86_64 (node)   01/16/2022      _x86_64_        (40 CPU)

11:49:13 AM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff
11:49:14 AM      0.00    100.00 608239.00      0.00 869641.00      0.00      0.00      0.00      0.00
11:49:15 AM      0.00   3692.00 737822.00      0.00 971933.00      0.00      0.00      0.00      0.00
11:49:16 AM      0.00    104.00 466154.00      0.00 781245.00      0.00      0.00      0.00      0.00
11:49:17 AM      0.00    124.00 460824.00      0.00 769351.00      0.00      0.00      0.00      0.00
11:49:18 AM      0.00    136.00 510035.00      0.00 806849.00      0.00      0.00      0.00      0.00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以发现，每秒钟产生了 50w 次以上的 minor page fault。&lt;/p&gt;

&lt;h3 id=&quot;查看-socket-rmem-的使用情况&quot;&gt;查看 socket rmem 的使用情况&lt;/h3&gt;

&lt;p&gt;此外，因为是在收包的过程中发生了内存申请操作，我们还可以使用 sormem.bt 这个 bpftrace 程序 (&lt;em&gt;&lt;a href=&quot;https://github.com/brendangregg/bpf-perf-tools-book/blob/master/originals/Ch10_Networking/sormem.bt&quot;&gt;https://github.com/brendangregg/bpf-perf-tools-book/blob/master/originals/Ch10_Networking/sormem.bt&lt;/a&gt;&lt;/em&gt;) 来进行查看一下进程的 socket recv buffer 的情况：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./sormem.bt
Attaching 4 probes...
Tracing socket receive buffer size. Hit Ctrl-C to end.
^C

@rmem_alloc:
[0]                15638 |@                                                   |
[1]                    0 |                                                    |
[2, 4)                 0 |                                                    |
[4, 8)                 0 |                                                    |
[8, 16)                0 |                                                    |
[16, 32)               0 |                                                    |
[32, 64)               0 |                                                    |
[64, 128)              0 |                                                    |
[128, 256)             0 |                                                    |
[256, 512)             0 |                                                    |
[512, 1K)            699 |                                                    |
[1K, 2K)            1136 |                                                    |
[2K, 4K)          433243 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[4K, 8K)            7037 |                                                    |
[8K, 16K)           3750 |                                                    |
[16K, 32K)           219 |                                                    |
[32K, 64K)            18 |                                                    |
[64K, 128K)          191 |                                                    |
[128K, 256K)         200 |                                                    |
[256K, 512K)         118 |                                                    |
[512K, 1M)            19 |                                                    |
[1M, 2M)               2 |                                                    |
[2M, 4M)          192207 |@@@@@@@@@@@@@@@@@@@@@@@                             |
[4M, 8M)            8551 |@                                                   |

@rmem_limit:
[128K, 256K)        8580 |                                                    |
[256K, 512K)        6030 |                                                    |
[512K, 1M)             0 |                                                    |
[1M, 2M)           33400 |@@                                                  |
[2M, 4M)            7956 |                                                    |
[4M, 8M)          605235 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[8M, 16M)              0 |                                                    |
[16M, 32M)          1187 |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从 &lt;strong&gt;rmem_alloc&lt;/strong&gt; 的数据可以看出，服务端程序在 benchmark 过程中大量使用了小块的内存。不过，这个数据无法直接推导出一些结论，只能说这可能和内存管理的行为有关。&lt;/p&gt;

&lt;h3 id=&quot;查看-madvise-调用情况&quot;&gt;查看 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 调用情况&lt;/h3&gt;

&lt;p&gt;在查看了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 的 man 手册之后，我发现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 的参数选择对于程序的性能影响很大，所以我们需要知道这里执行的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 调用的参数是什么。这里我写了一个 bpftrace 的程序来获取程序调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 时使用的参数：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat trace_madvise.bt
#!/usr/bin/bpftrace

BEGIN
{
        printf(&quot;trace syscall madvise of pid %d\n&quot;, $1);
}

t:syscalls:sys_enter_madvise /pid == $1/
{
        printf(&quot;pid %d, comm %s, arg1 %lx, arg2 %ld, arg3 %ld\n&quot;, pid, comm, args-&amp;gt;start, args-&amp;gt;len_in, args-&amp;gt;behavior);
}

t:syscalls:sys_exit_madvise /pid == $1/
{
        printf(&quot;pid %d, comm %s, retval %d\n&quot;, pid, comm, args-&amp;gt;ret);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 benchmark 的过程中执行这个脚本，得到的结果主要内容如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pid 336963, comm cmdname, arg1 7fcd81dab000, arg2 1048576, arg3 4
pid 336963, comm cmdname, retval 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arg3 4&lt;/code&gt; 表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;advice&lt;/code&gt; 参数，这里 &lt;strong&gt;4&lt;/strong&gt; 对应的是 &lt;strong&gt;MADV_DONTNEED&lt;/strong&gt;。另外，我还统计了一下 benchmark 过程中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 调用的数量，达到了 22w 次。&lt;/p&gt;

&lt;h3 id=&quot;madv_dontneed-这个坑&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MADV_DONTNEED&lt;/code&gt; 这个坑&lt;/h3&gt;

&lt;p&gt;这个参数的行为很诡异，会直接导致 Linux 立刻回收内存，然后再次访问这块内存，会触发一个内存分配操作，它的行为基本上等于 free 了。man 手册中的关键内容如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;After a successful MADV_DONTNEED operation, the semantics of memory access in the specified region are changed: subsequent accesses of pages in the range will succeed, but will result in either repopulating the memory contents from the up-to-date contents of the underlying mapped file (for shared file mappings, shared anonymous mappings, and shmem-based techniques such as  System V shared memory segments) or zero-fill-on-demand pages for anonymous private mappings.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我去搜下了下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://youjiali1995.github.io/allocator/jemalloc-purge/&quot;&gt;jemalloc purge改进&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/6844904084957315086&quot;&gt;深入理解 Linux 内核–jemalloc 引起的 TLB shootdown 及优化&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;这里要提一下，我们的这个问题并没有 TLB shotdown。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/jemalloc/jemalloc/issues/1422&quot;&gt;madivse MADV_DONTNEED causes bad performence in KVM virtual machine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这个视频我更是强烈推荐，吐嘈之余，让你也能理解这个参数的历史： &lt;em&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=bg6-LVCHmGM&amp;amp;t=3518s&quot;&gt;https://www.youtube.com/watch?v=bg6-LVCHmGM&amp;amp;t=3518s&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;问题总结&quot;&gt;问题总结&lt;/h3&gt;

&lt;p&gt;了解了程序的行为以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 这个坑之后，我们就可以得到这个性能问题的结论了： &lt;strong&gt;由于程序使用的 jemalloc 3.6 版本在运行过程中，大量调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise(MADV_DONTNEED)&lt;/code&gt;，导致内存不断被 kernel 回收。因此，在收包的过程中只好又去申请新的内存，导致收包的性能下降&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;关闭-jemalloc-内存回收进行问题确认&quot;&gt;关闭 jemalloc 内存回收进行问题确认&lt;/h3&gt;

&lt;p&gt;可以通过如下的环境变量关闭 jemalloc 的内存回收机制，&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export MALLOC_CONF=&quot;lg_dirty_mult:-1&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个参数在 jemalloc 的如下代码路径上发挥作用：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 在 src/arena.c 中找到如下函数
static inline void
arena_maybe_purge(arena_t *arena)
{
        size_t npurgeable, threshold;

        /* Don't purge if the option is disabled. */
        if (opt_lg_dirty_mult &amp;lt; 0)
                return;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关闭内存回收之后，我们的程序就不再出现上述的性能问题。&lt;/p&gt;

&lt;h2 id=&quot;kernel-418-的对比测试&quot;&gt;Kernel 4.18 的对比测试&lt;/h2&gt;

&lt;p&gt;随后，我在 &lt;strong&gt;CentOS 7.6 + kernel 4.18&lt;/strong&gt;  的环境上也进行了 benchmark，发现在 kernel 4.18 上，程序的性能下降比较少，大概是 10%。随后写了一个 &lt;em&gt;trace_tcp_recvmsg_time.bt&lt;/em&gt; 的 bpttrace 程序，对比了一下两个版本的 kernel 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tcp_recvmsg&lt;/code&gt; 函数上的性能差异。&lt;/p&gt;

&lt;p&gt;程序如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@node tools]# cat calc_tcp_recvmsg_time.bt
#!/usr/bin/bpftrace

BEGIN
{
        printf(&quot;Calc tcp_recvmsg time of pid %d\n&quot;, $1);
}

kprobe:tcp_recvmsg /pid == $1/
{
        @start[tid] = nsecs;
}

kretprobe:tcp_recvmsg /pid == $1/
{
        if (@start[tid]) {
                @pf_nsecs = hist((nsecs - @start[tid]) / 1000);
                delete(@start[tid]);
        }
}

END
{
        print(@pf_nsecs);
        clear(@start);
        clear(@pf_nsecs);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Kernel 3.10 的结果&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Attaching 4 probes...
Calc tcp_recvmsg time of pid 366959
^C@pf_nsecs:
[1]                  327 |                                                    |
[2, 4)             53761 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      |
[4, 8)              7840 |@@@@                                                |
[8, 16)            39434 |@@@@@@@@@@@@@@@@@@@@@@                              |
[16, 32)            1685 |                                                    |
[32, 64)             223 |                                                    |
[64, 128)            229 |                                                    |
[128, 256)           126 |                                                    |
[256, 512)             9 |                                                    |
[512, 1K)          10484 |@@@@@                                               |
[1K, 2K)           92465 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[2K, 4K)               9 |                                                    |
[4K, 8K)               0 |                                                    |
[8K, 16K)              0 |                                                    |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Kernel 4.18 的结果&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Attaching 4 probes...
Calc tcp_recvmsg time of pid 20607
^C@pf_nsecs:
[0]                   23 |                                                    |
[1]                  274 |                                                    |
[2, 4)             32551 |@@@@@@@@@@@@@@@@                                    |
[4, 8)             52765 |@@@@@@@@@@@@@@@@@@@@@@@@@@                          |
[8, 16)            35111 |@@@@@@@@@@@@@@@@@                                   |
[16, 32)            1375 |                                                    |
[32, 64)             116 |                                                    |
[64, 128)             41 |                                                    |
[128, 256)            15 |                                                    |
[256, 512)            27 |                                                    |
[512, 1K)         103847 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[1K, 2K)           17881 |@@@@@@@@                                            |
[2K, 4K)               2 |                                                    |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;得到的结论是，kernel 4.18 在这个路径上的性能确实比 kernel 3.10 更好。不过，因为不能对 kernel 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_page_fault&lt;/code&gt; 函数进行 kprobe，所以不确定这里的性能改进是哪部分贡献的。&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Jan 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/01/20/Performance-problem-caused-by-jemalloc-3.6/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/01/20/Performance-problem-caused-by-jemalloc-3.6/</guid>
        
        <category>linux</category>
        
        <category>kernel</category>
        
        <category>network</category>
        
        
      </item>
    
      <item>
        <title>CentOS 官方是如何编译一个包的</title>
        <description>&lt;p&gt;CentOS 是企业级开发里常用的 base 操作系统，很多时候，我们会先使用官方源里的包，随着业务的发展，我们会开始自己修改代码。这种时候，我们就希望可以编译出和 CentOS 官方一样的包。那么如何找到 CentOS  官方是如何编译包的呢？&lt;/p&gt;

&lt;h2 id=&quot;koji&quot;&gt;Koji&lt;/h2&gt;

&lt;p&gt;Koji 是 Fedora 平台用来编译 RPM 包和镜像的系统，CentOS/Rocky Linux 也都使用这个平台。这个 wiki 介绍了 Koji 的基本信息：&lt;em&gt;&lt;a href=&quot;https://fedoraproject.org/wiki/Koji&quot;&gt;https://fedoraproject.org/wiki/Koji&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;我们可以找到 CentOS Koji 的链接，然后通过 Koji 来找到我们需要的包的信息。&lt;/p&gt;

&lt;h2 id=&quot;如何找到-centos-8-官方编译-libvirt-的方案&quot;&gt;如何找到 CentOS 8 官方编译 libvirt 的方案&lt;/h2&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进入 Koji 的 build 页面：&lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/koji/builds&quot;&gt;https://koji.mbox.centos.org/koji/builds&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;在里面搜索 libvirt，找到 libvirt 有关的任务&lt;/li&gt;
  &lt;li&gt;找一个最新的：&lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/koji/buildinfo?buildID=19878&quot;&gt;https://koji.mbox.centos.org/koji/buildinfo?buildID=19878&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;进去之后，找到 task，然后进入 task：&lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/koji/taskinfo?taskID=310486&quot;&gt;https://koji.mbox.centos.org/koji/taskinfo?taskID=310486&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;因为会编译多个 arch 的包，所以还有子 task，我们可以进入 x86_64 的查看： &lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/koji/taskinfo?taskID=310489&quot;&gt;https://koji.mbox.centos.org/koji/taskinfo?taskID=310489&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;在这里就可以看到 build.log 的链接，点进去查看： &lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/pkgs/work/tasks/489/310489/build.log&quot;&gt;https://koji.mbox.centos.org/pkgs/work/tasks/489/310489/build.log&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在里面搜索 &lt;strong&gt;meson&lt;/strong&gt;，可以找到 meson 的参数，就知道 CentOS 8 官方如何编译 libvirt 库了：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ /usr/bin/meson --buildtype=plain --prefix=/usr --libdir=/usr/lib64 --libexecdir=/usr/libexec --bindir=/usr/bin --sbindir=/usr/sbin --includedir=/usr/include --datadir=/usr/share --mandir=/usr/share/man --infodir=/usr/share/info --localedir=/usr/share/locale --sysconfdir=/etc --localstatedir=/var --sharedstatedir=/var/lib --wrap-mode=nodownload --auto-features=enabled . x86_64-redhat-linux-gnu -Drunstatedir=/run -Ddriver_qemu=enabled -Ddriver_openvz=disabled -Ddriver_lxc=disabled -Ddriver_vbox=disabled -Ddriver_libxl=disabled -Dsasl=enabled -Dpolkit=enabled -Ddriver_libvirtd=enabled -Ddriver_remote=enabled -Ddriver_test=enabled -Ddriver_esx=enabled -Dcurl=enabled -Ddriver_hyperv=disabled -Dopenwsman=disabled -Ddriver_vmware=disabled -Ddriver_vz=disabled -Ddriver_bhyve=disabled -Ddriver_ch=disabled -Dremote_default_mode=legacy -Ddriver_interface=enabled -Ddriver_network=enabled -Dstorage_fs=enabled -Dstorage_lvm=enabled -Dstorage_iscsi=enabled -Dstorage_iscsi_direct=enabled -Dlibiscsi=enabled -Dstorage_scsi=enabled -Dstorage_disk=enabled -Dstorage_mpath=enabled -Dstorage_rbd=enabled -Dstorage_sheepdog=disabled -Dstorage_gluster=enabled -Dglusterfs=enabled -Dstorage_zfs=disabled -Dstorage_vstorage=disabled -Dnumactl=enabled -Dnumad=enabled -Dcapng=enabled -Dfuse=disabled -Dnetcf=enabled -Dselinux=enabled -Dselinux_mount=/sys/fs/selinux -Dapparmor=disabled -Dapparmor_profiles=disabled -Dsecdriver_apparmor=disabled -Dudev=enabled -Dyajl=enabled -Dsanlock=enabled -Dlibpcap=enabled -Dlibnl=enabled -Daudit=enabled -Ddtrace=enabled -Dfirewalld=enabled -Dfirewalld_zone=enabled -Dwireshark_dissector=enabled -Dlibssh=enabled -Dlibssh2=disabled -Dpm_utils=disabled -Dnss=enabled '-Dpackager=CentOS Buildsys &amp;lt;bugs@centos.org&amp;gt;, 2021-11-09-20:38:08, ' -Dpackager_version=1.module_el8.6.0+983+a7505f3f -Dqemu_user=qemu -Dqemu_group=qemu -Dtls_priority=@LIBVIRT,SYSTEM -Dwerror=true -Dexpensive_tests=enabled -Dinit_script=systemd -Ddocs=enabled -Dtests=enabled -Drpath=disabled -Dlogin_shell=disabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在里面搜索 &lt;strong&gt;rpmbuild&lt;/strong&gt; 就可以知道它用什么命令打包的了。&lt;/p&gt;

&lt;p&gt;同样的，Fedora 和 Rocky Linux 也可以用这个方法找到他们的打包细节。&lt;/p&gt;
</description>
        <pubDate>Tue, 07 Dec 2021 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2021/12/07/How-CentOS-build-rpm-packages/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2021/12/07/How-CentOS-build-rpm-packages/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>Golang time 库里的一个矛盾实现</title>
        <description>&lt;p&gt;Golang &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.Now()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.Parse()&lt;/code&gt; 两个函数对于 location 处理上是不一致的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.Parse()&lt;/code&gt; 方法在生成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Time&lt;/code&gt; 对象时，可能会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setLoc&lt;/code&gt; 方法，用于设置时区信息。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setLoc&lt;/code&gt; 方法，以及相关的其他方法都有一个特殊处理，就是将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Time.loc == nil&lt;/code&gt; 这个条件等同于 UTC 时区，例如下列代码：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// setLoc sets the location associated with the time.
func (t *Time) setLoc(loc *Location) {
	if loc == &amp;amp;utcLoc {
		loc = nil
	}
	t.stripMono()
	t.loc = loc
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.Now()&lt;/code&gt; 方法并不是这么处理的，无论时区如何，它都会为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Time.loc&lt;/code&gt; 赋值，如下所示：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Now returns the current local time.
func Now() Time {
	sec, nsec, mono := now()
	mono -= startNano
	sec += unixToInternal - minWall
	if uint64(sec)&amp;gt;&amp;gt;33 != 0 {
		return Time{uint64(nsec), sec + minWall, Local}
	}
	return Time{hasMonotonic | uint64(sec)&amp;lt;&amp;lt;nsecShift | uint64(nsec), mono, Local}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;于是，&lt;strong&gt;当你的程序运行在一个 UTC 时区的 Linux 系统上时，就会出现如下矛盾的现象：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.Now()&lt;/code&gt; 返回的值里, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loc&lt;/code&gt; 成员是有值的，但是用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.Parse()&lt;/code&gt; 去解析一个时间字符串时，得到的值里，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loc&lt;/code&gt; 成员可能是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;&lt;/strong&gt;。这个矛盾会导致一些比较代码失败（直接用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt; 比较），因为其中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loc&lt;/code&gt; 字段的值不一致。当然，官方文档也提到了这一点，&lt;strong&gt;所以比较时间还是应该用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Time.Equal()&lt;/code&gt; 方法&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果需要在这种情况下，为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parse()&lt;/code&gt; 得到的时间附上一个时区信息，得到和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Now()&lt;/code&gt; 一样的效果，可以使用如下的函数实现：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// parseTime calls time.Parse and set location if time.Local is UTC.
//
// time.Parse function will call Time.setLoc method which set Time.loc = nil
// if location is UTC. But on a machine with UTC timezone, time.Now() returns
// a Time value with Time.loc set to utcLoc, so it's not nil. The two methods
// result in discrepancy in time.Time values.
func parseTime(layout, value string) (time.Time, error) {
	t, err := time.Parse(layout, value)
	if err != nil {
		return time.Time{}, err
	}
	if _, offset := t.Zone(); offset == 0 {
		return t.Local(), nil
	}
	return t, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 20 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2021/10/20/Contradictory-implementation-in-Golang-time-library/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2021/10/20/Contradictory-implementation-in-Golang-time-library/</guid>
        
        <category>golang</category>
        
        
      </item>
    
      <item>
        <title>对程序员来说，速度是重要的</title>
        <description>&lt;p&gt;对于一个程序员来说，开发的速度是重要的。为什么呢？&lt;/p&gt;

&lt;p&gt;在说明原因之前，要先澄清下我说的开发速度包括哪些方面。&lt;strong&gt;开发速度，并不是仅仅指敲用键盘输入代码，而包括更大范围的一些操作&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;操作 IDE 的速度，就是使用 IDE 的熟练程度。&lt;/li&gt;
  &lt;li&gt;操作终端的速度。例如快速的跳转位置，快速的查找命令历史等。&lt;/li&gt;
  &lt;li&gt;操作 git 的速度。快速的切换分支，快速的 merge 或者 rebase 等。&lt;/li&gt;
  &lt;li&gt;使用操作系统的速度。例如快速找到一堆浏览器标签页中你需要的那个。&lt;/li&gt;
  &lt;li&gt;搭建最基础开发环境的速度。例如你用 Python，要能快速的搭建一个 Virtualenv ；或者你用 Go，要能快速的写好一个 go.mod，然后 download 所有依赖。最基础的开发环境往往用来写一些非常简短的测试代码，显然，搭建基础开发环境的时候不应该比写这个简短测试代码的时间长。&lt;/li&gt;
  &lt;li&gt;找到所需文档的速度，不只是 Google，还包括在你的团队所使用的 wiki 系统。&lt;/li&gt;
  &lt;li&gt;使用最基本的 shell 工具的速度，包括但不限于 find， grep，awk，wc 等。这些工具一般用来快速的找到文件或者快速的找到想要的内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面提到的这些操作，只要经过专门训练，都能大幅提升操作速度（也可以说是熟练度）。&lt;/p&gt;

&lt;p&gt;为什么程序员需要在上面列出的这些事情上追求速度呢？功利的说，上面这些事情，并不直接帮你赚钱，所以花的时间越多，你用来赚钱的时间就越少。但是，从成就感的角度来找这个问题的答案，会让我们更加愉悦：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你可以有更多的时间来思考那些直接产生价值的代码，这有助于写出更好的代码，以及做出更好的产品。&lt;/li&gt;
  &lt;li&gt;你的工作过程看起来会更炫酷。谁不爱呢。&lt;/li&gt;
  &lt;li&gt;你会更擅长排查环境导致问题，也更不容易造成这样的问题。&lt;/li&gt;
  &lt;li&gt;有更多的时间享受创造的快乐，而不是陷在问题的泥潭之中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总而言之，会编程成为一件快乐的事情。&lt;/p&gt;

&lt;p&gt;不过，当你变得很快时，可能会产生一个副作用：你会对同事变得缺乏耐心，并且不乐于帮助他们。如果你能解决这个副作用，那么你可以收获更多的东西。&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2021/10/11/Be-fast-do-matter-for-programmer/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2021/10/11/Be-fast-do-matter-for-programmer/</guid>
        
        <category>programming</category>
        
        
      </item>
    
      <item>
        <title>getaddrinfo 中最长前缀匹配实现导致的DNS 负载均衡失效</title>
        <description>&lt;h1 id=&quot;dns-负载均衡方案的失效&quot;&gt;DNS 负载均衡方案的失效&lt;/h1&gt;

&lt;p&gt;通过 DNS 实现负载均衡是一种常见的方案。这种方案通常会返回多个 A 记录，客户端会按照 DNS 响应中的顺序依次尝试去连接服务器，直到成功为止。这个方案对于客户端是有要求的，即客户端必须严格按照 DNS 响应中的地址顺序来访问服务器。在一段不算短的时间以前，大概是 Linux 还未成熟的时候，很多应用还是使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt; 来进行 DNS 解析。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt; 接口会严格返回 DNS 响应中的地址顺序，因此应用使用一个循环来进行连接尝试时，就达到了负载均衡的目的。但是，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 接口被实现，并且被推荐用来替代 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt; 之后，这个情况就变了。原因是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 会实现 &lt;strong&gt;RFC 3484 (Default Address Selection for Internet Protocol version 6 (IPv6))&lt;/strong&gt; 中的地址选择功能，其中的&lt;strong&gt;目标地址选择功能&lt;/strong&gt;直接导致了 DNS 负载均衡方案的失效。简单的说，目标地址选择功能会修改返回给应用程序的 DNS 地址记录的顺序，导致应用程序是按照目标地址选择功能决定的顺序，而不是 DNS 服务器决定的顺序来访问服务器。会导致地址返回顺序被修改的场景很多，本文会描述一种我觉得最常见的失效场景。&lt;/p&gt;

&lt;h1 id=&quot;失效场景与-ip-地址的选择有关&quot;&gt;失效场景：与 IP 地址的选择有关&lt;/h1&gt;

&lt;p&gt;失效的场景设置如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00034_dns_and_getaddrinfo.png&quot; alt=&quot;getaddrinfo_and_dns&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个业务的流程是这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;某个业务有一个客户端，以及三台服务器。采用 DNS 负载均衡方案，让客户端按照一定的比例将请求转发到三个服务器上。&lt;/li&gt;
  &lt;li&gt;客户端需要通过内部的 DNS 服务器来解析域名，获得可以访问的服务器地址。在实现上，从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 返回的第一个地址开始尝试。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;DNS 服务器返回的其中一个 DNS 响应如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;test.dom.               3600    IN      A       192.168.192.128
test.dom.               3600    IN      A       192.168.192.127
test.dom.               3600    IN      A       192.168.192.129
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为我们采用了负载均衡的策略，所以返回的 DNS 响应，每次都会重新排列所有的地址，保证每个地址出现在第一条的概率基本一样。所以，实际上有 6 中排列组合方式。&lt;/p&gt;

&lt;p&gt;客户端也有一个同网段的地址：&lt;strong&gt;192.168.192.121&lt;/strong&gt;。所有这些地址，都属于 &lt;em&gt;192.168.192.0/24&lt;/em&gt; 这个子网。如本章的标题所示，这些地址的选择是非常重要的，&lt;strong&gt;就是地址的值导致了 DNS 负载均衡的失效&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在这个场景中，我们发现我们的客户端程序每次都是去连接 &lt;strong&gt;192.168.192.127&lt;/strong&gt; 这个地址，从来不使用其他两个地址，不管这个 &lt;em&gt;192.168.192.127&lt;/em&gt; 的地址是出现在响应中的哪个位置。&lt;/p&gt;

&lt;h1 id=&quot;问题定位与分析&quot;&gt;问题定位与分析&lt;/h1&gt;

&lt;p&gt;我们首先排除了 DNS 服务器的问题，以及客户端实现的问题。所以，问题出现在 DNS 请求成功后，到将地址列表返回给客户端程序之前。为了简化问题定位，我们发现 ping 程序也遇到了同样的问题，即 ping 这个域名，都只会使用 &lt;em&gt;192.168.192.127&lt;/em&gt; 这个地址。&lt;/p&gt;

&lt;h2 id=&quot;使用-strace-命令来分析问题&quot;&gt;使用 strace 命令来分析问题&lt;/h2&gt;

&lt;p&gt;我们先使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strace ping -c 1 test.dom&lt;/code&gt; 命令来看看程序到底做了什么。下面是其中的相关内容（为了好看，我删掉了不相关的内容。另外，如果你想看到更多的参数信息，可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strace&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-s&lt;/code&gt; 参数）：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 先连接 DNS 服务器，发出 DNS 请求，并且收到响应。
socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC|SOCK_NONBLOCK, IPPROTO_IP) = 4
connect(4, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;192.168.192.132&quot;)}, 16) = 0
sendto(4, &quot;\272\273\1\0\0\1\0\0\0\0\0\0\4test\3dom\0\0\1\0\1&quot;, 26, MSG_NOSIGNAL, NULL, 0) = 26
recvfrom(4, &quot;\272\273\205\0\0\1\0\3\0\1\0\0\4test\3dom\0\0\1\0\1\4test\3&quot;..., 1024, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;192.168.192.132&quot;)}, [16]) = 121
close(4)                                = 0

# 尝试打开这个文件，见下文。
open(&quot;/etc/gai.conf&quot;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)

# 通过 NETLINK 获取一些接口信息 (getifaddrs)
socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE) = 4
bind(4, {sa_family=AF_NETLINK, pid=0, groups=00000000}, 12) = 0
getsockname(4, {sa_family=AF_NETLINK, pid=217030, groups=00000000}, [12]) = 0
sendto(4, &quot;\24\0\0\0\26\0\1\3\312W`a\0\0\0\0\0\0\0\0&quot;, 20, 0, {sa_family=AF_NETLINK, pid=0, groups=00000000}, 12) = 20
recvmsg(4, {msg_name(12)={sa_family=AF_NETLINK, pid=0, groups=00000000}, msg_iov(1)=[{&quot;L...
recvmsg(4, {msg_name(12)={sa_family=AF_NETLINK, pid=0, groups=00000000}, msg_iov(1)=[{&quot;H
recvmsg(4, {msg_name(12)={sa_family=AF_NETLINK, pid=0, groups=00000000}, msg_iov(1)=[{&quot;...

# 尝试连接 DNS 返回的每个地址，判断是否可用。这里用的是 UDP，所以主要是判断路由是否可达。
socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC, IPPROTO_IP) = 4
connect(4, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&quot;192.168.192.128&quot;)}, 16) = 0
getsockname(4, {sa_family=AF_INET, sin_port=htons(58008), sin_addr=inet_addr(&quot;192.168.192.121&quot;)}, [16]) = 0
connect(4, {sa_family=AF_UNSPEC, sa_data=&quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;}, 16) = 0
connect(4, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&quot;192.168.192.127&quot;)}, 16) = 0
getsockname(4, {sa_family=AF_INET, sin_port=htons(44743), sin_addr=inet_addr(&quot;192.168.192.121&quot;)}, [16]) = 0
connect(4, {sa_family=AF_UNSPEC, sa_data=&quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;}, 16) = 0
connect(4, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&quot;192.168.192.129&quot;)}, 16) = 0
getsockname(4, {sa_family=AF_INET, sin_port=htons(35095), sin_addr=inet_addr(&quot;192.168.192.121&quot;)}, [16]) = 0

# 开始连接 192.168.192.127。注意到，从上面到这里，没有任何系统调用，所以这里是一段完全由代码和内存数据决定的逻辑。
socket(AF_INET, SOCK_DGRAM, IPPROTO_IP) = 4
connect(4, {sa_family=AF_INET, sin_port=htons(1025), sin_addr=inet_addr(&quot;192.168.192.127&quot;)}, 16) = 0
getsockname(4, {sa_family=AF_INET, sin_port=htons(34211), sin_addr=inet_addr(&quot;192.168.192.121&quot;)}, [16]) = 0
setsockopt(3, SOL_RAW, ICMP_FILTER, ~(1&amp;lt;&amp;lt;ICMP_ECHOREPLY|1&amp;lt;&amp;lt;ICMP_DEST_UNREACH|1&amp;lt;&amp;lt;ICMP_SOURCE_QUENCH|1&amp;lt;&amp;lt;ICMP_REDIRECT|1&amp;lt;&amp;lt;ICMP_TIME_EXCEEDED|1&amp;lt;&amp;lt;ICMP_PARAMETERPROB), 4) = 0
setsockopt(3, SOL_IP, IP_RECVERR, [1], 4) = 0
setsockopt(3, SOL_SOCKET, SO_SNDBUF, [324], 4) = 0
setsockopt(3, SOL_SOCKET, SO_RCVBUF, [65536], 4) = 0
getsockopt(3, SOL_SOCKET, SO_RCVBUF, [131072], [4]) = 0
PING test.dom (192.168.192.127) 56(84) bytes of data.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面的代码中，我注释了关键的部分。最后，我们可以发现，导致问题的代码是在尝试 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect&lt;/code&gt; 之后，以及应用开始使用 IP 地址之前的部分，也就是说，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 导致的问题。但是，为什么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 这个函数会有这个问题？理论上来说，一个广泛使用的库函数，应该是很稳定的。此时，我注意到了上面的 &lt;strong&gt;/etc/gai.conf&lt;/strong&gt; 这个文件。&lt;/p&gt;

&lt;h2 id=&quot;getaddrinfo-与-rfc-3484&quot;&gt;getaddrinfo 与 RFC 3484&lt;/h2&gt;

&lt;p&gt;通过阅读 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;man gai.conf&lt;/code&gt;，我了解到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 根据 RFC 3484 实现了目的地址排序，再通过阅读 RFC 的相关内容，我了解到，这个排序会涉及到 10 条规则 (RFC 3484, Chapter 6 Destination Address Selection)。通过反复研究这 10 条规则，以及进行一些测试，我判断比较可能是规则 9 导致的问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Rule 9:  Use longest matching prefix.
When DA and DB belong to the same address family (both are IPv6 or
both are IPv4): If CommonPrefixLen(DA, Source(DA)) &amp;gt;
CommonPrefixLen(DB, Source(DB)), then prefer DA.  Similarly, if
CommonPrefixLen(DA, Source(DA)) &amp;lt; CommonPrefixLen(DB, Source(DB)),
then prefer DB.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么，RFC 3484 是做什么的呢？这个其实在引入 IPv6 之后，对于网络中一个节点，如何选择源地址与目的地址做出了规定。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 因为涉及到网络地址的选择，所以实现了这个标准。你可能有疑问，为什么一个 IPv6 的标准会影响到 IPv4 的网络，这个主要是因为网络总是要过度的，所以在指定标准的过程中就都进行了考虑。这个标准对于 IPv4 源地址的选择没有做规定，这个取决于操作系统的实现，主要还是路由来决定选择哪个源地址。但是规定了目标地址的选择，比如遵守上面提到的 10 条规则。&lt;/p&gt;

&lt;p&gt;为什么我会判断是 Rule 9 导致的问题，主要是结合一下几个方面：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端和服务器的地址在同一个网段，不会收到路由决策的干扰，且全部处于可用状态。&lt;/li&gt;
  &lt;li&gt;操作系统不存在 &lt;em&gt;/etc/gai.conf&lt;/em&gt; 文件，所以不会有 label 和优先级的问题。&lt;/li&gt;
  &lt;li&gt;因为地址都是 IPv4 的私有网段，所以 scope 也都是规定好的，也就没有任何差异。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;阅读-glibc-代码并且进行-gdb&quot;&gt;阅读 glibc 代码并且进行 gdb&lt;/h2&gt;

&lt;p&gt;当然，上面只是推测，还需要证据。接下来，我们要结合代码来找证据，当然，因为时间有限，不太可能仔细研究代码，所以我一般结合代码和调试信息来定位问题。&lt;/p&gt;

&lt;p&gt;glibc 的代码： &lt;em&gt;&lt;a href=&quot;https://sourceware.org/git/glibc.git&quot;&gt;https://sourceware.org/git/glibc.git&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;我们是 CentOS 7.6 的系统，可以在系统上安装 debuginfo 来进行调试：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 会自动安装 glibc 的 debuginfo。
# debuginfo-install iputils-20160308-10.el7.x86_64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后使用 gdb 来辅助代码阅读：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# gdb --args ping -c 1 test.dom
(gdb) b getaddrinfo
Breakpoint 1 at 0x2210
(gdb) run
Starting program: /usr/bin/ping -c 1 test.gfs

Breakpoint 1, __GI_getaddrinfo (name=name@entry=0x7fffffffe666 &quot;test.gfs&quot;, service=service@entry=0x0, hints=hints@entry=0x7fffffffe270, pai=pai@entry=0x7fffffffe248)
    at ../sysdeps/posix/getaddrinfo.c:2208
2208    {
Missing separate debuginfos, use: debuginfo-install libattr-2.4.46-13.el7.x86_64 zlib-1.2.7-18.el7.x86_64
(gdb) b rfc3484_sort
Breakpoint 2 at 0x7ffff6d3df70: file ../sysdeps/posix/getaddrinfo.c, line 1440.
(gdb) c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个时候，我们就进入到了 glibc 这个库中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rfc3484_sort&lt;/code&gt; 这个函数，函数名字取得很好，最终的问题也是由这里导致的。接下来是逐行分析这个函数的逻辑，过程就不细说了，我们来看结论。&lt;/p&gt;

&lt;h2 id=&quot;rfc3484_sort-longest-matching-prefix-实现&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rfc3484_sort&lt;/code&gt; Longest Matching Prefix 实现&lt;/h2&gt;

&lt;p&gt;这个函数的注释很清晰，标明了哪个部分是对应到标准的哪个 rule。通过 gdb 的逐步调试，我们发现，果然是 Rule 9 导致的问题。我们只关心 IPv4 的部分，见下面的代码（代码原始缩进就没对齐）：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 这个函数是用在快排中的 cmp 函数，用来比较两个地址的优先级。
// 函数里的 a1 和 a2 两个变量，会在快排过程中，对应到 DNS 返回的两个地址，比如 192.168.192.127 和 192.168.192.128。
// 函数运行到这里时，源地址已经选择完毕了，就是根据路由选出来的网卡地址，在这个场景中，就是 192.168.192.121。

  /* Rule 9: Use longest matching prefix.  */
  if (a1-&amp;gt;got_source_addr
      &amp;amp;&amp;amp; a1-&amp;gt;dest_addr-&amp;gt;ai_family == a2-&amp;gt;dest_addr-&amp;gt;ai_family)
    {
      int bit1 = 0;
      int bit2 = 0;

      if (a1-&amp;gt;dest_addr-&amp;gt;ai_family == PF_INET)
	{
	  assert (a1-&amp;gt;source_addr.sin6_family == PF_INET);
	  assert (a2-&amp;gt;source_addr.sin6_family == PF_INET);

	  /* Outside of subnets, as defined by the network masks,
	     common address prefixes for IPv4 addresses make no sense.
	     So, define a non-zero value only if source and
	     destination address are on the same subnet.  */
	  struct sockaddr_in *in1_dst
	    = (struct sockaddr_in *) a1-&amp;gt;dest_addr-&amp;gt;ai_addr;
	  in_addr_t in1_dst_addr = ntohl (in1_dst-&amp;gt;sin_addr.s_addr);
	  struct sockaddr_in *in1_src
	    = (struct sockaddr_in *) &amp;amp;a1-&amp;gt;source_addr;
	  in_addr_t in1_src_addr = ntohl (in1_src-&amp;gt;sin_addr.s_addr);
	  in_addr_t netmask1 = 0xffffffffu &amp;lt;&amp;lt; (32 - a1-&amp;gt;prefixlen);

	  // in1_src_addr 就是选择到的源地址，在这个场景里，就是 192.168.192.121
	  // netmask1 和 24 位掩码对应： 0xffffff00
	  // in1_dst_addr 就是参与比较的某个 DNS 响应中的地址。
	  if ((in1_src_addr &amp;amp; netmask1) == (in1_dst_addr &amp;amp; netmask1))
	    // 因为我们的客户端和服务端在同一个子网，所以这个条件会成立。
	    // fls 函数，从左到右找到第一个 1 的位置，最左边是位置 0，最右边是位置 31.
		// 将源地址和目标地址进行 XOR，然后找到第一个 1 的位置。
	    bit1 = fls (in1_dst_addr ^ in1_src_addr);

	  struct sockaddr_in *in2_dst
	    = (struct sockaddr_in *) a2-&amp;gt;dest_addr-&amp;gt;ai_addr;
	  in_addr_t in2_dst_addr = ntohl (in2_dst-&amp;gt;sin_addr.s_addr);
	  struct sockaddr_in *in2_src
	    = (struct sockaddr_in *) &amp;amp;a2-&amp;gt;source_addr;
	  in_addr_t in2_src_addr = ntohl (in2_src-&amp;gt;sin_addr.s_addr);
	  in_addr_t netmask2 = 0xffffffffu &amp;lt;&amp;lt; (32 - a2-&amp;gt;prefixlen);

	  if ((in2_src_addr &amp;amp; netmask2) == (in2_dst_addr &amp;amp; netmask2))
	    bit2 = fls (in2_dst_addr ^ in2_src_addr);
	}
      else if (a1-&amp;gt;dest_addr-&amp;gt;ai_family == PF_INET6)
	{
	  ...
	}

	// 第一个 1 的位置越靠右边，值越小。注意，如果值相等，就不改变位置。
		if (bit1 &amp;gt; bit2)
	return -1;
      if (bit1 &amp;lt; bit2)
	return 1;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以我们的场景来说：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;192.168.192.127 和 192.168.192.128 进行比较：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEX(192.168.192.121) = 0xc0a8c079&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEX(192.168.192.127) = 0xc0a8c07f&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEX(192.168.192.128) = 0xc0a8c080&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;netmask1 = netmask2 = 0xffffff00&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bit1 = fls(in1_dst_addr ^ in1_src_addr) = fls(0xc0a8c07f ^ 0xc0a8c079) = 29&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bit2 = fls(in2_dst_addr ^ in2_src_addr) = fls(0xc0a8c079 ^ 0xc0a8c080) = 24&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bit1 &amp;gt; bit2&lt;/code&gt;，所以 &lt;em&gt;192.168.192.127&lt;/em&gt; 排在 &lt;em&gt;192.168.192.128&lt;/em&gt; 前面。同样，你可以算出 &lt;em&gt;192.168.192.129&lt;/em&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fls(...)&lt;/code&gt; 值为 24，所以它也排在 &lt;em&gt;192.168.192.127&lt;/em&gt; 后面。于是，只要服务端返回是这三个地址，&lt;em&gt;192.168.192.127&lt;/em&gt; 永远排在第一个。&lt;/p&gt;

&lt;h2 id=&quot;构造-dns-轮询不失效的地址&quot;&gt;构造 DNS 轮询不失效的地址&lt;/h2&gt;

&lt;p&gt;把上面的 &lt;em&gt;192.168.192.127&lt;/em&gt; 换成 &lt;strong&gt;192.168.192.130&lt;/strong&gt;，此时，你就会发现，128, 129, 130 这三个地址算出来的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fls(...)&lt;/code&gt; 值都是 24，所以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 不会改变 DNS 响应返回的地址的顺序，&lt;strong&gt;DNS 轮询“神奇“的生效了&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;再看另外一个例子：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端是 10.253.1.14&lt;/li&gt;
  &lt;li&gt;三个服务器是 10.253.1.43, 10.253.1.44, 10.253.1.45&lt;/li&gt;
  &lt;li&gt;DNS 服务器是 10.253.1.46&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用这些地址，你会算出来三个服务器地址的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fls(...)&lt;/code&gt; 都为 26，所以 DNS 轮询又“神奇”的生效了。&lt;/p&gt;

&lt;h1 id=&quot;ref&quot;&gt;Ref&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;https://en.wikipedia.org/wiki/Getaddrinfo&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://access.redhat.com/solutions/22132&quot;&gt;https://access.redhat.com/solutions/22132&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;RedHat 官方对于这个问题的解决方案，其实结论是除非关掉 IPv6，否则无解。所以，无解。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://daniel.haxx.se/blog/2012/01/03/getaddrinfo-with-round-robin-dns-and-happy-eyeballs/&quot;&gt;https://daniel.haxx.se/blog/2012/01/03/getaddrinfo-with-round-robin-dns-and-happy-eyeballs/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jameshfisher.com/2018/02/03/what-does-getaddrinfo-do/&quot;&gt;https://jameshfisher.com/2018/02/03/what-does-getaddrinfo-do/&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;通过 strace 来介绍了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 做了什么。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3484.txt&quot;&gt;https://www.ietf.org/rfc/rfc3484.txt&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://lists.debian.org/debian-glibc/2007/09/msg00347.html&quot;&gt;https://lists.debian.org/debian-glibc/2007/09/msg00347.html&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;狂喷 RFC 3484 Rule 9&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;update&quot;&gt;Update&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;2021-10-09: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s/192.168.192.197/192.168.192.127/g&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 08 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2021/10/08/DNS-Round-Robin-Fail-and-Longest-Matching-Prefix-Implementation-in-getaddrinfo/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2021/10/08/DNS-Round-Robin-Fail-and-Longest-Matching-Prefix-Implementation-in-getaddrinfo/</guid>
        
        <category>linux</category>
        
        <category>network</category>
        
        
      </item>
    
      <item>
        <title>Golang Testing Parallel</title>
        <description>&lt;p&gt;本文将介绍 Golang 单元测试的串行运行和并行运行的实现细节，以及在使用 &lt;strong&gt;github.com/stretchr/testify/suite&lt;/strong&gt; 库时，如何控制串行和并行。&lt;/p&gt;

&lt;h2 id=&quot;基本流程-basic-procedure&quot;&gt;基本流程 Basic Procedure&lt;/h2&gt;

&lt;h3 id=&quot;test-code-scanning-loading-and-test-cases-execution&quot;&gt;Test Code Scanning, Loading and Test Cases Execution&lt;/h3&gt;

&lt;p&gt;通常我们会用如下的命令运行单元测试： &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go test -v goexample/pkg/apiserver&lt;/code&gt;，也就是我们运行 package &lt;strong&gt;goexample/pkg/apiserver&lt;/strong&gt; 下的所有单元测试。下面，我们先来分析这个命令的内部流程。&lt;/p&gt;

&lt;p&gt;首先 &lt;em&gt;go test&lt;/em&gt; 这个命令会扫描 package 下的测试代码信息（名字以 _test.go 结尾的文件），然后会用这些代码信息重新生成一个 &lt;strong&gt;main&lt;/strong&gt; 程序，或者称为 &lt;strong&gt;testmain&lt;/strong&gt; 程序，执行这个程序就是在执行所有的测试用例代码。我们需要先来看一下这里生成 &lt;strong&gt;testmain&lt;/strong&gt; 程序的细节，这个对于理解测试用例的串行和并行是至关重要的。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;和扫描测试代码信息，以及生成 &lt;strong&gt;testmain&lt;/strong&gt; 有关的代码在 Golang 仓库的 &lt;em&gt;src/cmd/go/internal/load/test.go&lt;/em&gt; 文件里。这个文件最下面有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testmainTmpl&lt;/code&gt; 的变量，保存了用于生成 &lt;strong&gt;testmain&lt;/strong&gt; 程序的模板。其中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数部分如下：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; func main() {
	
     testing.RegisterCover(testing.Cover{
         Mode: ,
         Counters: coverCounters,
         Blocks: coverBlocks,
         CoveredPackages: ,
     })
	
     m := testing.MainStart(testdeps.TestDeps{}, tests, benchmarks, examples)
	
     .(m)
     os.Exit(int(reflect.ValueOf(m).Elem().FieldByName(&quot;exitCode&quot;).Int()))
	
     os.Exit(m.Run())
	
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;从这个代码可以看出，首先会会先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m := testing.MainStart()&lt;/code&gt; 以获得一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testing.M&lt;/code&gt; 对象。随后，如果你定义了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestMain&lt;/code&gt; 函数，就会执行该函数，否则执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m.Run()&lt;/code&gt;。这里的 &lt;strong&gt;testing&lt;/strong&gt; 就是标准库里的 &lt;strong&gt;testing&lt;/strong&gt; 库。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;上面代码中，传递给 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testing.MainStart&lt;/code&gt; 函数的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tests&lt;/code&gt; 变量是在该模板中定义的的一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[]testing.InternalTest&lt;/code&gt; 列表，其每个元素就对应测试 package 中的一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestXxx(t *testing.T)&lt;/code&gt; 函数 (是文件级的函数，不是 &lt;em&gt;testify/suite&lt;/em&gt; 的一个 suite 的方法，相关的代码也是在上面提到的 &lt;em&gt;load/test.go&lt;/em&gt; 文件中，就不展开说了)。在通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testing.MainStart()&lt;/code&gt; 创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testing.M&lt;/code&gt; 对象时，这些测试用例文件都存放在了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testing.M.tests&lt;/code&gt; 成员中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接下来就是执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testing.M.Run()&lt;/code&gt; 方法，在这个方法内，主要是调用 &lt;strong&gt;testing&lt;/strong&gt; 库的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runTests&lt;/code&gt; 函数（下文如无特别说明，所提到的函数都是指 &lt;strong&gt;testing&lt;/strong&gt; 库中的函数）。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runTests&lt;/code&gt; 函数可以认为是一个 package 下的所有用例的执行入口，来看下该函数：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; func runTests(matchString, tests []InternalTest, deadline time.Time) (ran, ok bool) {
     // 忽略掉控制运行次数的之类的代码
     // ignore the code controlling running times
     { // In loops.

             // ctx 用于进行并发控制
             // ctx is used to control parallel execution
             ctx := newTestContext(*parallel, newMatcher(matchString, *match, &quot;-test.run&quot;))
             ctx.deadline = deadline

             t := &amp;amp;T{
                 common: common{
                     signal:  make(chan bool),
                     barrier: make(chan bool),
                     w:       os.Stdout,
                 },
                 context: ctx,
             }
             if Verbose() {
                 t.chatty = newChattyPrinter(t.w)
             }

             tRunner(t, func(t *T) {
                 for _, test := range tests {
                     t.Run(test.Name, test.F)
                 }
                 // Run catching the signal rather than the tRunner as a separate
                 // goroutine to avoid adding a goroutine during the sequential
                 // phase as this pollutes the stacktrace output when aborting.
                 go func() { &amp;lt;-t.signal }()
             })
             ok = ok &amp;amp;&amp;amp; !t.Failed()
             ran = ran || t.ran
     }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;上述代码的重点有 3 个：&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;这里的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;，是整个 package 的最高级的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; 对象，其他的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 都是它的儿子。我们将这个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 称为 &lt;strong&gt;t0&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tRunner&lt;/code&gt; 函数是用于执行一个用例的，它的函数定义如下： &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func tRunner(t *T, fn func(t *T))&lt;/code&gt;，它的主要逻辑是用第一个参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 来执行第二个参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fn&lt;/code&gt;，然后在 defer 中处理 panic，以及并发控制等逻辑。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func (t *T) Run(name string, f func(t *T)) bool&lt;/code&gt; 函数表示将第二个参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 作为当前 receiver &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 的儿子用例来执行。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;因此，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runTests&lt;/code&gt; 的逻辑可以简述为：&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;先定义 &lt;strong&gt;t0&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;生成 &lt;strong&gt;t0&lt;/strong&gt; 对应的测试用例，就是：&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; func(t *T) {
     for _, test := range tests {
         t.Run(test.Name, test.F)
     }
     ...
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;这里的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tests&lt;/code&gt; 就是上面提到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestXxx&lt;/code&gt; 测试函数，即通常所说的测试用例。因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tRunner&lt;/code&gt; 主要逻辑就是调用这个匿名函数，因此在这个地方，就会一个接一个的执行测试文件中定义个的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestXxx&lt;/code&gt; 函数。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tRunner&lt;/code&gt; 执行 &lt;strong&gt;t0&lt;/strong&gt; 的测试用例。这里我可以先说一个&lt;strong&gt;结论&lt;/strong&gt;：如果没有调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Parallel()&lt;/code&gt;，那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Run()&lt;/code&gt; 的执行是阻塞的，会一直等到一个测试用例，即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestXxx&lt;/code&gt; 函数执行完成后才返回。&lt;strong&gt;所以，默认情况下，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go test&lt;/code&gt; 是串行的执行测试用例的&lt;/strong&gt;。为什么会这样等我们下面讲到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Run()&lt;/code&gt; 的实现时会再说。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;到这里，我们就了解了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go test&lt;/code&gt; 命令如何扫描测试代码，并且最终是如何调用我们的测试用例的。下面我们要分别看一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tRunner&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Run&lt;/code&gt; 这两个函数的实现细节。&lt;/p&gt;

&lt;h3 id=&quot;trunner&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tRunner&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func tRunner(t *T, fn func(t *T))&lt;/code&gt; 的基本结构如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func tRunner(t *T, fn func(t *T)) {
	defer func() {
		// handle panic

		defer func() {
			if didPanic {
				return
			}
			if err != nil {
				panic(err)
			}
			t.signal &amp;lt;- signal // 这个 signal 会让父用例的等待返回，见下文 t.Run 的说明。
		}()

		// handle subtests
		if len(t.sub) &amp;gt; 0 {
			// release 相当于释放一个锁，使得子用例可以执行。
			t.context.release()
			// 关闭这个 channel，表示当前用例的所有逻辑都处理完了，子用例可以开始执行。
			close(t.barrier)
			// 等待每个子用例执行完成。
			for _, sub := range t.sub {
				&amp;lt;-sub.signal
			}
		}
		...
	}()

	fn(t)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;整个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tRunner&lt;/code&gt; 函数的主要部分就两个，首先在函数内调用测试用例 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fn&lt;/code&gt;，然后在 defer 里处理 panic 以及等待子用例的完成。从上面的代码可以得到如下结论：&lt;strong&gt;父用例一定要先执行完，子用例才有机会执行&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;trun&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Run&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func (t *T) Run(name string, f func(t *T))&lt;/code&gt; 的基本结构如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (t *T) Run(name string f func(t *T)) bool {
	...

	// 生成一个新的 t，会集成父亲的`t.common` 部分。这里代码命名有些换乱，其实新的 t 称为 subt 更好。
	// 为了描述更清晰，我们统一使用 subt 这个名字来表示子用例。
	t = &amp;amp;T{
		common: common{
			barrier: make(chan bool),
			signal:  make(chan bool),
			name:    testName,
			parent:  &amp;amp;t.common,
			level:   t.level + 1,
			creator: pc[:n],
			chatty:  t.chatty,
		},
		context: t.context,
	}
	...
	go tRunner(t, f) // 使用 subt 来运行测试用例 f
	if !&amp;lt;-t.signal { // 等待 subt 执行完成
		runtime.Goexit()
	}
	return !t.failed
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Run&lt;/code&gt; 的主要逻辑就是生成一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subt&lt;/code&gt;，然后等待 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subt&lt;/code&gt; 执行完成。这里的等待分为两个情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;默认情况下，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subt&lt;/code&gt; 会在执行完成后才执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.signal &amp;lt;- signal&lt;/code&gt; 操作（见上一小节），所以此时这里是阻塞等待。上面我们也提到了，在最开始的时候，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runTests&lt;/code&gt; 函数里 &lt;strong&gt;t0&lt;/strong&gt; 对应的测试用例就是对每个用例调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Run&lt;/code&gt;，因此默认情况下，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runTests&lt;/code&gt; 是逐个执行用例的。&lt;/li&gt;
  &lt;li&gt;如果有用例调用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Parallel()&lt;/code&gt;，那么这里就会返回（详情见下一章）。所以如果一个 package 里每个用例都调用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Parallel()&lt;/code&gt;，那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runTests&lt;/code&gt; 里的 &lt;strong&gt;t0&lt;/strong&gt; 用例就会立刻返回。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来，我们看一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; 这个结构体：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type T struct {
	common
	isParallel bool
	context    *testContext // For running tests and subtests.
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你会发现，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Run&lt;/code&gt; 函数里，还有一个需要注意的地方，就是新建的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subt&lt;/code&gt; 没有继承父亲 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isParallel&lt;/code&gt; 的值，因此一个用例的所有子用例，默认是串行的。&lt;/p&gt;

&lt;h2 id=&quot;并行流程&quot;&gt;并行流程&lt;/h2&gt;

&lt;p&gt;Golang 在 1.7 版本增加了子用例的支持，同时也支持了用例的并行执行： &lt;em&gt;&lt;a href=&quot;https://blog.golang.org/subtests&quot;&gt;https://blog.golang.org/subtests&lt;/a&gt;&lt;/em&gt;. 官方的这篇 blog 有简述了并行的实现，现在我们从代码上来分析它是如何实现的。&lt;/p&gt;

&lt;p&gt;实现并行的关键就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Parallel&lt;/code&gt; 函数。上文我们提到，当父用例调用子用例时，即通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Run&lt;/code&gt; 方法来执行子用例时，默认情况下会阻塞在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;-subt.signal&lt;/code&gt; 这里。但是当子用例调用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Parallel&lt;/code&gt; 方法时，这里就会返回。我们可以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Parallel&lt;/code&gt; 的代码中看到相关逻辑：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (t *T) Parallel() {
    t.isParallel = true
	...
	// 将自己加入父亲的 sub 列表中。
    t.parent.sub = append(t.parent.sub, t)
	...

	// 这里直接写入成功，会使得 t.Run() 里的等待返回。
    t.signal &amp;lt;- true
	// 这里等待父用例调用 close(t.barrier)，上面提到了，这个会在 tRunner 的 defer 中调用。
    &amp;lt;-t.parent.barrier
	// 并发控制，通过这个来控制用例并发数。当并发数不够时，会一直阻塞在这里。
    t.context.waitParallel()

	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结合上文的相关信息，我们现在知道用例的并行执行是这样进行的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;父用例 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 的代码中会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Run&lt;/code&gt; 来执行子用例。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Run&lt;/code&gt; 内会生成子用例 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subt&lt;/code&gt;，然后调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tRunner&lt;/code&gt; 来执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subt&lt;/code&gt;，并且等待 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subt&lt;/code&gt; 执行完成(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;-subt.signal&lt;/code&gt;)。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subt&lt;/code&gt; 在执行的时候调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subt.Parallel()&lt;/code&gt;:
    &lt;ol&gt;
      &lt;li&gt;其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subt.signal &amp;lt;- true&lt;/code&gt; 会导致上面 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;-subt.signal&lt;/code&gt; 返回。&lt;/li&gt;
      &lt;li&gt;然后 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subt&lt;/code&gt; 会阻塞在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;-subt.parent.barrier&lt;/code&gt; 这里，等待父用例的函数返回（即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tRunner&lt;/code&gt; 里调用的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fn(t)&lt;/code&gt; 返回）。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;父用例 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 的函数执行完返回后，会在 defer 里 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close(t.barrier)&lt;/code&gt;，以便子用例执行。&lt;/li&gt;
  &lt;li&gt;父用例等待子用例执行完。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;重点强调一下，父用例调用子用例后，一定要返回，否则子用例无法执行。上述流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00032_golang_testing_parallel_1.png&quot; alt=&quot;golang_testing_parallel_1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;testifysuite-与并行&quot;&gt;testify/suite 与并行&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;github.com/stretchr/testify&lt;/strong&gt; 这个库提供了 suite 功能，可以让我们编写测试用例更加方便。当我们使用这个库时，我们一般是这么写的：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package somename

import (
	&quot;testing&quot;

	&quot;github.com/stretchr/testify/suite&quot;
)

func TestXxxSuite(t1 *testing.T) {
    suite.Run(t, new(xxxSuite))
}

type xxxSuite struct {
}

func (s *xxxSuite) SetupSuite() {
}

func (s *xxxSuite) TearDownSuite() {
}

func (s *xxxSuite) SetupTest() {
}

func (s *xxxSuite) TearDownTest() {
}

func (s *xxxSuite) TestCase1() {
	// t1sub1
}

func (s *xxxSuite) TestCase2() {
	// t1sub2
}

func TestYyySuite(t2 *testing.T) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们先来看一下 &lt;strong&gt;suite&lt;/strong&gt; 库执行用例的流程。在上文中，我们已经知道，整个 package 的用例执行入口是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runTests&lt;/code&gt; 函数，里面会生成顶级的 &lt;strong&gt;t0&lt;/strong&gt;。&lt;strong&gt;t0&lt;/strong&gt; 在执行时，就会对每个顶级的函数调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t0.Run()&lt;/code&gt; 方法，这个方法里会生成一个新的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subt&lt;/code&gt;，用于执行我们的顶级测试函数，在这里就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestXxxSuite&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestYyySuite&lt;/code&gt;，我们将这个 &lt;strong&gt;t0&lt;/strong&gt; 的儿子称为 &lt;strong&gt;t1&lt;/strong&gt; 和 &lt;strong&gt;t2&lt;/strong&gt;，分别对应 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestXxxSuite&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestYyySuite&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;接下来，我们来分析一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suite.Run&lt;/code&gt; 的实现，通过了解它的实现，我们可以知道 &lt;strong&gt;suite&lt;/strong&gt; 库是如何组织用例的。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suite.Run&lt;/code&gt; 的基本结构如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Run 函数属于 pacagek github.com/stretchr/suite
func Run(t *testing.T, suite TestingSuite) {

	// 扫描 suite 结构体，得到所有的以 Test 开头的方法，这些方法组成该 suite 下的所有用例。
	// 遍历每个方法，即每个测试用例
	for eachMethod {
		// 判断是否需要执行 SetupSuite 方法，这个方法对于整个 suite 只会执行一次。
		// 为当前正在处理的方法生成一个 testing.InternalTest 结构体，其中的成员 F 会调用测试用例对应的方法，F 的结构如下：
		// F {
		//	call SetupTest
		//	call BeforeTest
		//  call the method
		//  call AfterTest
		//  call TearDownTest
		// }
	}

	// 使用 t.Run 方法来执行刚才生成的所有测试用例，这里的 t 是对应 TestXxxSuite 函数
	// 等所有用例都返回（这里只是返回，并不是用例执行完，下面会详细说）
	// 执行 TearDownSuite
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Run&lt;/code&gt; 函数中，使用了前文提到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Run&lt;/code&gt; 方法来执行子用例，也就是说会生成下一层的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subt&lt;/code&gt;，例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1sub1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t2sub2&lt;/code&gt; 等，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00033_golang_testing_parallel_2.png&quot; alt=&quot;golang_testing_parallel_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在我们可以来分析一下使用 &lt;strong&gt;suite&lt;/strong&gt; 库时，如何进行并行测试。首先，串行的流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runTests&lt;/code&gt; 创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t0&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runTests&lt;/code&gt; 将每个顶级函数作为子用例来执行，生成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t2&lt;/code&gt; 等。&lt;/li&gt;
  &lt;li&gt;顶级函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestXxxSuite&lt;/code&gt; 调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suite.Run&lt;/code&gt; 函数，为一个 suite 中的每个方法生成一个子用例，然后执行所有的子用例。等待所有的子用例都执行之后，该顶级函数才返回。&lt;/li&gt;
  &lt;li&gt;继续执行下一个顶级函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestYyySuite&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总的来说，所有用例都是串行执行的，每次按照顺序执行一个 suite 内的所有用例。&lt;/p&gt;

&lt;p&gt;当我们考虑在这个流程中启用并行时，需要考虑如下几个方面的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个 suite 内的每个测试用例是共享同一个 suite 的内存的，所以如果在这些方法上开启并行，那么就得考虑对共享的内存进行保护。&lt;/li&gt;
  &lt;li&gt;如果在一个 suite 内的测试用例上启用并行，那么需要注意，属于其父用例的函数必须执行结束后，这些子用例才会开始执行。所以，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TearDownSuite&lt;/code&gt; 这个方法就会变成在所有的子用例执行之前就要执行完，这个有点违背接口的含义。&lt;/li&gt;
  &lt;li&gt;不同 suite 之间虽然没有共享 suite 结构体的内存，但是也可能共享其他的全局变量，这就需要业务代码进行一定的调整。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;综上所述，在使用 &lt;strong&gt;suite&lt;/strong&gt; 库时，如果要启用并行测试，一个比较可行的策略是： &lt;strong&gt;每个 suite 间启用并行，suite 内则使用串行&lt;/strong&gt;。具体做法可以参考下面这几个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suite.SetupSuite&lt;/code&gt; 内调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Parallel()&lt;/code&gt;，使得该 suite 进入并行状态。不过因为 parallel 设置是不传递给子用例的，所以该 suite 的所有子用例还是会串行执行。&lt;/li&gt;
  &lt;li&gt;如果被测试的代码共享了全局变量，那么需要修改被测试代码。&lt;/li&gt;
  &lt;li&gt;一个 suite 内的每个测试用例的配套方法（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SetupTest&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BeforeTest&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AfterTest&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TearDownTest&lt;/code&gt;）可以直接访问 suite 内存而不用加锁，因为 suite 内的每个用例都是串行执行的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;示例代码如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package somename

import (
	&quot;testing&quot;

	&quot;github.com/stretchr/testify/suite&quot;
)

func TestXxxSuite(t1 *testing.T) {
    suite.Run(t, new(xxxSuite))
}

type xxxSuite struct {
}

func (s *xxxSuite) SetupSuite() {
	// Let the suite running in parallel with other suites.
	s.T().Parallel()
}

func (s *xxxSuite) TearDownSuite() {
}

func (s *xxxSuite) SetupTest() {
	// visit fields of s
}

func (s *xxxSuite) TearDownTest() {
	// visit fields of s
}

func (s *xxxSuite) TestCase1() {
	// t1sub1
}

func (s *xxxSuite) TestCase2() {
	// t1sub2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 03 Aug 2021 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2021/08/03/golang-testing-parallel/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2021/08/03/golang-testing-parallel/</guid>
        
        <category>golang</category>
        
        
      </item>
    
      <item>
        <title>Postgres Logical Replication and CDC - 1</title>
        <description>&lt;p&gt;Postgres 作为目前最流行的数据库之一，自身也在不断的发展。从 Postgres 10 开始，它内置了逻辑复制功能。逻辑复制不仅可以实现更灵活的数据备份，也可以作为 &lt;strong&gt;CDC (Change Data Capture)&lt;/strong&gt; 架构的基础。&lt;/p&gt;

&lt;p&gt;As one of the most popular databases, Postgres itself is constantly evolving. Starting from Postgres 10, it has built-in logical replication. Logical replication can not only achieve more flexible data backup, but also serve as the basis of the CDC (Change Data Capture) architecture.&lt;/p&gt;

&lt;h2 id=&quot;历史&quot;&gt;历史&lt;/h2&gt;

&lt;p&gt;Postgres 对逻辑复制的支持经历了好几年的开发，主要由一家叫 &lt;strong&gt;2ndQuadrant&lt;/strong&gt; 的公司开发并且提交到 Postgres 的。&lt;/p&gt;

&lt;p&gt;Postgres’ support for logical replication has gone through several years of development, I think it mainly developed by a company called 2ndQuadrant and submitted to Postgres.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于 2ndQuadrant  的历史，请参考： &lt;em&gt;&lt;a href=&quot;https://en.everybodywiki.com/2ndQuadrant&quot;&gt;https://en.everybodywiki.com/2ndQuadrant&lt;/a&gt;&lt;/em&gt;。2ndQuadrant 在 2020 年 9 月被 EDB 公司收购： &lt;em&gt;&lt;a href=&quot;https://www.2ndquadrant.com/en/blog/how-edb-became-the-leader-in-the-postgres-market/&quot;&gt;https://www.2ndquadrant.com/en/blog/how-edb-became-the-leader-in-the-postgres-market/&lt;/a&gt;&lt;/em&gt;。
For the history of 2ndQuadrant, please refer to: &lt;em&gt;&lt;a href=&quot;https://en.everybodywiki.com/2ndQuadrant&quot;&gt;https://en.everybodywiki.com/2ndQuadrant&lt;/a&gt;&lt;/em&gt;. 2ndQuadrant was acquired by EDB in September 2020: &lt;em&gt;&lt;a href=&quot;https://www.2ndquadrant.com/en/blog/how-edb-became-the-leader-in-the-postgres-market/&quot;&gt;https://www.2ndquadrant.com/en/blog/how-edb-became-the-leader-in-the-postgres-market/&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;逻辑复制相关的功能主要是 2ndQuadrant 公司在开发自己的 &lt;strong&gt;Postgres-BDR&lt;/strong&gt; 产品时设计并开发的。BDR 是一个 Postgres 集群解决方案，在这个产品开发过程中，2ndQuadrant 产生了对逻辑复制的需求，那是在 Postgres 9.2 版本之前。这篇文章记录了 BDR 的开发历史， &lt;em&gt;&lt;a href=&quot;https://www.2ndquadrant.com/en/blog/bdr-history-and-future/&quot;&gt;https://www.2ndquadrant.com/en/blog/bdr-history-and-future/&lt;/a&gt;&lt;/em&gt;。逻辑复制的相关支持是慢慢提交到 Postgres 内核中的，从 9.2 版本增加对 trigger 的支持开始，9.4 版本支持 logical decoding，9.6 版本完成了所有的 logical decoding 必要 feature 的支持，10 版本开始支持 logical replication。整个过程是很漫长的。下图是 2ndQuadrant 提供的，描述了逻辑复制相关功能在 Postgres 上的演进。&lt;/p&gt;

&lt;p&gt;The functions related to logical replication are mainly designed and developed by 2ndQuadrant when developing its own Postgres-BDR product. BDR is a Postgres cluster solution. During this product development process, 2ndQuadrant generated a need for logical replication, which was before Postgres 9.2. This article records the development history of BDR, &lt;em&gt;&lt;a href=&quot;https://www.2ndquadrant.com/en/blog/bdr-history-and-future/&quot;&gt;https://www.2ndquadrant.com/en/blog/bdr-history-and-future/&lt;/a&gt;&lt;/em&gt;. The support for logical replication is slowly submitted to the Postgres kernel. Starting with the addition of trigger support in version 9.2, version 9.4 supports logical decoding, version 9.6 completes the support for all necessary features of logical decoding, and version 10 starts to support logical replication . The whole process is very long. The following figure is provided by 2ndQuadrant and describes the evolution of logical replication related functions on Postgres.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00031_infograph_bdr_1.png&quot; alt=&quot;infograph_bdr_1&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Picture from: &lt;em&gt;&lt;a href=&quot;https://www.2ndquadrant.com/wp-content/uploads/2016/10/infograph-bdr-1.png&quot;&gt;https://www.2ndquadrant.com/wp-content/uploads/2016/10/infograph-bdr-1.png&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;9.6 版本算是一个经典版本。在 9.6 版本发布了之后，BDR 可以在 Postgres 不打补丁的情况下就提供支持 （之前 9.4 版本需要打一个大 patch，&lt;em&gt;&lt;a href=&quot;https://www.2ndquadrant.com/en/blog/bdr-is-coming-to-postgresql-9-6/&quot;&gt;https://www.2ndquadrant.com/en/blog/bdr-is-coming-to-postgresql-9-6/&lt;/a&gt;&lt;/em&gt;）。&lt;/p&gt;

&lt;p&gt;The 9.6 version is considered a classic version. After the release of version 9.6, BDR can support Postgres without patching (previous version 9.4 requires a large patch, &lt;em&gt;&lt;a href=&quot;https://www.2ndquadrant.com/en/blog/bdr-is-coming- to-postgresql-9-6/&quot;&gt;https://www.2ndquadrant.com/en/blog/bdr-is-coming- to-postgresql-9-6/&lt;/a&gt;&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;此外，还有个扩展，叫做 pglogical。它是从 BDR 项目中剥离出来的，从 9.4 版本开始支持逻辑复制功能。虽然从 Postgres 10 版本开始，已经内置了逻辑复制，但是 pglogical 依旧继续在开发之中，主要的原因是 pglogical 作为一个扩展，可以更快的进行 feature 开发和升级。在这篇文章中，解释了为什么要把逻辑复制功能引入到 Postgres 中，以及为什么引入之后还继续开发 pglogical: &lt;em&gt;&lt;a href=&quot;https://www.2ndquadrant.com/en/blog/pglogical-logical-replication-postgresql-10/&quot;&gt;https://www.2ndquadrant.com/en/blog/pglogical-logical-replication-postgresql-10/&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;In addition, there is an extension called pglogical. It is stripped from the BDR project and supports the logical replication function since version 9.4. Although the logical replication has been built-in since Postgres 10, pglogical is still under development. The main reason is that pglogical, as an extension, can develop and upgrade features faster. This article explained why the logical replication function was introduced into Postgres, and why the development of pglogical was continued after the introduction: &lt;em&gt;&lt;a href=&quot;https://www.2ndquadrant.com/en/blog/pglogical-logical-replication-postgresql- 10/&quot;&gt;https://www.2ndquadrant.com/en/blog/pglogical-logical-replication-postgresql- 10/&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;可以这么认为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Postgres 9.4 ~ 9.6 版本，主要是引入了 logical decoding 功能，作为逻辑复制基础。&lt;/li&gt;
  &lt;li&gt;Postgres 10 版本引入的逻辑复制功能，也就是把 pglogical 的核心功能集成到 Postgres 里。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Think of it this way:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Postgres 9.4 ~ 9.6 version, mainly introduces the logical decoding function, as the basis of logical replication.&lt;/li&gt;
  &lt;li&gt;The logical replication function introduced in Postgres 10 version is to integrate the core function of pglogical into Postgres.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;logical-decoding&quot;&gt;Logical Decoding&lt;/h2&gt;

&lt;p&gt;Logical decoding 是 Postgres 9.4 引入的，通过看 9.4 版本的文档 &lt;em&gt;&lt;a href=&quot;https://www.postgresql.org/docs/9.4/logicaldecoding.html&quot;&gt;https://www.postgresql.org/docs/9.4/logicaldecoding.html&lt;/a&gt;&lt;/em&gt;，可以知道，从 9.4 版本开始 logical decoding 的功能就已经比较完善了。&lt;/p&gt;

&lt;p&gt;Logical decoding Postgres 9.4 is introduced, by the 9.4 version of the document &lt;em&gt;&lt;a href=&quot;https://www.postgresql.org/docs/9.4/logicaldecoding.html&quot;&gt;https://www.postgresql.org/docs/9.4/logicaldecoding.html&lt;/a&gt;&lt;/em&gt;, you can see that at version 9.4, logical decoding was almost fully functional.&lt;/p&gt;

&lt;p&gt;Logical decoding 的功能主要在 Postgres 内部提供了一种将数据库中的数据上所发生的改变的事件导出的手段。官方文档的原文是：&lt;/p&gt;

&lt;p&gt;The function of logical decoding mainly provides a means to export the events of changes in the data inside Postgres. The original text of the official document is:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;PostgreSQL provides infrastructure to stream the modifications performed via SQL to external consumers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;实现原理&quot;&gt;实现原理&lt;/h3&gt;

&lt;p&gt;它的根本原理是在数据库内部将 WAL 文件的内容按照一定的格式输出，事件输出的顺序等同于 WAL 的写入顺序（如果一个事件可以输出的话，否则该事件就会直接被忽略）。对于 Postgres 来说，实现 logical decoding 就是在 WAL flush 到磁盘之后，调用 replication slot 的指定的 plugin 的回调函数。官方文档解释了每个回调函数的作用: &lt;em&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/logicaldecoding-output-plugin.html&quot;&gt;https://www.postgresql.org/docs/current/logicaldecoding-output-plugin.html&lt;/a&gt;&lt;/em&gt;。在本文撰写的时候，Postgres 的最新版本是 13，14 版本正在开发中。从最新的代码中可以看到，在 14 版本中，Postgres 会开始支持未提交事务的逻辑复，所以 plugin 回调结构体 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct OutputPluginCallbacks&lt;/code&gt; 中增加了很多以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stream_&lt;/code&gt; 开头的回调函数。&lt;/p&gt;

&lt;p&gt;Its fundamental principle is to output the contents of the WAL file in a certain format within the database, and the sequence of event output is equivalent to the writing sequence of WAL (if an event can be output, otherwise the event will be ignored). For Postgres, implementing logical decoding is to call the callback functions of the specified plugin of the replication slot after the WAL flush to the disk. The official document explains the role of each callback function: &lt;em&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/logicaldecoding-output-plugin.html&quot;&gt;https://www.postgresql.org/docs/current/logicaldecoding-output-plugin.html&lt;/a&gt;&lt;/em&gt;. At the time of this writing, the latest version of Postgres is 13, and version 14 is under development. You can see from the latest code in version 14, Postgres will begin to support complex logic uncommitted transactions, so the plugin callback structure &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct OutputPluginCallbacks&lt;/code&gt; adds a lot of callback functions with the prefix &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stream_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Logical decoding 中有一个 &lt;strong&gt;logical replication slot&lt;/strong&gt; ( 简称 replication slot) 的概念。一个 replication slot 代表了一个事件输出流，用于将 WAL 记录的事件发送给订阅者。replication slot 主要功能有两个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用预先配置好的 output plugin 将 WAL 内容转换成输出格式。&lt;/li&gt;
  &lt;li&gt;维护需要使用的 WAL 位置，包括订阅者开始消费的位置，以及订阅者已经 flush 的位置（可以把订阅者当成一个备库，当备库向主库报告自己已经将某个位置之前的 WAL 都持久化之后，主库就可以将该位置之前的 WAL 文件回收了）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There is a concept of &lt;strong&gt;logical replication slot&lt;/strong&gt; (referred to as replication slot) in logical decoding. A replication slot represents an event output stream, used to send WAL recorded events to subscribers. There are two main functions of replication slot:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Use the pre-configured output plugin to convert WAL content into output format.&lt;/li&gt;
  &lt;li&gt;Maintain the WAL location that needs to be used, including the location where the subscriber starts to consume, and the location where the subscriber has been flushed (you can treat the subscriber as a standby database, when the standby database reports to the main database that it has persisted the WAL before a certain location, the main dastabase can reclaim the WAL file before the location).&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data=# select * from pg_replication_slots ;
  slot_name   |  plugin  | slot_type | datoid | database | temporary | active | active_pid | xmin | catalog_xmin | restart_lsn | confirmed_flush_lsn | wal_status | safe_wal_size
--------------+----------+-----------+--------+----------+-----------+--------+------------+------+--------------+-------------+---------------------+------------+---------------
   myslot     | pgoutput | logical   |  16384 | data     | f         | f      |            |      |          622 | 0/1765268   | 0/1765282           | reserved   |
(1 row)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里比较难理解的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restart_lsn&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;confirmed_flush_lsn&lt;/code&gt; 这两个列的值。&lt;/p&gt;

&lt;p&gt;Here it is difficult to understand &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restart_lsn&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;confirmed_flush_lsn&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;confirmed_flush_lsn&lt;/code&gt; 表示 consumer 已经收到并且回复确认的 WAL 的 LSN。早于该值的 WAL 无法再被 consumer 获取。这个值在 consumer 每次通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StandyStatusUpdate&lt;/code&gt; 消息更新时都会被修改。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;confirmed_flush_lsn&lt;/code&gt; means the address (LSN) up to which the logical slot’s consumer has confirmed receiving data. Data older than this is not available anymore. This value updated by each consumer’s StandyStatusUpdate message.&lt;/p&gt;

&lt;p&gt;官方文档对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restart_lsn&lt;/code&gt; 的描述就没有这么清晰了：&lt;/p&gt;

&lt;p&gt;Official document for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restart_lsn&lt;/code&gt; is not so clear:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The address (LSN) of oldest WAL which still might be required by the consumer of this slot and thus won’t be automatically removed during checkpoints unless this LSN gets behind more than max_slot_wal_keep_size from the current LSN. NULL if the LSN of this slot has never been reserved.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我在邮件列表里找到了几个相关的讨论，可能最有用的两个如下：&lt;/p&gt;

&lt;p&gt;I found some discussion about &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restart_lsn&lt;/code&gt;, the following two might be useful:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In general, the restart_lsn and confirmed_flush_lsn are advanced in different ways so you might see some difference but it should not be this much. The confirmed_flush_lsn is updated when we get confirmation from the downstream node about the flush_lsn but restart_lsn is only incremented based on the LSN required by the oldest in-progress transaction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;By Amit Kapila&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.postgresql.org/message-id/flat/CAFt1pcp5GGeJ1oVm6JZSzgptrRJ22FnfYqjoQPWgiss8HXzk4A%40mail.gmail.com#9f27f18a6302dc697a709f0a656f3548&quot;&gt;https://www.postgresql.org/message-id/flat/CAFt1pcp5GGeJ1oVm6JZSzgptrRJ22FnfYqjoQPWgiss8HXzk4A%40mail.gmail.com#9f27f18a6302dc697a709f0a656f3548&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;To make sure, replication delay or lag here is current_wal_lsn() - confirmed_flush_lsn. restart_lsn has nothing to do with replication lag. It is the minimum LSN the server thinks it needs for restarting replication on the slot.&lt;/p&gt;

  &lt;p&gt;How long have you observed the increase of the gap? If no long-transactions are running, restart_lsn is the current LSN about from 15 to 30 seconds ago. That is, the gap between restart_lsn and confirmed_flush_lsn would be at most the amount of WAL emitted in the last 30 seconds. In this case, that is estimated to be 235MB*30 = about 7GB or 440 in 16MB-segments even if the system is perfectly working. Anyway the publisher server would need to preserve WAL files up to about 68GB (in the case where checkpoint_timeout is 5 minutes) so requirement of 7GB by restart_lsn doesn’t matter.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;By Kyotaro Horiguchi&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.postgresql-archive.org/Replication-lag-due-to-lagging-restart-lsn-td6150451.html#a6150570&quot;&gt;https://www.postgresql-archive.org/Replication-lag-due-to-lagging-restart-lsn-td6150451.html#a6150570&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;从这两个逻辑复制的开发者的回复可以看出，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restart_lsn&lt;/code&gt; 的作用不是用来表示下游节点的复制延迟大小的，只是用来指导 master 何时可以删除 WAL 文件。主要的原因是 logical decoding 和 checkpoint 进程都涉及到何时删除 WAL 文件，因此系统需要考虑多个值来确认哪些 WAL 文件是可以回收的。 (&lt;em&gt;我在写这篇文章的时候，并没有阅读过 Postgres 的代码，所以我以上的结论是不准确的，也有可能是错误的。&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;From the threads of the these two developers of logical replications, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restart_lsn&lt;/code&gt; is not used to indicate replication delay, but to guide the main database when WAL files can be deleted. The main reason is that both logical decoding and checkpoint process involveed with WAL files deletion, so the system needs to consider multiple values to confirm which WAL files can be recycled. (When I was writing this article, I had not read the Postgres code, so my above conclusions are inaccurate and may be wrong. )&lt;/p&gt;

&lt;h3 id=&quot;output-plugin&quot;&gt;Output Plugin&lt;/h3&gt;

&lt;p&gt;Output plugin 是 logical decoding 里面决定输出格式的程序。这个 wiki 页面介绍了大部分的插: &lt;em&gt;&lt;a href=&quot;https://wiki.postgresql.org/wiki/Logical_Decoding_Plugins&quot;&gt;https://wiki.postgresql.org/wiki/Logical_Decoding_Plugins&lt;/a&gt;&lt;/em&gt;. 本章介绍几个主要的插件。&lt;/p&gt;

&lt;p&gt;Output plugin is the program that determines the output format in logical decoding. This wiki page introduces most of the plugins: &lt;em&gt;&lt;a href=&quot;https://wiki.postgresql.org/wiki/Logical_Decoding_Plugins&quot;&gt;https://wiki.postgresql.org/wiki/Logical_Decoding_Plugins&lt;/a&gt;&lt;/em&gt;. This chapter introduces several major plugins.&lt;/p&gt;

&lt;h4 id=&quot;test_decoding&quot;&gt;test_decoding&lt;/h4&gt;

&lt;p&gt;在 9.4 版本里，只有一个内置的 test_decoding 的插件 (*&lt;a href=&quot;https://www.postgresql.org/docs/9.4/test-decoding.html*&quot;&gt;https://www.postgresql.org/docs/9.4/test-decoding.html*&lt;/a&gt;)，它用于支持&lt;/p&gt;

&lt;p&gt;In version 9.4, there is only one built-in plugin named test_decoding (* https://www.postgresql.org/docs/9.4/test-decoding.html* ), which is used to support&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM pg_logical_slot_get_changes('test_slot', NULL, NULL, 'include-xids', '0');

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个插件的主要作用是提供一个简单的调试手段，同时作为其他插件开发的模板，并不适用于实现逻辑复制这样复杂的场景。这个插件的代码在: &lt;em&gt;&lt;a href=&quot;https://github.com/postgres/postgres/blob/master/contrib/test_decoding/test_decoding.c&quot;&gt;https://github.com/postgres/postgres/blob/master/contrib/test_decoding/test_decoding.c&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The main function of this plug-in is to provide a simple debugging method, and at the same time as a template for other plug-in development, it is not suitable for complex scenarios such as logical replication. The code for this plugin is at: &lt;em&gt;&lt;a href=&quot;https://github.com/postgres/postgres/blob/master/contrib/test_decoding/test_decoding.c&quot;&gt;https://github.com/postgres/postgres/blob/master/contrib/test_decoding/test_decoding.c&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;pglogical&quot;&gt;pglogical&lt;/h4&gt;

&lt;p&gt;由于 test_decoding 只是提供了一个实现参考，所以在还没有 pgoutput 插件的时候，pglogical 程序自己实现了一个 plugin (&lt;em&gt;&lt;a href=&quot;https://github.com/2ndQuadrant/pglogical/blob/REL2_x_STABLE/pglogical_output.c&quot;&gt;https://github.com/2ndQuadrant/pglogical/blob/REL2_x_STABLE/pglogical_output.c&lt;/a&gt;&lt;/em&gt;) 。&lt;/p&gt;

&lt;p&gt;Since test_decoding only provides an implementation reference, the pglogical program implements a plugin (&lt;em&gt;&lt;a href=&quot;https://github.com/2ndQuadrant/pglogical/blob/REL2_x_STABLE/pglogical_output.c&quot;&gt;https://github.com/2ndQuadrant/pglogical/blob/REL2_x_STABLE/pglogical_output.c&lt;/a&gt;&lt;/em&gt;) when there is no pgoutput plugin .&lt;/p&gt;

&lt;h4 id=&quot;wal2json&quot;&gt;wal2json&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/eulerto/wal2json&quot;&gt;https://github.com/eulerto/wal2json&lt;/a&gt;&lt;/em&gt; 这个插件是一个比较流行的插件，因为它的输出是 JSON 格式的，相当容易理解以及用程序解析。不过这个插件不是 Postgres 内置的，需要自己安装。但是由于其非常简单易用，有些云服务会在自己的 Postgres 服务中内置这个这个插件，例如 Azure (&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/postgresql/concepts-logical&quot;&gt;https://docs.microsoft.com/en-us/azure/postgresql/concepts-logical&lt;/a&gt;&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/eulerto/wal2json&quot;&gt;https://github.com/eulerto/wal2json&lt;/a&gt;&lt;/em&gt; This plug-in is a popular plugin because its output is in JSON format, which is quite easy to understand and parse with programs. But this plugin is not built-in Postgres, you need to install it yourself. But because it is very simple and easy to use, some cloud services will install this plugin in their Postgres service, such as Azure ( https://docs.microsoft.com/en-us/azure/postgresql/concepts-logical ).&lt;/p&gt;

&lt;h4 id=&quot;pgoutput&quot;&gt;pgoutput&lt;/h4&gt;

&lt;p&gt;在 Postgres 10 里，内置了一个 pgoutput 插件，为逻辑复制功能提供基础。pgoutput 实现了一个二进制协议，而且会在多个 Postgres 版本之间保持稳定（这样才能实现跨版本的逻辑复制）。这个协议属于 Postgres 后端协议的一部分，具体的协议定义见: &lt;em&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/protocol-logicalrep-message-formats.html&quot;&gt;https://www.postgresql.org/docs/current/protocol-logicalrep-message-formats.html&lt;/a&gt;&lt;/em&gt;。相比与 wal2json 这种文本格式的插件，pgoutput 插件的二进制协议的优点是性能好，缺点是较难解析。该插件的代码在: &lt;em&gt;&lt;a href=&quot;https://github.com/postgres/postgres/blob/master/src/backend/replication/pgoutput/pgoutput.c&quot;&gt;https://github.com/postgres/postgres/blob/master/src/backend/replication/pgoutput/pgoutput.c&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In Postgres 10, a pgoutput plug-in is built in to provide a basis for logical replication. pgoutput implements a binary protocol and will remain stable across multiple Postgres versions (so that it can achieve cross-version logical replication). This protocol is part of the Postgres backend protocol. For specific protocol definitions, please see: &lt;em&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/protocol-logicalrep-message-formats.html&quot;&gt;https://www.postgresql.org/docs/current/protocol-logicalrep-message-formats.html&lt;/a&gt;&lt;/em&gt;. Compared with the text format plug-in of wal2json, the binary protocol of the pgoutput plug-in has the advantage of good performance, but the disadvantage is that it is difficult to parse. The code of the plugin is at: &lt;em&gt;&lt;a href=&quot;https://github.com/postgres/postgres/blob/master/src/backend/replication/pgoutput/pgoutput.c&quot;&gt;https://github.com/postgres/postgres/blob/master/src/backend/replication/pgoutput/pgoutput.c&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;如果使用 Golang 进行开发，我已经在 &lt;strong&gt;github.com/jackc/pglogrepl&lt;/strong&gt; 这个库中增加了对 pgoutput 的支持 (&lt;em&gt;&lt;a href=&quot;https://github.com/jackc/pglogrepl/pull/14&quot;&gt;https://github.com/jackc/pglogrepl/pull/14&lt;/a&gt;&lt;/em&gt;)。你可以直接利用这个库中的 example 代码作为自己开发 subscriber 的基础： &lt;em&gt;&lt;a href=&quot;https://github.com/jackc/pglogrepl/tree/master/example/pglogrepl_demo&quot;&gt;https://github.com/jackc/pglogrepl/tree/master/example/pglogrepl_demo&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;If you use Golang development, I have adds support for the protocol in Github repo:  &lt;strong&gt;github.com/jackc/pglogrepl&lt;/strong&gt; (support for pgoutput of https://github.com/jackc/pglogrepl/pull/14 ). You can directly use the example code in this repo as the basis for your own development of subscribers:  &lt;em&gt;&lt;a href=&quot;https://github.com/jackc/pglogrepl/tree/master/example/pglogrepl_demo&quot;&gt;https://github.com/jackc/pglogrepl/tree/master/example/pglogrepl_demo&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;update&quot;&gt;Update&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Translate From Chinese to English with Google translate, then checking and editing.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 27 Jun 2021 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2021/06/27/postgres-logical-replication-and-cdc-part-1/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2021/06/27/postgres-logical-replication-and-cdc-part-1/</guid>
        
        <category>database</category>
        
        
      </item>
    
  </channel>
</rss>
