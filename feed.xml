<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coffee, Coke and Code</title>
    <description>Archive diabloneo&apos;s articles.
</description>
    <link>http://diabloneo.github.io//</link>
    <atom:link href="http://diabloneo.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 08 Nov 2022 21:37:39 +0800</pubDate>
    <lastBuildDate>Tue, 08 Nov 2022 21:37:39 +0800</lastBuildDate>
    <generator>Jekyll v4.3.1</generator>
    
      <item>
        <title>go-yaml 的默认 map 类型是 map[any]any</title>
        <description>&lt;p&gt;Go 语言的 yaml 库 &lt;em&gt;&amp;lt;github.com/go-yaml/yaml&amp;gt;&lt;/em&gt; 的默认 map 类型是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map[any]any&lt;/code&gt;，而不是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map[string]any&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;V2 代码：&lt;em&gt;&lt;a href=&quot;https://github.com/go-yaml/yaml/blob/v2/decode.go#L241&quot;&gt;https://github.com/go-yaml/yaml/blob/v2/decode.go#L241&lt;/a&gt;&lt;/em&gt;
V3 代码：&lt;em&gt;&lt;a href=&quot;https://github.com/go-yaml/yaml/blob/v3/decode.go#L334&quot;&gt;https://github.com/go-yaml/yaml/blob/v3/decode.go#L334&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;因此，当使用这个库对 yaml 内容进行 unmarshal 的时候，由 go-yaml 自动创建的 map 的类型是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map[any]any&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;fmt&quot;
	&quot;log&quot;

	&quot;gopkg.in/yaml.v2&quot;
)

var content = `
storage:
  settings:
    fs:
      ad:
        username: admin
      ldap:
        password: password

`

type Storage struct {
	Settings map[string]any `yaml:&quot;settings&quot;`
}

type Config struct {
	Storage *Storage `yaml:&quot;storage&quot;`
}

func main() {
	c := new(Config)
	err := yaml.Unmarshal([]byte(content), c)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf(&quot;%T\n&quot;, c.Storage.Settings[&quot;fs&quot;])
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码的输出是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;❯ go run testcmd.go
map[interface {}]interface {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 02 Nov 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/11/02/go-yaml-default-map-type-is-map-any-any/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/11/02/go-yaml-default-map-type-is-map-any-any/</guid>
        
        <category>golang</category>
        
        
      </item>
    
      <item>
        <title>GRUB2 menu and kernel-install</title>
        <description>&lt;h2 id=&quot;bls-boot-loader-specification&quot;&gt;BLS: Boot Loader Specification&lt;/h2&gt;

&lt;p&gt;在新的发行版上，普遍采用了 &lt;strong&gt;GRUB2&lt;/strong&gt; （以下简称 GRUB） 作为 boot loader。GRUB2 现在采用了 &lt;strong&gt;Boot Loader Specification&lt;/strong&gt; （简称 BLS） 来管理启动菜单： &lt;em&gt;&lt;a href=&quot;https://systemd.io/BOOT_LOADER_SPECIFICATION/&quot;&gt;https://systemd.io/BOOT_LOADER_SPECIFICATION/&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;在非 UEFI Secure 启动的情况下，启动菜单直接使用文本文件保存，方便维护。你可以在一个使用该标准的系统上查看这些文件，例如 Rocky Linux 8.5：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ll /boot/loader/entries/
total 12
-rw-r--r--. 1 root root 405 May 10 13:54 a0284538aa5b498cb38b8e530b2a6be4-0-rescue.conf
-rw-r--r--. 1 root root 353 May 10 13:54 a0284538aa5b498cb38b8e530b2a6be4-4.18.0-348.el8.0.2.x86_64.conf

# cat a0284538aa5b498cb38b8e530b2a6be4-4.18.0-348.el8.0.2.x86_64.conf
title Rocky Linux (4.18.0-348.el8.0.2.x86_64) 8.5 (Green Obsidian)
version 4.18.0-348.el8.0.2.x86_64
linux /vmlinuz-4.18.0-348.el8.0.2.x86_64
initrd /initramfs-4.18.0-348.el8.0.2.x86_64.img $tuned_initrd
options $kernelopts $tuned_params
id rocky-20211114010422-4.18.0-348.el8.0.2.x86_64
grub_users $grub_users
grub_arg --unrestricted
grub_class kernel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;machine-id&quot;&gt;Machine ID&lt;/h2&gt;

&lt;p&gt;Machine ID 是一个在系统安装的时候生成的 UUID，用于表示系统的唯一性。它存放在 &lt;em&gt;/etc/machine-id&lt;/em&gt; 文件中&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cat /etc/machine-id
a0284538aa5b498cb38b8e530b2a6be4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以查看 man 手册获取更多信息： &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;man machine-id&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;grub-菜单的生成&quot;&gt;GRUB 菜单的生成&lt;/h2&gt;

&lt;p&gt;GRUB 菜单是在 kernel 安装的时候生成的，在 kernel 卸载的时候删除的，这整个过程是由 &lt;strong&gt;kernel-install&lt;/strong&gt; 命令来完成的。在 RHEL 8 及衍生系统上，这个程序由 &lt;strong&gt;systemd-udev&lt;/strong&gt; 包来提供。&lt;/p&gt;

&lt;h3 id=&quot;kernel-install&quot;&gt;kernel-install&lt;/h3&gt;

&lt;p&gt;这个程序只有两个功能，添加内核，和删除内核：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# kernel-install --help
Usage:
        /usr/bin/kernel-install add KERNEL-VERSION KERNEL-IMAGE
        /usr/bin/kernel-install remove KERNEL-VERSION
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它本身是通过一系列的脚本来实现的，这些脚本存放在：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;/usr/lib/kernel/install.d/&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;/etc/kernel/install.d/&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认脚本存放在 &lt;em&gt;/usr/lib/kernel/install.d&lt;/em&gt; 目录下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@overlord-sz3 install.d]# cd /usr/lib/kernel/install.d/
[root@overlord-sz3 install.d]# ll
total 40
-rwxr-xr-x. 1 root root 7120 Nov 14  2021 20-grub.install
-rwxr-xr-x. 1 root root 2252 Nov  9  2021 20-grubby.install
-rwxr-xr-x. 1 root root  368 Jun 22  2018 50-depmod.install
-rwxr-xr-x. 1 root root 1657 Nov  9  2021 50-dracut.install
-rwxr-xr-x. 1 root root 3338 Nov  9  2021 51-dracut-rescue.install
-rwxr-xr-x. 1 root root  791 Oct 13  2021 60-kdump.install
-rwxr-xr-x. 1 root root 1975 Nov  9  2021 90-loaderentry.install
-rwxr-xr-x. 1 root root  989 Jul 22  2021 92-tuned.install
-rwxr-xr-x. 1 root root  454 Nov 14  2021 99-grub-mkconfig.install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这些都是 shell 脚本，主要是完成一些配置。例如 &lt;em&gt;20-grub.install&lt;/em&gt; 和 &lt;em&gt;90-loaderentry.install&lt;/em&gt; 这两个脚本就是完成 grub 相关的一些配置。&lt;/p&gt;

&lt;p&gt;另外，kernel-install 对于这些脚本返回值做了一个特殊的规定：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;An executable should return 0 on success. It may also return 77 to cause the whole operation to terminate (executables later in lexical order will be skipped).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以，如果一个脚本返回了 77，那么后续的都会被跳过。&lt;/p&gt;

&lt;h3 id=&quot;生成菜单的脚本&quot;&gt;生成菜单的脚本&lt;/h3&gt;

&lt;p&gt;在 RHEL 8 及其衍生系统中，默认安装的 kernel-install 脚本里有两个脚本会负责 GRUB 菜单的生成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;/usr/lib/kernel/install.d/20-grub.install&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;这个文件来自包 grub2-common-2.02-106.el8.0.2.noarch。&lt;em&gt;&lt;a href=&quot;https://git.rockylinux.org/staging/rpms/grub2/-/blob/r8/SOURCES/20-grub.install&quot;&gt;https://git.rockylinux.org/staging/rpms/grub2/-/blob/r8/SOURCES/20-grub.install&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;/usr/lib/kernel/install.d/90-loaderentry.install&lt;/em&gt;
    &lt;ul&gt;
      &lt;li&gt;这个文件来自包 systemd-udev-239-51.el8.x86_64。&lt;em&gt;&lt;a href=&quot;https://github.com/systemd/systemd/blob/v239-50/src/kernel-install/90-loaderentry.install&quot;&gt;https://github.com/systemd/systemd/blob/v239-50/src/kernel-install/90-loaderentry.install&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你观察上面所展示的菜单文件的内容，并且对比这两个脚本，那么你就会发现他们是由 &lt;em&gt;20-grub.install&lt;/em&gt; 这个文件生成的。为什么嗯？&lt;/p&gt;

&lt;p&gt;这个是两个脚本的实现问题，首先 &lt;em&gt;20-grub.install&lt;/em&gt; 脚本会被先执行，并且生成了 entries 目录中的文件。等到 &lt;em&gt;90-loaderentry.install&lt;/em&gt; 被执行时，它有一个判断如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ! [[ -d &quot;$BOOT_DIR_ABS&quot; ]]; then
    exit 0
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BOOT_DIR_ABS&lt;/code&gt; 如果不是一个目录，就不会执行。这个变量如何定义呢？它在这里定义：&lt;em&gt;&lt;a href=&quot;https://github.com/systemd/systemd/blob/v239-50/src/kernel-install/kernel-install#L92&quot;&gt;https://github.com/systemd/systemd/blob/v239-50/src/kernel-install/kernel-install#L92&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ! [[ $MACHINE_ID ]]; then
    BOOT_DIR_ABS=$(mktemp -d /tmp/kernel-install.XXXXX) || exit 1
    trap &quot;rm -rf &apos;$BOOT_DIR_ABS&apos;&quot; EXIT INT QUIT PIPE
elif [[ -d /efi/loader/entries ]] || [[ -d /efi/$MACHINE_ID ]]; then
    BOOT_DIR_ABS=&quot;/efi/$MACHINE_ID/$KERNEL_VERSION&quot;
elif [[ -d /boot/loader/entries ]] || [[ -d /boot/$MACHINE_ID ]]; then
    BOOT_DIR_ABS=&quot;/boot/$MACHINE_ID/$KERNEL_VERSION&quot;                           # ------------- This line
elif [[ -d /boot/efi/loader/entries ]] || [[ -d /boot/efi/$MACHINE_ID ]]; then
    BOOT_DIR_ABS=&quot;/boot/efi/$MACHINE_ID/$KERNEL_VERSION&quot;
elif mountpoint -q /efi; then
    BOOT_DIR_ABS=&quot;/efi/$MACHINE_ID/$KERNEL_VERSION&quot;
elif mountpoint -q /boot/efi; then
    BOOT_DIR_ABS=&quot;/boot/efi/$MACHINE_ID/$KERNEL_VERSION&quot;
else
    BOOT_DIR_ABS=&quot;/boot/$MACHINE_ID/$KERNEL_VERSION&quot;
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/boot/$MACHINE_ID/$KERNEL_VERSION&lt;/code&gt; 这个形式，是 BLS 规范定义的新的形式，即每个系统的启动项都放在自己的独立目录中。因为现在 RHEL 8 及其衍生版本还未用到这个规范，所以他们的 GRUB 菜单项就不是用 &lt;em&gt;90-loaderentry.install&lt;/em&gt; 这个脚本生成的。&lt;/p&gt;

&lt;h3 id=&quot;菜单文件&quot;&gt;菜单文件&lt;/h3&gt;

&lt;p&gt;一个菜单文件的规范涉及两个部分：文件名和内容。&lt;/p&gt;

&lt;p&gt;一般来说，文件名类似：&lt;em&gt;a0284538aa5b498cb38b8e530b2a6be4-4.18.0-348.el8.0.2.x86_64.conf&lt;/em&gt;。这个文件名主要的限制是必须跨系统唯一，所以一般使用如下格式: &lt;strong&gt;{machine_id}-{kernel_version}.conf&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文件的内容可能如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;title Rocky Linux (4.18.0-348.el8.0.2.x86_64) 8.5 (Green Obsidian)
version 4.18.0-348.el8.0.2.x86_64
linux /vmlinuz-4.18.0-348.el8.0.2.x86_64
initrd /initramfs-4.18.0-348.el8.0.2.x86_64.img $tuned_initrd
options $kernelopts $tuned_params
id rocky-20211114010422-4.18.0-348.el8.0.2.x86_64
grub_users $grub_users
grub_arg --unrestricted
grub_class kernel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每行第一个空格之前的就是 key，后面则是 value。其中，title 就是展示在菜单上的内容。这个 title 就是纯文本，所以你可以随意修改。&lt;/p&gt;

&lt;p&gt;从 &lt;em&gt;20-grub.install&lt;/em&gt; 文件可以看出，这里的 title 的内容会使用到来自 &lt;em&gt;/etc/os-release&lt;/em&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NAME&lt;/code&gt; 变量和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VERSION&lt;/code&gt; 变量。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cat /etc/os-release
NAME=&quot;Rocky Linux&quot;
VERSION=&quot;8.5 (Green Obsidian)&quot;
ID=&quot;rocky&quot;
ID_LIKE=&quot;rhel centos fedora&quot;
VERSION_ID=&quot;8.5&quot;
PLATFORM_ID=&quot;platform:el8&quot;
PRETTY_NAME=&quot;Rocky Linux 8.5 (Green Obsidian)&quot;
ANSI_COLOR=&quot;0;32&quot;
CPE_NAME=&quot;cpe:/o:rocky:rocky:8.5:GA&quot;
HOME_URL=&quot;https://rockylinux.org/&quot;
BUG_REPORT_URL=&quot;https://bugs.rockylinux.org/&quot;
ROCKY_SUPPORT_PRODUCT=&quot;Rocky Linux&quot;
ROCKY_SUPPORT_PRODUCT_VERSION=&quot;8&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grub_&lt;/code&gt; 开头的 key，是 GRUB 平台实现的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On grub platforms, the following grub-specific keywords have been implemented:
    &lt;ul&gt;
      &lt;li&gt;the BLS filename is also used for menuentry’s –id parameter, so you can use it in saved_entry&lt;/li&gt;
      &lt;li&gt;grub_hotkey - same as grub’s “–hotkey” menuentry parameter&lt;/li&gt;
      &lt;li&gt;grub_users - same as grub’s “–users” menuentry parameter; used for password protection&lt;/li&gt;
      &lt;li&gt;grub_class - same as grub’s “–class” menuentry paramter&lt;/li&gt;
      &lt;li&gt;grub_arg - passes extra arguments to menuentry&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些是兼容原来 GRUB 的参数：&lt;em&gt;&lt;a href=&quot;https://www.gnu.org/software/grub/manual/grub/grub.html#menuentry&quot;&gt;https://www.gnu.org/software/grub/manual/grub/grub.html#menuentry&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;默认启动项&quot;&gt;默认启动项&lt;/h3&gt;

&lt;p&gt;你可以使用 &lt;strong&gt;grub2-set-default&lt;/strong&gt; 命令修改默认的启动项。&lt;/p&gt;

&lt;p&gt;此外，我们还可以在安装了一个新的 kernel 之后，让 kernel-install 自动将这个新的 kernel 设置为默认 kernel。这个行为的配置，是在文件 &lt;em&gt;/etc/sysconfig/kernel&lt;/em&gt; 文件中控制的：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cat /etc/sysconfig/kernel
# UPDATEDEFAULT specifies if kernel-install should make
# new kernels the default
UPDATEDEFAULT=yes

# DEFAULTKERNEL specifies the default kernel package type
DEFAULTKERNEL=kernel-core
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个注释已经解释得很清楚了。这部分逻辑的实现，也是在 &lt;em&gt;20-grub.install&lt;/em&gt; 中实现的，调用的是 &lt;strong&gt;grub2-editenv&lt;/strong&gt; 命令：&lt;em&gt;&lt;a href=&quot;https://git.rockylinux.org/staging/rpms/grub2/-/blob/r8/SOURCES/20-grub.install#L134&quot;&gt;https://git.rockylinux.org/staging/rpms/grub2/-/blob/r8/SOURCES/20-grub.install#L134&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;顺便说一下，如果你安装的 kernel 采用了另外一个名字来打包，比如 elrepo  的 kernel-lt，那么修改 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DEFAULTKERNEL&lt;/code&gt; 这行即可。&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://fedoraproject.org/wiki/Changes/BootLoaderSpecByDefault&quot;&gt;https://fedoraproject.org/wiki/Changes/BootLoaderSpecByDefault&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;&lt;a href=&quot;https://systemd.io/BOOT_LOADER_SPECIFICATION/&quot;&gt;https://systemd.io/BOOT_LOADER_SPECIFICATION/&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 23 May 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/05/23/GRUB2-menu-and-kernel-install/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/05/23/GRUB2-menu-and-kernel-install/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>ISO9660 标准和 genisoimage 命令</title>
        <description>&lt;p&gt;当我们要定制一个 RHEL 及其衍生版的操作系统镜像时，我们会使用 &lt;strong&gt;genisoimage&lt;/strong&gt; 命令来生成最终的 ISO 文件。&lt;/p&gt;

&lt;p&gt;例如，我们基于 Rocky Linux 8.5 版本，定制了一个镜像后，最终我们会执行如下这条命令：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd rocky-linux-8-5-x86_64-dvd/
$ genisoimage -v -U -r -T -J -joliet-long \
  -V Rocky-8-5-x86_64-dvd -volset Rocky-8-5-x86_64-dvd -A Rocky-8-5-x86_64-dvd \
  -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table \
  -eltorito-alt-boot -e images/efiboot.img -no-emul-boot \
  -o ../NEWISO.iso
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这条命令参数很多，我们需要先了解和光盘有关的相关标准才能看懂这个命令。&lt;/p&gt;

&lt;h2 id=&quot;iso9660-及相关标准&quot;&gt;ISO9660 及相关标准&lt;/h2&gt;

&lt;p&gt;ISO9660 就是光盘文件系统的标准，意思就是如何在光盘上存储文件。更多信息可以查看 wiki 链接：&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;随着计算机行业的发展，原来的标准不太适用于新的需求，比如文件名字更长，目录层级更多等。所以业界也一直在扩充 ISO9660 的相关标准。这里我们说三个目前最常用的。&lt;/p&gt;

&lt;h3 id=&quot;rock-ridge&quot;&gt;Rock Ridge&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660#Rock_Ridge&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660#Rock_Ridge&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rock Ridge Interaction Protocol (RRIP)&lt;/strong&gt; 为光盘文件系统增加了 POSIX 文件系统语意。支持这个标准后，操作系统可以更好的跟光盘文件系统进行交互，比如支持更长的文件名，文件 mode, uid 等。&lt;/p&gt;

&lt;p&gt;这个标准的名字是一部电影里的虚构城镇的名字。电影的中文名字是：神枪小子。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fictional town Rock Ridge in Mel Brooks&apos; film Blazing Saddles.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;el-torito&quot;&gt;El Torito&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660#El_Torito&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660#El_Torito&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El Torito 是一个让 PC 可以从 CD-ROM 启动的标准。最初由 IBM 和 Phoenix Technologies （卖 BIOS 的厂商）制定，随后被所有 BIOS 支持。支持这个标准后，BIOS 除了可以加载硬盘上的启动代码，也可以加载光盘上的启动代码。&lt;/p&gt;

&lt;p&gt;据说这个名字是加州一家墨西哥餐馆的名字，这个标准是在这个餐馆里想出来的。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;El Torito restaurant in Irvine, California (33.684722°N 117.852547°W)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;joliet&quot;&gt;Joliet&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_9660#Joliet&quot;&gt;https://en.wikipedia.org/wiki/ISO_9660#Joliet&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这里由微软提出的标准。原来的标准对于光盘上的文件名字限制太死，比如长度、格式、不支持 Unicode 等，所以用这个标准扩展了一下，方便存放名字更复杂的文件。&lt;/p&gt;

&lt;h3 id=&quot;三个扩展标准的小结&quot;&gt;三个扩展标准的小结&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Standard&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Rock Ridge&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;让光盘文件系统更接近 POSIX 文件系统，操作系统可以更方便的访问。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;El Torito&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;让计算机可以从光盘启动。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Joliet&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;让光盘的文件名可以更复杂，符合现在的计算机系统中的文件名。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;genisoimage-命令的参数&quot;&gt;genisoimage 命令的参数&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ genisoimage -v -U -r -T -J -joliet-long \
  -V Rocky-8-5-x86_64-dvd -volset Rocky-8-5-x86_64-dvd -A Rocky-8-5-x86_64-dvd \
  -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table \
  -eltorito-alt-boot -e images/efiboot.img -no-emul-boot \
  -o ../NEWISO.iso
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这个命令的参数看起来很多，但是可以分组来看。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-v&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-o&lt;/code&gt; 参数比较简单，就不展开说了。&lt;/p&gt;

&lt;h3 id=&quot;和光盘的名字相关的&quot;&gt;和光盘的名字相关的&lt;/h3&gt;

&lt;p&gt;这些参数就是让光盘在系统上有一个友好的展示名字。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-A&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-appid&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;会被写入 volume header 的一个字符串，表示这个光盘中装载的应用程序，最多 128 字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-V&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;将 volume id 写入 master block，长度限制是 32 个字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-volset&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;设置 volume set id，长度限制是 128 字符。Volume set 相当于是一套光盘的意思，所以后续还可以设置当前光盘是一套光盘里的第几张光盘。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;joliet-标准相关&quot;&gt;Joliet 标准相关&lt;/h3&gt;

&lt;p&gt;这些参数用来控制光盘上的文件的文件名的限制，配置这些选项的目的就是尽量不限制文件名。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-J&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;生成 Joliet 目录记录。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-joliet-long&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;允许 Joliet 文件名的最大长度达到 103 个字符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-r&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-rational-rock&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;类似 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-R&lt;/code&gt;，生成 SUSP 和 RR 记录，但是 file ownership 会被设置为更有用的值，减少使用 ISO 的人需要处理的文件权限的问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-T&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-translation-table&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;在光盘的每个目录下都生成一个 &lt;em&gt;TRANS.TBL&lt;/em&gt; 的文件，用于帮助在不兼容 RR 标准的系统上使用正确的文件名来访问文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-U&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-untranslated-filenames&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;允许非转换的文件名，这会导致完全不兼容 ISO9660 标准。相当于开启了以下选项：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-d -l -N -allow-leading-dots -relaxed-filenames -allow-lowercase -allow-multidot -no-iso-translate&lt;/code&gt;，就是减少对文件名的限制。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;el-torito-标准相关&quot;&gt;El Torito 标准相关&lt;/h3&gt;

&lt;p&gt;这些参数是用来控制光盘作为启动盘是如何工作的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-b&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-eltorito-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定 El Torito 启动盘使用的启动文件。对于 legacy BIOS，这个就是 &lt;em&gt;isolinux.bin&lt;/em&gt; 文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eltorito-alt-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;开始一组新的 El Torito 启动参数的配置。一般一组用于 isolinux，一组用于 UEFI。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;以下几个参数是和 legacy BIOS 启动方式相关的&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-c&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-eltorito-catalog&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定 El Torito 的 boot catalog 文件的位置。启动需要这个文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-no-emul-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;用于 El Torito 的启动文件是一个非模拟镜像。系统会加载并且直接执行，而不会像使用一个硬盘一样，先通过分区表来查找启动分区。现在计算机都支持这种方式，通过这种方式，就不需要在一个启动文件里模拟硬盘的数据保存格式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-boot-load-size&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定在非模拟的情况下，load 的 virtual sector (512B) 数量。这里一般要求是 4 的倍数，否则在有些系统上无法工作。这个意思是启动的时候，在启动阶段，通过读取启动文件的这么多数据，就可以把控制权转给启动文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-boot-info-table&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;指定需要在 boot file offset 8 的位置插入一个 56 字节长的内容，这个插入的内容和光盘的 layout 信息有关，如下面所示。主要目的是为了在启动的过程中，找到 boot 文件的位置。&lt;/li&gt;
      &lt;li&gt;LBA：linear block address (given in CD sectors, normally 2048 bytes)。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;         Offset    Name           Size      Meaning
          8        bi_pvd         4 bytes   LBA of primary volume descriptor
         12        bi_file        4 bytes   LBA of boot file
         16        bi_length      4 bytes   Boot file length in bytes
         20        bi_csum        4 bytes   32-bit checksum
         24        bi_reserved    40 bytes  Reserved
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;以下几个参数是和 UEFI 启动方式相关的&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-e&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-efi-boot&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;EFI 启动文件的位置。UEFI 启动文件也需要指定 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-no-emul-boot&lt;/code&gt; 参数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;implantisomd5-命令&quot;&gt;implantisomd5 命令&lt;/h2&gt;

&lt;p&gt;将 ISO 的 md5sum 写入一个没有的 sector，以便随后使用 checkisomd5 命令进行校验。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ implantisomd5 Rocky-Linux-8.5-x86_64-dvd.iso
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;em&gt;checkisomd5&lt;/em&gt; 命令进行校验：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ checkisomd5 --verbose Rocky-Linux-8.5-x86_64-dvd.iso
Rocky-Linux-8.5-x86_64-dvd.iso:   e9ebe80ba90b67c1a4e3ccfd971bd86a
Fragment sums: 6ec3c854976341d15f5425ae13b7e16f5a7df75942a553adb6f29ba6798c
Fragment count: 20
Supported ISO: no
Press [Esc] to abort check.
Checking: 093.3%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 19 May 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/05/19/iso9660-and-genisoimage-command/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/05/19/iso9660-and-genisoimage-command/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>Linux Bridge VLAN Filter Command Explain</title>
        <description>&lt;p&gt;Linux bridge VLAN filter 功能使得 bridge 像一个真正的交换机一样来提供 VLAN 服务。本文解释 Linux &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bridge vlan&lt;/code&gt; 相关的一些命令。&lt;/p&gt;

&lt;h2 id=&quot;bridge-vlan-add&quot;&gt;bridge vlan add&lt;/h2&gt;

&lt;h3 id=&quot;access-port&quot;&gt;Access Port&lt;/h3&gt;

&lt;p&gt;如下图所示，我们要将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tap0&lt;/code&gt; 加入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;br0&lt;/code&gt;，然后要让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tap0&lt;/code&gt; 像一个 access port 一样工作。&lt;/p&gt;

&lt;p&gt;首先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip link set dev tap0 master br0&lt;/code&gt;。然后执行下图所示的命令，下图还说明了命令的每个部分分别表示什么含义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00037_linux_vlan_filter_1.png&quot; alt=&quot;linux_vlan_filter_add_command_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图所描述的行为，就是交换机上一个 access port 的行为。&lt;/p&gt;

&lt;h3 id=&quot;trunk-port&quot;&gt;Trunk Port&lt;/h3&gt;

&lt;p&gt;如下图所示，我们要将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bond0&lt;/code&gt; 加入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;br0&lt;/code&gt;，然后要让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bond0&lt;/code&gt; 像一个 trunk port 一样工作。&lt;/p&gt;

&lt;p&gt;首先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ip link set dev bond0 master br0&lt;/code&gt;。然后执行下图所示的命令，下图还说明了命令的每个部分分别表示什么含义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00038_linux_vlan_filter_2.png&quot; alt=&quot;linux_vlan_filter_add_command_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图所描述的行为，就是交换机上一个 trunk port 的行为。&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Apr 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/04/18/linux-vlan-filter-explain/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/04/18/linux-vlan-filter-explain/</guid>
        
        <category>linux</category>
        
        <category>network</category>
        
        
      </item>
    
      <item>
        <title>Dell XPS 9500 电源适配器无法识别的问题</title>
        <description>&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;我的 XPS 9500 是 2020 年买的，目前安装的是 Ubuntu 21.10 系统，最近出现了一次电源适配器无法识别的问题。现象是这样的：&lt;strong&gt;前一天正常待机，第二天恢复后，无法识别电源适配器，只能一直消耗电池的电量，直到耗尽关机&lt;/strong&gt;。之前，我的电脑也出现过在休眠时，直接掉电关机的情况，就像电源和电池同时拔掉的情况。看起来，应该是电脑本身的电源模块的问题。通过致电 Dell 技术支持，他们告知我这个是个系统电源管理模块的 bug，Dell 提供的故障描述如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;问题描述：xps 9500 type c充电器无法识别充电，dpm电池设置其他方式和关闭高级充电依旧，交换电脑三个type c口都无法识别充电，进入bios下也是一样无法识别电源适配器，没有其他的ac交换，一开始以为是ac 问题 ，后续客户自己重新到dpm检查开启的设置，发现dpm的峰值偏移功能开启影响了ac和电池的充电计划。&lt;/p&gt;

  &lt;p&gt;解决方法：后续遇到无法识别ac充电的情况，建议可以先到打开dell power manager，点击峰值偏移，关闭这个功能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;问题是由&lt;strong&gt;峰值偏移&lt;/strong&gt;这个功能引起的，解决办法有两个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Windows 系统可以使用 Power Manager 这个程序，关闭峰值偏移功能。&lt;/li&gt;
  &lt;li&gt;更新 BIOS。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我的故障和 Dell 提供的描述有一个地方不太一样，就是我的电池充电模式被我修改成了 &lt;strong&gt;Primarily AC Use&lt;/strong&gt;。在出现了无法识别电源适配器的问题后，我又改回了 &lt;strong&gt;Adaptive&lt;/strong&gt;，然后发现在 BIOS 中，电池可以开始充电了。此外，我记得我没有开启过峰值偏移功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00036_dell_xps9500_bios_power.jpg&quot; alt=&quot;dell_xps_9500_bios_power&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;dell-command-configure&quot;&gt;Dell Command Configure&lt;/h2&gt;

&lt;p&gt;因为我不是 Windows 系统，所以无法使用 Power Manager 这个程序。而且，我也不想升级 BIOS。国内的技术支持并不知道在 Ubuntu 系统下如何解决这个问题。经过搜索，我发现，Dell 自己是有个命令行程序支持在 Linux 下修改这些 BIOS 设置的，这个程序就是 &lt;strong&gt;Dell Command Configure&lt;/strong&gt;，下载路径如下： &lt;em&gt;&lt;a href=&quot;https://www.dell.com/support/kbdoc/zh-cn/000178000/dell-command-configure&quot;&gt;https://www.dell.com/support/kbdoc/zh-cn/000178000/dell-command-configure&lt;/a&gt;&lt;/em&gt;。Ubuntu 版本包含两个 dep 包，先安装 &lt;em&gt;srvadmin-hapi&lt;/em&gt;，再安装 &lt;em&gt;command-configure&lt;/em&gt;：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-r--r-- 1 diabloneo diabloneo 1696256 Sep 15 20:41 command-configure_4.6.0-277.ubuntu20_amd64.deb
-rw-r--r-- 1 diabloneo diabloneo  297940 Sep 15 20:41 srvadmin-hapi_9.5.0_amd64.deb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个命令的使用手册可以从这里下载： &lt;em&gt;&lt;a href=&quot;https://dl.dell.com/topicspdf/command-configure_users-guide4_en-us.pdf&quot;&gt;https://dl.dell.com/topicspdf/command-configure_users-guide4_en-us.pdf&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;使用这个命令关闭峰值偏移功能：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd /opt/dell/dcc
$ sudo ./cctk --PeakShiftCfg=Disabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不过，虽然我关闭了这个功能，但是并不知道这个问题是否还会再出现。&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Feb 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/02/10/Dell-XPS-9500-AC-power-adapter-not-regonized/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/02/10/Dell-XPS-9500-AC-power-adapter-not-regonized/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>jemalloc 3.6 版本导致的性能问题</title>
        <description>&lt;p&gt;最近我们有一个服务在测试过程中发现了性能问题，最终定位到是因为 jemalloc 使用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MADV_DONTNEED&lt;/code&gt; 导致的，这里分享一下定位过程。&lt;/p&gt;

&lt;h2 id=&quot;测试环境和问题描述&quot;&gt;测试环境和问题描述&lt;/h2&gt;

&lt;p&gt;测试程序通过网络接受 RPC 请求后，执行处理逻辑，程序运行环境如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CentOS 7.6 + kernel 3.10&lt;/li&gt;
  &lt;li&gt;程序运行在 docker 容器内&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Benchmark 过程很简单，就是通过客户端程序发起请求，然后看看测试过程能达到的服务带宽有多少。在获得结果后，我们发现，使用 jemalloc 的版本性能下降了差不多 20%（不过我们一开始并不知道是 jemalloc 导致的）。&lt;/p&gt;

&lt;h2 id=&quot;定位过程&quot;&gt;定位过程&lt;/h2&gt;

&lt;h3 id=&quot;获取-profile-数据生成火焰图&quot;&gt;获取 profile 数据，生成火焰图&lt;/h3&gt;

&lt;p&gt;这里使用 bcc 的 profile 工具来生成 profile stack 文件，然后使用 Brendan Gregg 的 FlameGraph 工具将其转换成火焰图 (&lt;em&gt;&lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot;&gt;https://github.com/brendangregg/FlameGraph&lt;/a&gt;&lt;/em&gt;)。&lt;/p&gt;

&lt;p&gt;Profile 命令如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# /usr/share/bcc/tools/profile -F 99 -f -a -p $PID 30 &amp;gt; profile.stack
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;FlameGraph 命令如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./flamegraph.pl profile.stack &amp;gt; profile.svg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;得到的火焰图中的关键部分如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00035_flame_graph_recvmsg_madvise.png&quot; alt=&quot;flame_graph_recvmsg_madvise&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图中可以看出两个奇怪的地方：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;有很多 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 调用。&lt;/li&gt;
  &lt;li&gt;收包的时候经常伴随着内存申请操作 (page_fault 的处理)。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;minor-page-fault-有多少&quot;&gt;minor page fault 有多少&lt;/h3&gt;

&lt;p&gt;因为从火焰图中看到了很多 page fault，所以可以通过其他工具来看一下 page fault 的类型和产生速率。因为我们的系统上是关闭了 swap 的，所以肯定都是 minor page fault，这里主要是要查看一下速率。可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sar&lt;/code&gt; 命令来查看：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sar -B 1
Linux 3.10.0-957.el7.x86_64 (node)   01/16/2022      _x86_64_        (40 CPU)

11:49:13 AM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff
11:49:14 AM      0.00    100.00 608239.00      0.00 869641.00      0.00      0.00      0.00      0.00
11:49:15 AM      0.00   3692.00 737822.00      0.00 971933.00      0.00      0.00      0.00      0.00
11:49:16 AM      0.00    104.00 466154.00      0.00 781245.00      0.00      0.00      0.00      0.00
11:49:17 AM      0.00    124.00 460824.00      0.00 769351.00      0.00      0.00      0.00      0.00
11:49:18 AM      0.00    136.00 510035.00      0.00 806849.00      0.00      0.00      0.00      0.00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以发现，每秒钟产生了 50w 次以上的 minor page fault。&lt;/p&gt;

&lt;h3 id=&quot;查看-socket-rmem-的使用情况&quot;&gt;查看 socket rmem 的使用情况&lt;/h3&gt;

&lt;p&gt;此外，因为是在收包的过程中发生了内存申请操作，我们还可以使用 sormem.bt 这个 bpftrace 程序 (&lt;em&gt;&lt;a href=&quot;https://github.com/brendangregg/bpf-perf-tools-book/blob/master/originals/Ch10_Networking/sormem.bt&quot;&gt;https://github.com/brendangregg/bpf-perf-tools-book/blob/master/originals/Ch10_Networking/sormem.bt&lt;/a&gt;&lt;/em&gt;) 来进行查看一下进程的 socket recv buffer 的情况：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./sormem.bt
Attaching 4 probes...
Tracing socket receive buffer size. Hit Ctrl-C to end.
^C

@rmem_alloc:
[0]                15638 |@                                                   |
[1]                    0 |                                                    |
[2, 4)                 0 |                                                    |
[4, 8)                 0 |                                                    |
[8, 16)                0 |                                                    |
[16, 32)               0 |                                                    |
[32, 64)               0 |                                                    |
[64, 128)              0 |                                                    |
[128, 256)             0 |                                                    |
[256, 512)             0 |                                                    |
[512, 1K)            699 |                                                    |
[1K, 2K)            1136 |                                                    |
[2K, 4K)          433243 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[4K, 8K)            7037 |                                                    |
[8K, 16K)           3750 |                                                    |
[16K, 32K)           219 |                                                    |
[32K, 64K)            18 |                                                    |
[64K, 128K)          191 |                                                    |
[128K, 256K)         200 |                                                    |
[256K, 512K)         118 |                                                    |
[512K, 1M)            19 |                                                    |
[1M, 2M)               2 |                                                    |
[2M, 4M)          192207 |@@@@@@@@@@@@@@@@@@@@@@@                             |
[4M, 8M)            8551 |@                                                   |

@rmem_limit:
[128K, 256K)        8580 |                                                    |
[256K, 512K)        6030 |                                                    |
[512K, 1M)             0 |                                                    |
[1M, 2M)           33400 |@@                                                  |
[2M, 4M)            7956 |                                                    |
[4M, 8M)          605235 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[8M, 16M)              0 |                                                    |
[16M, 32M)          1187 |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从 &lt;strong&gt;rmem_alloc&lt;/strong&gt; 的数据可以看出，服务端程序在 benchmark 过程中大量使用了小块的内存。不过，这个数据无法直接推导出一些结论，只能说这可能和内存管理的行为有关。&lt;/p&gt;

&lt;h3 id=&quot;查看-madvise-调用情况&quot;&gt;查看 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 调用情况&lt;/h3&gt;

&lt;p&gt;在查看了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 的 man 手册之后，我发现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 的参数选择对于程序的性能影响很大，所以我们需要知道这里执行的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 调用的参数是什么。这里我写了一个 bpftrace 的程序来获取程序调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 时使用的参数：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat trace_madvise.bt
#!/usr/bin/bpftrace

BEGIN
{
        printf(&quot;trace syscall madvise of pid %d\n&quot;, $1);
}

t:syscalls:sys_enter_madvise /pid == $1/
{
        printf(&quot;pid %d, comm %s, arg1 %lx, arg2 %ld, arg3 %ld\n&quot;, pid, comm, args-&amp;gt;start, args-&amp;gt;len_in, args-&amp;gt;behavior);
}

t:syscalls:sys_exit_madvise /pid == $1/
{
        printf(&quot;pid %d, comm %s, retval %d\n&quot;, pid, comm, args-&amp;gt;ret);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 benchmark 的过程中执行这个脚本，得到的结果主要内容如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pid 336963, comm cmdname, arg1 7fcd81dab000, arg2 1048576, arg3 4
pid 336963, comm cmdname, retval 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arg3 4&lt;/code&gt; 表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;advice&lt;/code&gt; 参数，这里 &lt;strong&gt;4&lt;/strong&gt; 对应的是 &lt;strong&gt;MADV_DONTNEED&lt;/strong&gt;。另外，我还统计了一下 benchmark 过程中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 调用的数量，达到了 22w 次。&lt;/p&gt;

&lt;h3 id=&quot;madv_dontneed-这个坑&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MADV_DONTNEED&lt;/code&gt; 这个坑&lt;/h3&gt;

&lt;p&gt;这个参数的行为很诡异，会直接导致 Linux 立刻回收内存，然后再次访问这块内存，会触发一个内存分配操作，它的行为基本上等于 free 了。man 手册中的关键内容如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;After a successful MADV_DONTNEED operation, the semantics of memory access in the specified region are changed: subsequent accesses of pages in the range will succeed, but will result in either repopulating the memory contents from the up-to-date contents of the underlying mapped file (for shared file mappings, shared anonymous mappings, and shmem-based techniques such as  System V shared memory segments) or zero-fill-on-demand pages for anonymous private mappings.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我去搜下了下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://youjiali1995.github.io/allocator/jemalloc-purge/&quot;&gt;jemalloc purge改进&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/6844904084957315086&quot;&gt;深入理解 Linux 内核–jemalloc 引起的 TLB shootdown 及优化&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;这里要提一下，我们的这个问题并没有 TLB shotdown。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/jemalloc/jemalloc/issues/1422&quot;&gt;madivse MADV_DONTNEED causes bad performence in KVM virtual machine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这个视频我更是强烈推荐，吐嘈之余，让你也能理解这个参数的历史： &lt;em&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=bg6-LVCHmGM&amp;amp;t=3518s&quot;&gt;https://www.youtube.com/watch?v=bg6-LVCHmGM&amp;amp;t=3518s&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;问题总结&quot;&gt;问题总结&lt;/h3&gt;

&lt;p&gt;了解了程序的行为以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise&lt;/code&gt; 这个坑之后，我们就可以得到这个性能问题的结论了： &lt;strong&gt;由于程序使用的 jemalloc 3.6 版本在运行过程中，大量调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;madvise(MADV_DONTNEED)&lt;/code&gt;，导致内存不断被 kernel 回收。因此，在收包的过程中只好又去申请新的内存，导致收包的性能下降&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;关闭-jemalloc-内存回收进行问题确认&quot;&gt;关闭 jemalloc 内存回收进行问题确认&lt;/h3&gt;

&lt;p&gt;可以通过如下的环境变量关闭 jemalloc 的内存回收机制，&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export MALLOC_CONF=&quot;lg_dirty_mult:-1&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个参数在 jemalloc 的如下代码路径上发挥作用：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 在 src/arena.c 中找到如下函数
static inline void
arena_maybe_purge(arena_t *arena)
{
        size_t npurgeable, threshold;

        /* Don&apos;t purge if the option is disabled. */
        if (opt_lg_dirty_mult &amp;lt; 0)
                return;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关闭内存回收之后，我们的程序就不再出现上述的性能问题。&lt;/p&gt;

&lt;h2 id=&quot;kernel-418-的对比测试&quot;&gt;Kernel 4.18 的对比测试&lt;/h2&gt;

&lt;p&gt;随后，我在 &lt;strong&gt;CentOS 7.6 + kernel 4.18&lt;/strong&gt;  的环境上也进行了 benchmark，发现在 kernel 4.18 上，程序的性能下降比较少，大概是 10%。随后写了一个 &lt;em&gt;trace_tcp_recvmsg_time.bt&lt;/em&gt; 的 bpttrace 程序，对比了一下两个版本的 kernel 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tcp_recvmsg&lt;/code&gt; 函数上的性能差异。&lt;/p&gt;

&lt;p&gt;程序如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@node tools]# cat calc_tcp_recvmsg_time.bt
#!/usr/bin/bpftrace

BEGIN
{
        printf(&quot;Calc tcp_recvmsg time of pid %d\n&quot;, $1);
}

kprobe:tcp_recvmsg /pid == $1/
{
        @start[tid] = nsecs;
}

kretprobe:tcp_recvmsg /pid == $1/
{
        if (@start[tid]) {
                @pf_nsecs = hist((nsecs - @start[tid]) / 1000);
                delete(@start[tid]);
        }
}

END
{
        print(@pf_nsecs);
        clear(@start);
        clear(@pf_nsecs);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Kernel 3.10 的结果&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Attaching 4 probes...
Calc tcp_recvmsg time of pid 366959
^C@pf_nsecs:
[1]                  327 |                                                    |
[2, 4)             53761 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      |
[4, 8)              7840 |@@@@                                                |
[8, 16)            39434 |@@@@@@@@@@@@@@@@@@@@@@                              |
[16, 32)            1685 |                                                    |
[32, 64)             223 |                                                    |
[64, 128)            229 |                                                    |
[128, 256)           126 |                                                    |
[256, 512)             9 |                                                    |
[512, 1K)          10484 |@@@@@                                               |
[1K, 2K)           92465 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[2K, 4K)               9 |                                                    |
[4K, 8K)               0 |                                                    |
[8K, 16K)              0 |                                                    |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Kernel 4.18 的结果&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Attaching 4 probes...
Calc tcp_recvmsg time of pid 20607
^C@pf_nsecs:
[0]                   23 |                                                    |
[1]                  274 |                                                    |
[2, 4)             32551 |@@@@@@@@@@@@@@@@                                    |
[4, 8)             52765 |@@@@@@@@@@@@@@@@@@@@@@@@@@                          |
[8, 16)            35111 |@@@@@@@@@@@@@@@@@                                   |
[16, 32)            1375 |                                                    |
[32, 64)             116 |                                                    |
[64, 128)             41 |                                                    |
[128, 256)            15 |                                                    |
[256, 512)            27 |                                                    |
[512, 1K)         103847 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[1K, 2K)           17881 |@@@@@@@@                                            |
[2K, 4K)               2 |                                                    |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;得到的结论是，kernel 4.18 在这个路径上的性能确实比 kernel 3.10 更好。不过，因为不能对 kernel 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_page_fault&lt;/code&gt; 函数进行 kprobe，所以不确定这里的性能改进是哪部分贡献的。&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Jan 2022 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2022/01/20/Performance-problem-caused-by-jemalloc-3.6/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2022/01/20/Performance-problem-caused-by-jemalloc-3.6/</guid>
        
        <category>linux</category>
        
        <category>kernel</category>
        
        <category>network</category>
        
        
      </item>
    
      <item>
        <title>CentOS 官方是如何编译一个包的</title>
        <description>&lt;p&gt;CentOS 是企业级开发里常用的 base 操作系统，很多时候，我们会先使用官方源里的包，随着业务的发展，我们会开始自己修改代码。这种时候，我们就希望可以编译出和 CentOS 官方一样的包。那么如何找到 CentOS  官方是如何编译包的呢？&lt;/p&gt;

&lt;h2 id=&quot;koji&quot;&gt;Koji&lt;/h2&gt;

&lt;p&gt;Koji 是 Fedora 平台用来编译 RPM 包和镜像的系统，CentOS/Rocky Linux 也都使用这个平台。这个 wiki 介绍了 Koji 的基本信息：&lt;em&gt;&lt;a href=&quot;https://fedoraproject.org/wiki/Koji&quot;&gt;https://fedoraproject.org/wiki/Koji&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;我们可以找到 CentOS Koji 的链接，然后通过 Koji 来找到我们需要的包的信息。&lt;/p&gt;

&lt;h2 id=&quot;如何找到-centos-8-官方编译-libvirt-的方案&quot;&gt;如何找到 CentOS 8 官方编译 libvirt 的方案&lt;/h2&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进入 Koji 的 build 页面：&lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/koji/builds&quot;&gt;https://koji.mbox.centos.org/koji/builds&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;在里面搜索 libvirt，找到 libvirt 有关的任务&lt;/li&gt;
  &lt;li&gt;找一个最新的：&lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/koji/buildinfo?buildID=19878&quot;&gt;https://koji.mbox.centos.org/koji/buildinfo?buildID=19878&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;进去之后，找到 task，然后进入 task：&lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/koji/taskinfo?taskID=310486&quot;&gt;https://koji.mbox.centos.org/koji/taskinfo?taskID=310486&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;因为会编译多个 arch 的包，所以还有子 task，我们可以进入 x86_64 的查看： &lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/koji/taskinfo?taskID=310489&quot;&gt;https://koji.mbox.centos.org/koji/taskinfo?taskID=310489&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;在这里就可以看到 build.log 的链接，点进去查看： &lt;em&gt;&lt;a href=&quot;https://koji.mbox.centos.org/pkgs/work/tasks/489/310489/build.log&quot;&gt;https://koji.mbox.centos.org/pkgs/work/tasks/489/310489/build.log&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在里面搜索 &lt;strong&gt;meson&lt;/strong&gt;，可以找到 meson 的参数，就知道 CentOS 8 官方如何编译 libvirt 库了：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ /usr/bin/meson --buildtype=plain --prefix=/usr --libdir=/usr/lib64 --libexecdir=/usr/libexec --bindir=/usr/bin --sbindir=/usr/sbin --includedir=/usr/include --datadir=/usr/share --mandir=/usr/share/man --infodir=/usr/share/info --localedir=/usr/share/locale --sysconfdir=/etc --localstatedir=/var --sharedstatedir=/var/lib --wrap-mode=nodownload --auto-features=enabled . x86_64-redhat-linux-gnu -Drunstatedir=/run -Ddriver_qemu=enabled -Ddriver_openvz=disabled -Ddriver_lxc=disabled -Ddriver_vbox=disabled -Ddriver_libxl=disabled -Dsasl=enabled -Dpolkit=enabled -Ddriver_libvirtd=enabled -Ddriver_remote=enabled -Ddriver_test=enabled -Ddriver_esx=enabled -Dcurl=enabled -Ddriver_hyperv=disabled -Dopenwsman=disabled -Ddriver_vmware=disabled -Ddriver_vz=disabled -Ddriver_bhyve=disabled -Ddriver_ch=disabled -Dremote_default_mode=legacy -Ddriver_interface=enabled -Ddriver_network=enabled -Dstorage_fs=enabled -Dstorage_lvm=enabled -Dstorage_iscsi=enabled -Dstorage_iscsi_direct=enabled -Dlibiscsi=enabled -Dstorage_scsi=enabled -Dstorage_disk=enabled -Dstorage_mpath=enabled -Dstorage_rbd=enabled -Dstorage_sheepdog=disabled -Dstorage_gluster=enabled -Dglusterfs=enabled -Dstorage_zfs=disabled -Dstorage_vstorage=disabled -Dnumactl=enabled -Dnumad=enabled -Dcapng=enabled -Dfuse=disabled -Dnetcf=enabled -Dselinux=enabled -Dselinux_mount=/sys/fs/selinux -Dapparmor=disabled -Dapparmor_profiles=disabled -Dsecdriver_apparmor=disabled -Dudev=enabled -Dyajl=enabled -Dsanlock=enabled -Dlibpcap=enabled -Dlibnl=enabled -Daudit=enabled -Ddtrace=enabled -Dfirewalld=enabled -Dfirewalld_zone=enabled -Dwireshark_dissector=enabled -Dlibssh=enabled -Dlibssh2=disabled -Dpm_utils=disabled -Dnss=enabled &apos;-Dpackager=CentOS Buildsys &amp;lt;bugs@centos.org&amp;gt;, 2021-11-09-20:38:08, &apos; -Dpackager_version=1.module_el8.6.0+983+a7505f3f -Dqemu_user=qemu -Dqemu_group=qemu -Dtls_priority=@LIBVIRT,SYSTEM -Dwerror=true -Dexpensive_tests=enabled -Dinit_script=systemd -Ddocs=enabled -Dtests=enabled -Drpath=disabled -Dlogin_shell=disabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在里面搜索 &lt;strong&gt;rpmbuild&lt;/strong&gt; 就可以知道它用什么命令打包的了。&lt;/p&gt;

&lt;p&gt;同样的，Fedora 和 Rocky Linux 也可以用这个方法找到他们的打包细节。&lt;/p&gt;
</description>
        <pubDate>Tue, 07 Dec 2021 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2021/12/07/How-CentOS-build-rpm-packages/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2021/12/07/How-CentOS-build-rpm-packages/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>Golang time 库里的一个矛盾实现</title>
        <description>&lt;p&gt;Golang &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.Now()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.Parse()&lt;/code&gt; 两个函数对于 location 处理上是不一致的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.Parse()&lt;/code&gt; 方法在生成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Time&lt;/code&gt; 对象时，可能会调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setLoc&lt;/code&gt; 方法，用于设置时区信息。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setLoc&lt;/code&gt; 方法，以及相关的其他方法都有一个特殊处理，就是将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Time.loc == nil&lt;/code&gt; 这个条件等同于 UTC 时区，例如下列代码：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// setLoc sets the location associated with the time.
func (t *Time) setLoc(loc *Location) {
	if loc == &amp;amp;utcLoc {
		loc = nil
	}
	t.stripMono()
	t.loc = loc
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.Now()&lt;/code&gt; 方法并不是这么处理的，无论时区如何，它都会为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Time.loc&lt;/code&gt; 赋值，如下所示：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Now returns the current local time.
func Now() Time {
	sec, nsec, mono := now()
	mono -= startNano
	sec += unixToInternal - minWall
	if uint64(sec)&amp;gt;&amp;gt;33 != 0 {
		return Time{uint64(nsec), sec + minWall, Local}
	}
	return Time{hasMonotonic | uint64(sec)&amp;lt;&amp;lt;nsecShift | uint64(nsec), mono, Local}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;于是，&lt;strong&gt;当你的程序运行在一个 UTC 时区的 Linux 系统上时，就会出现如下矛盾的现象：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.Now()&lt;/code&gt; 返回的值里, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loc&lt;/code&gt; 成员是有值的，但是用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.Parse()&lt;/code&gt; 去解析一个时间字符串时，得到的值里，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loc&lt;/code&gt; 成员可能是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;&lt;/strong&gt;。这个矛盾会导致一些比较代码失败（直接用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt; 比较），因为其中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loc&lt;/code&gt; 字段的值不一致。当然，官方文档也提到了这一点，&lt;strong&gt;所以比较时间还是应该用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Time.Equal()&lt;/code&gt; 方法&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果需要在这种情况下，为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parse()&lt;/code&gt; 得到的时间附上一个时区信息，得到和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Now()&lt;/code&gt; 一样的效果，可以使用如下的函数实现：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// parseTime calls time.Parse and set location if time.Local is UTC.
//
// time.Parse function will call Time.setLoc method which set Time.loc = nil
// if location is UTC. But on a machine with UTC timezone, time.Now() returns
// a Time value with Time.loc set to utcLoc, so it&apos;s not nil. The two methods
// result in discrepancy in time.Time values.
func parseTime(layout, value string) (time.Time, error) {
	t, err := time.Parse(layout, value)
	if err != nil {
		return time.Time{}, err
	}
	if _, offset := t.Zone(); offset == 0 {
		return t.Local(), nil
	}
	return t, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 20 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2021/10/20/Contradictory-implementation-in-Golang-time-library/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2021/10/20/Contradictory-implementation-in-Golang-time-library/</guid>
        
        <category>golang</category>
        
        
      </item>
    
      <item>
        <title>对程序员来说，速度是重要的</title>
        <description>&lt;p&gt;对于一个程序员来说，开发的速度是重要的。为什么呢？&lt;/p&gt;

&lt;p&gt;在说明原因之前，要先澄清下我说的开发速度包括哪些方面。&lt;strong&gt;开发速度，并不是仅仅指敲用键盘输入代码，而包括更大范围的一些操作&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;操作 IDE 的速度，就是使用 IDE 的熟练程度。&lt;/li&gt;
  &lt;li&gt;操作终端的速度。例如快速的跳转位置，快速的查找命令历史等。&lt;/li&gt;
  &lt;li&gt;操作 git 的速度。快速的切换分支，快速的 merge 或者 rebase 等。&lt;/li&gt;
  &lt;li&gt;使用操作系统的速度。例如快速找到一堆浏览器标签页中你需要的那个。&lt;/li&gt;
  &lt;li&gt;搭建最基础开发环境的速度。例如你用 Python，要能快速的搭建一个 Virtualenv ；或者你用 Go，要能快速的写好一个 go.mod，然后 download 所有依赖。最基础的开发环境往往用来写一些非常简短的测试代码，显然，搭建基础开发环境的时候不应该比写这个简短测试代码的时间长。&lt;/li&gt;
  &lt;li&gt;找到所需文档的速度，不只是 Google，还包括在你的团队所使用的 wiki 系统。&lt;/li&gt;
  &lt;li&gt;使用最基本的 shell 工具的速度，包括但不限于 find， grep，awk，wc 等。这些工具一般用来快速的找到文件或者快速的找到想要的内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面提到的这些操作，只要经过专门训练，都能大幅提升操作速度（也可以说是熟练度）。&lt;/p&gt;

&lt;p&gt;为什么程序员需要在上面列出的这些事情上追求速度呢？功利的说，上面这些事情，并不直接帮你赚钱，所以花的时间越多，你用来赚钱的时间就越少。但是，从成就感的角度来找这个问题的答案，会让我们更加愉悦：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你可以有更多的时间来思考那些直接产生价值的代码，这有助于写出更好的代码，以及做出更好的产品。&lt;/li&gt;
  &lt;li&gt;你的工作过程看起来会更炫酷。谁不爱呢。&lt;/li&gt;
  &lt;li&gt;你会更擅长排查环境导致问题，也更不容易造成这样的问题。&lt;/li&gt;
  &lt;li&gt;有更多的时间享受创造的快乐，而不是陷在问题的泥潭之中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总而言之，会编程成为一件快乐的事情。&lt;/p&gt;

&lt;p&gt;不过，当你变得很快时，可能会产生一个副作用：你会对同事变得缺乏耐心，并且不乐于帮助他们。如果你能解决这个副作用，那么你可以收获更多的东西。&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2021/10/11/Be-fast-do-matter-for-programmer/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2021/10/11/Be-fast-do-matter-for-programmer/</guid>
        
        <category>programming</category>
        
        
      </item>
    
      <item>
        <title>getaddrinfo 中最长前缀匹配实现导致的DNS 负载均衡失效</title>
        <description>&lt;h1 id=&quot;dns-负载均衡方案的失效&quot;&gt;DNS 负载均衡方案的失效&lt;/h1&gt;

&lt;p&gt;通过 DNS 实现负载均衡是一种常见的方案。这种方案通常会返回多个 A 记录，客户端会按照 DNS 响应中的顺序依次尝试去连接服务器，直到成功为止。这个方案对于客户端是有要求的，即客户端必须严格按照 DNS 响应中的地址顺序来访问服务器。在一段不算短的时间以前，大概是 Linux 还未成熟的时候，很多应用还是使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt; 来进行 DNS 解析。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt; 接口会严格返回 DNS 响应中的地址顺序，因此应用使用一个循环来进行连接尝试时，就达到了负载均衡的目的。但是，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 接口被实现，并且被推荐用来替代 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt; 之后，这个情况就变了。原因是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 会实现 &lt;strong&gt;RFC 3484 (Default Address Selection for Internet Protocol version 6 (IPv6))&lt;/strong&gt; 中的地址选择功能，其中的&lt;strong&gt;目标地址选择功能&lt;/strong&gt;直接导致了 DNS 负载均衡方案的失效。简单的说，目标地址选择功能会修改返回给应用程序的 DNS 地址记录的顺序，导致应用程序是按照目标地址选择功能决定的顺序，而不是 DNS 服务器决定的顺序来访问服务器。会导致地址返回顺序被修改的场景很多，本文会描述一种我觉得最常见的失效场景。&lt;/p&gt;

&lt;h1 id=&quot;失效场景与-ip-地址的选择有关&quot;&gt;失效场景：与 IP 地址的选择有关&lt;/h1&gt;

&lt;p&gt;失效的场景设置如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://diabloneo.github.io//assets/imgs/00034_dns_and_getaddrinfo.png&quot; alt=&quot;getaddrinfo_and_dns&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个业务的流程是这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;某个业务有一个客户端，以及三台服务器。采用 DNS 负载均衡方案，让客户端按照一定的比例将请求转发到三个服务器上。&lt;/li&gt;
  &lt;li&gt;客户端需要通过内部的 DNS 服务器来解析域名，获得可以访问的服务器地址。在实现上，从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 返回的第一个地址开始尝试。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;DNS 服务器返回的其中一个 DNS 响应如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;test.dom.               3600    IN      A       192.168.192.128
test.dom.               3600    IN      A       192.168.192.127
test.dom.               3600    IN      A       192.168.192.129
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为我们采用了负载均衡的策略，所以返回的 DNS 响应，每次都会重新排列所有的地址，保证每个地址出现在第一条的概率基本一样。所以，实际上有 6 中排列组合方式。&lt;/p&gt;

&lt;p&gt;客户端也有一个同网段的地址：&lt;strong&gt;192.168.192.121&lt;/strong&gt;。所有这些地址，都属于 &lt;em&gt;192.168.192.0/24&lt;/em&gt; 这个子网。如本章的标题所示，这些地址的选择是非常重要的，&lt;strong&gt;就是地址的值导致了 DNS 负载均衡的失效&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在这个场景中，我们发现我们的客户端程序每次都是去连接 &lt;strong&gt;192.168.192.127&lt;/strong&gt; 这个地址，从来不使用其他两个地址，不管这个 &lt;em&gt;192.168.192.127&lt;/em&gt; 的地址是出现在响应中的哪个位置。&lt;/p&gt;

&lt;h1 id=&quot;问题定位与分析&quot;&gt;问题定位与分析&lt;/h1&gt;

&lt;p&gt;我们首先排除了 DNS 服务器的问题，以及客户端实现的问题。所以，问题出现在 DNS 请求成功后，到将地址列表返回给客户端程序之前。为了简化问题定位，我们发现 ping 程序也遇到了同样的问题，即 ping 这个域名，都只会使用 &lt;em&gt;192.168.192.127&lt;/em&gt; 这个地址。&lt;/p&gt;

&lt;h2 id=&quot;使用-strace-命令来分析问题&quot;&gt;使用 strace 命令来分析问题&lt;/h2&gt;

&lt;p&gt;我们先使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strace ping -c 1 test.dom&lt;/code&gt; 命令来看看程序到底做了什么。下面是其中的相关内容（为了好看，我删掉了不相关的内容。另外，如果你想看到更多的参数信息，可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strace&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-s&lt;/code&gt; 参数）：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 先连接 DNS 服务器，发出 DNS 请求，并且收到响应。
socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC|SOCK_NONBLOCK, IPPROTO_IP) = 4
connect(4, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;192.168.192.132&quot;)}, 16) = 0
sendto(4, &quot;\272\273\1\0\0\1\0\0\0\0\0\0\4test\3dom\0\0\1\0\1&quot;, 26, MSG_NOSIGNAL, NULL, 0) = 26
recvfrom(4, &quot;\272\273\205\0\0\1\0\3\0\1\0\0\4test\3dom\0\0\1\0\1\4test\3&quot;..., 1024, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;192.168.192.132&quot;)}, [16]) = 121
close(4)                                = 0

# 尝试打开这个文件，见下文。
open(&quot;/etc/gai.conf&quot;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)

# 通过 NETLINK 获取一些接口信息 (getifaddrs)
socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE) = 4
bind(4, {sa_family=AF_NETLINK, pid=0, groups=00000000}, 12) = 0
getsockname(4, {sa_family=AF_NETLINK, pid=217030, groups=00000000}, [12]) = 0
sendto(4, &quot;\24\0\0\0\26\0\1\3\312W`a\0\0\0\0\0\0\0\0&quot;, 20, 0, {sa_family=AF_NETLINK, pid=0, groups=00000000}, 12) = 20
recvmsg(4, {msg_name(12)={sa_family=AF_NETLINK, pid=0, groups=00000000}, msg_iov(1)=[{&quot;L...
recvmsg(4, {msg_name(12)={sa_family=AF_NETLINK, pid=0, groups=00000000}, msg_iov(1)=[{&quot;H
recvmsg(4, {msg_name(12)={sa_family=AF_NETLINK, pid=0, groups=00000000}, msg_iov(1)=[{&quot;...

# 尝试连接 DNS 返回的每个地址，判断是否可用。这里用的是 UDP，所以主要是判断路由是否可达。
socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC, IPPROTO_IP) = 4
connect(4, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&quot;192.168.192.128&quot;)}, 16) = 0
getsockname(4, {sa_family=AF_INET, sin_port=htons(58008), sin_addr=inet_addr(&quot;192.168.192.121&quot;)}, [16]) = 0
connect(4, {sa_family=AF_UNSPEC, sa_data=&quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;}, 16) = 0
connect(4, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&quot;192.168.192.127&quot;)}, 16) = 0
getsockname(4, {sa_family=AF_INET, sin_port=htons(44743), sin_addr=inet_addr(&quot;192.168.192.121&quot;)}, [16]) = 0
connect(4, {sa_family=AF_UNSPEC, sa_data=&quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;}, 16) = 0
connect(4, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&quot;192.168.192.129&quot;)}, 16) = 0
getsockname(4, {sa_family=AF_INET, sin_port=htons(35095), sin_addr=inet_addr(&quot;192.168.192.121&quot;)}, [16]) = 0

# 开始连接 192.168.192.127。注意到，从上面到这里，没有任何系统调用，所以这里是一段完全由代码和内存数据决定的逻辑。
socket(AF_INET, SOCK_DGRAM, IPPROTO_IP) = 4
connect(4, {sa_family=AF_INET, sin_port=htons(1025), sin_addr=inet_addr(&quot;192.168.192.127&quot;)}, 16) = 0
getsockname(4, {sa_family=AF_INET, sin_port=htons(34211), sin_addr=inet_addr(&quot;192.168.192.121&quot;)}, [16]) = 0
setsockopt(3, SOL_RAW, ICMP_FILTER, ~(1&amp;lt;&amp;lt;ICMP_ECHOREPLY|1&amp;lt;&amp;lt;ICMP_DEST_UNREACH|1&amp;lt;&amp;lt;ICMP_SOURCE_QUENCH|1&amp;lt;&amp;lt;ICMP_REDIRECT|1&amp;lt;&amp;lt;ICMP_TIME_EXCEEDED|1&amp;lt;&amp;lt;ICMP_PARAMETERPROB), 4) = 0
setsockopt(3, SOL_IP, IP_RECVERR, [1], 4) = 0
setsockopt(3, SOL_SOCKET, SO_SNDBUF, [324], 4) = 0
setsockopt(3, SOL_SOCKET, SO_RCVBUF, [65536], 4) = 0
getsockopt(3, SOL_SOCKET, SO_RCVBUF, [131072], [4]) = 0
PING test.dom (192.168.192.127) 56(84) bytes of data.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面的代码中，我注释了关键的部分。最后，我们可以发现，导致问题的代码是在尝试 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect&lt;/code&gt; 之后，以及应用开始使用 IP 地址之前的部分，也就是说，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 导致的问题。但是，为什么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 这个函数会有这个问题？理论上来说，一个广泛使用的库函数，应该是很稳定的。此时，我注意到了上面的 &lt;strong&gt;/etc/gai.conf&lt;/strong&gt; 这个文件。&lt;/p&gt;

&lt;h2 id=&quot;getaddrinfo-与-rfc-3484&quot;&gt;getaddrinfo 与 RFC 3484&lt;/h2&gt;

&lt;p&gt;通过阅读 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;man gai.conf&lt;/code&gt;，我了解到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 根据 RFC 3484 实现了目的地址排序，再通过阅读 RFC 的相关内容，我了解到，这个排序会涉及到 10 条规则 (RFC 3484, Chapter 6 Destination Address Selection)。通过反复研究这 10 条规则，以及进行一些测试，我判断比较可能是规则 9 导致的问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Rule 9:  Use longest matching prefix.
When DA and DB belong to the same address family (both are IPv6 or
both are IPv4): If CommonPrefixLen(DA, Source(DA)) &amp;gt;
CommonPrefixLen(DB, Source(DB)), then prefer DA.  Similarly, if
CommonPrefixLen(DA, Source(DA)) &amp;lt; CommonPrefixLen(DB, Source(DB)),
then prefer DB.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么，RFC 3484 是做什么的呢？这个其实在引入 IPv6 之后，对于网络中一个节点，如何选择源地址与目的地址做出了规定。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 因为涉及到网络地址的选择，所以实现了这个标准。你可能有疑问，为什么一个 IPv6 的标准会影响到 IPv4 的网络，这个主要是因为网络总是要过度的，所以在指定标准的过程中就都进行了考虑。这个标准对于 IPv4 源地址的选择没有做规定，这个取决于操作系统的实现，主要还是路由来决定选择哪个源地址。但是规定了目标地址的选择，比如遵守上面提到的 10 条规则。&lt;/p&gt;

&lt;p&gt;为什么我会判断是 Rule 9 导致的问题，主要是结合一下几个方面：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端和服务器的地址在同一个网段，不会收到路由决策的干扰，且全部处于可用状态。&lt;/li&gt;
  &lt;li&gt;操作系统不存在 &lt;em&gt;/etc/gai.conf&lt;/em&gt; 文件，所以不会有 label 和优先级的问题。&lt;/li&gt;
  &lt;li&gt;因为地址都是 IPv4 的私有网段，所以 scope 也都是规定好的，也就没有任何差异。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;阅读-glibc-代码并且进行-gdb&quot;&gt;阅读 glibc 代码并且进行 gdb&lt;/h2&gt;

&lt;p&gt;当然，上面只是推测，还需要证据。接下来，我们要结合代码来找证据，当然，因为时间有限，不太可能仔细研究代码，所以我一般结合代码和调试信息来定位问题。&lt;/p&gt;

&lt;p&gt;glibc 的代码： &lt;em&gt;&lt;a href=&quot;https://sourceware.org/git/glibc.git&quot;&gt;https://sourceware.org/git/glibc.git&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;我们是 CentOS 7.6 的系统，可以在系统上安装 debuginfo 来进行调试：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 会自动安装 glibc 的 debuginfo。
# debuginfo-install iputils-20160308-10.el7.x86_64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后使用 gdb 来辅助代码阅读：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# gdb --args ping -c 1 test.dom
(gdb) b getaddrinfo
Breakpoint 1 at 0x2210
(gdb) run
Starting program: /usr/bin/ping -c 1 test.gfs

Breakpoint 1, __GI_getaddrinfo (name=name@entry=0x7fffffffe666 &quot;test.gfs&quot;, service=service@entry=0x0, hints=hints@entry=0x7fffffffe270, pai=pai@entry=0x7fffffffe248)
    at ../sysdeps/posix/getaddrinfo.c:2208
2208    {
Missing separate debuginfos, use: debuginfo-install libattr-2.4.46-13.el7.x86_64 zlib-1.2.7-18.el7.x86_64
(gdb) b rfc3484_sort
Breakpoint 2 at 0x7ffff6d3df70: file ../sysdeps/posix/getaddrinfo.c, line 1440.
(gdb) c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个时候，我们就进入到了 glibc 这个库中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rfc3484_sort&lt;/code&gt; 这个函数，函数名字取得很好，最终的问题也是由这里导致的。接下来是逐行分析这个函数的逻辑，过程就不细说了，我们来看结论。&lt;/p&gt;

&lt;h2 id=&quot;rfc3484_sort-longest-matching-prefix-实现&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rfc3484_sort&lt;/code&gt; Longest Matching Prefix 实现&lt;/h2&gt;

&lt;p&gt;这个函数的注释很清晰，标明了哪个部分是对应到标准的哪个 rule。通过 gdb 的逐步调试，我们发现，果然是 Rule 9 导致的问题。我们只关心 IPv4 的部分，见下面的代码（代码原始缩进就没对齐）：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 这个函数是用在快排中的 cmp 函数，用来比较两个地址的优先级。
// 函数里的 a1 和 a2 两个变量，会在快排过程中，对应到 DNS 返回的两个地址，比如 192.168.192.127 和 192.168.192.128。
// 函数运行到这里时，源地址已经选择完毕了，就是根据路由选出来的网卡地址，在这个场景中，就是 192.168.192.121。

  /* Rule 9: Use longest matching prefix.  */
  if (a1-&amp;gt;got_source_addr
      &amp;amp;&amp;amp; a1-&amp;gt;dest_addr-&amp;gt;ai_family == a2-&amp;gt;dest_addr-&amp;gt;ai_family)
    {
      int bit1 = 0;
      int bit2 = 0;

      if (a1-&amp;gt;dest_addr-&amp;gt;ai_family == PF_INET)
	{
	  assert (a1-&amp;gt;source_addr.sin6_family == PF_INET);
	  assert (a2-&amp;gt;source_addr.sin6_family == PF_INET);

	  /* Outside of subnets, as defined by the network masks,
	     common address prefixes for IPv4 addresses make no sense.
	     So, define a non-zero value only if source and
	     destination address are on the same subnet.  */
	  struct sockaddr_in *in1_dst
	    = (struct sockaddr_in *) a1-&amp;gt;dest_addr-&amp;gt;ai_addr;
	  in_addr_t in1_dst_addr = ntohl (in1_dst-&amp;gt;sin_addr.s_addr);
	  struct sockaddr_in *in1_src
	    = (struct sockaddr_in *) &amp;amp;a1-&amp;gt;source_addr;
	  in_addr_t in1_src_addr = ntohl (in1_src-&amp;gt;sin_addr.s_addr);
	  in_addr_t netmask1 = 0xffffffffu &amp;lt;&amp;lt; (32 - a1-&amp;gt;prefixlen);

	  // in1_src_addr 就是选择到的源地址，在这个场景里，就是 192.168.192.121
	  // netmask1 和 24 位掩码对应： 0xffffff00
	  // in1_dst_addr 就是参与比较的某个 DNS 响应中的地址。
	  if ((in1_src_addr &amp;amp; netmask1) == (in1_dst_addr &amp;amp; netmask1))
	    // 因为我们的客户端和服务端在同一个子网，所以这个条件会成立。
	    // fls 函数，从左到右找到第一个 1 的位置，最左边是位置 0，最右边是位置 31.
		// 将源地址和目标地址进行 XOR，然后找到第一个 1 的位置。
	    bit1 = fls (in1_dst_addr ^ in1_src_addr);

	  struct sockaddr_in *in2_dst
	    = (struct sockaddr_in *) a2-&amp;gt;dest_addr-&amp;gt;ai_addr;
	  in_addr_t in2_dst_addr = ntohl (in2_dst-&amp;gt;sin_addr.s_addr);
	  struct sockaddr_in *in2_src
	    = (struct sockaddr_in *) &amp;amp;a2-&amp;gt;source_addr;
	  in_addr_t in2_src_addr = ntohl (in2_src-&amp;gt;sin_addr.s_addr);
	  in_addr_t netmask2 = 0xffffffffu &amp;lt;&amp;lt; (32 - a2-&amp;gt;prefixlen);

	  if ((in2_src_addr &amp;amp; netmask2) == (in2_dst_addr &amp;amp; netmask2))
	    bit2 = fls (in2_dst_addr ^ in2_src_addr);
	}
      else if (a1-&amp;gt;dest_addr-&amp;gt;ai_family == PF_INET6)
	{
	  ...
	}

	// 第一个 1 的位置越靠右边，值越小。注意，如果值相等，就不改变位置。
		if (bit1 &amp;gt; bit2)
	return -1;
      if (bit1 &amp;lt; bit2)
	return 1;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以我们的场景来说：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;192.168.192.127 和 192.168.192.128 进行比较：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEX(192.168.192.121) = 0xc0a8c079&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEX(192.168.192.127) = 0xc0a8c07f&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEX(192.168.192.128) = 0xc0a8c080&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;netmask1 = netmask2 = 0xffffff00&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bit1 = fls(in1_dst_addr ^ in1_src_addr) = fls(0xc0a8c07f ^ 0xc0a8c079) = 29&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bit2 = fls(in2_dst_addr ^ in2_src_addr) = fls(0xc0a8c079 ^ 0xc0a8c080) = 24&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bit1 &amp;gt; bit2&lt;/code&gt;，所以 &lt;em&gt;192.168.192.127&lt;/em&gt; 排在 &lt;em&gt;192.168.192.128&lt;/em&gt; 前面。同样，你可以算出 &lt;em&gt;192.168.192.129&lt;/em&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fls(...)&lt;/code&gt; 值为 24，所以它也排在 &lt;em&gt;192.168.192.127&lt;/em&gt; 后面。于是，只要服务端返回是这三个地址，&lt;em&gt;192.168.192.127&lt;/em&gt; 永远排在第一个。&lt;/p&gt;

&lt;h2 id=&quot;构造-dns-轮询不失效的地址&quot;&gt;构造 DNS 轮询不失效的地址&lt;/h2&gt;

&lt;p&gt;把上面的 &lt;em&gt;192.168.192.127&lt;/em&gt; 换成 &lt;strong&gt;192.168.192.130&lt;/strong&gt;，此时，你就会发现，128, 129, 130 这三个地址算出来的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fls(...)&lt;/code&gt; 值都是 24，所以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 不会改变 DNS 响应返回的地址的顺序，&lt;strong&gt;DNS 轮询“神奇“的生效了&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;再看另外一个例子：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端是 10.253.1.14&lt;/li&gt;
  &lt;li&gt;三个服务器是 10.253.1.43, 10.253.1.44, 10.253.1.45&lt;/li&gt;
  &lt;li&gt;DNS 服务器是 10.253.1.46&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用这些地址，你会算出来三个服务器地址的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fls(...)&lt;/code&gt; 都为 26，所以 DNS 轮询又“神奇”的生效了。&lt;/p&gt;

&lt;h1 id=&quot;ref&quot;&gt;Ref&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;https://en.wikipedia.org/wiki/Getaddrinfo&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://access.redhat.com/solutions/22132&quot;&gt;https://access.redhat.com/solutions/22132&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;RedHat 官方对于这个问题的解决方案，其实结论是除非关掉 IPv6，否则无解。所以，无解。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://daniel.haxx.se/blog/2012/01/03/getaddrinfo-with-round-robin-dns-and-happy-eyeballs/&quot;&gt;https://daniel.haxx.se/blog/2012/01/03/getaddrinfo-with-round-robin-dns-and-happy-eyeballs/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jameshfisher.com/2018/02/03/what-does-getaddrinfo-do/&quot;&gt;https://jameshfisher.com/2018/02/03/what-does-getaddrinfo-do/&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;通过 strace 来介绍了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo&lt;/code&gt; 做了什么。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3484.txt&quot;&gt;https://www.ietf.org/rfc/rfc3484.txt&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://lists.debian.org/debian-glibc/2007/09/msg00347.html&quot;&gt;https://lists.debian.org/debian-glibc/2007/09/msg00347.html&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;狂喷 RFC 3484 Rule 9&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;update&quot;&gt;Update&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;2021-10-09: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s/192.168.192.197/192.168.192.127/g&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 08 Oct 2021 00:00:00 +0800</pubDate>
        <link>http://diabloneo.github.io//2021/10/08/DNS-Round-Robin-Fail-and-Longest-Matching-Prefix-Implementation-in-getaddrinfo/</link>
        <guid isPermaLink="true">http://diabloneo.github.io//2021/10/08/DNS-Round-Robin-Fail-and-Longest-Matching-Prefix-Implementation-in-getaddrinfo/</guid>
        
        <category>linux</category>
        
        <category>network</category>
        
        
      </item>
    
  </channel>
</rss>
