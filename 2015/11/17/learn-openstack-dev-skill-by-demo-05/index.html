<!DOCTYPE html>
<html>

  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	
		<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-78067453-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-78067453-1');
</script>

	

	<title>通过demo学习OpenStack开发所需的基础知识 -- API服务(4)</title>
	<meta name="description" content="上一篇文章说到，我们将以实例的形式来继续讲述这个API服务的开发知识，这里会使用Pecan和WSME两个库。">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="/css/main.css">
	<link rel="stylesheet" href="/css/pygments-rainbow_dash.css">
	<link rel="canonical" href="http://diabloneo.github.io//2015/11/17/learn-openstack-dev-skill-by-demo-05/">
	<link rel="alternate" type="application/rss+xml" title="Coffee, Coke and Code" href="http://diabloneo.github.io//feed.xml">
</head>


  <body>
    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Coffee, Coke and Code</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <a class="page-link" href="/tags">Tags</a>
        <a class="page-link" href="/feed.xml">RSS</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">通过demo学习OpenStack开发所需的基础知识 -- API服务(4)</h1>
    <p class="post-meta"><time datetime="2015-11-17T00:00:00+08:00" itemprop="datePublished">Nov 17, 2015</time></p>
  </header>

  <div class="post-tags">
    <ul>
      
      <li>
        <a href="/tags/python/">python</a>
      </li>
      
      <li>
        <a href="/tags/openstack/">openstack</a>
      </li>
      
    </ul>
  </div>

  <div class="post-content" itemprop="articleBody">
    
      <!-- Go to www.addthis.com/dashboard to customize your tools -->
      <div class="addthis_inline_share_toolbox"></div>
    
    <br />
      <p>上一篇文章说到，我们将以实例的形式来继续讲述这个API服务的开发知识，这里会使用Pecan和WSME两个库。</p>

<h2 id="设计rest-api">设计REST API</h2>

<p>要开发REST API服务，我们首先需要设计一下这个服务。设计包括要实现的功能，以及接口的具体规范。我们这里要实现的是一个简单的用户管理接口，包括增删改查等功能。如果读者对REST API不熟悉，可以先从<a href="https://en.wikipedia.org/wiki/Representational_state_transfer">Wiki页面</a>了解一下。</p>

<p>另外，为了方便大家阅读和理解，本系列的代码会放在github上，<a href="https://github.com/diabloneo/webdemo">diabloneo/webdemo</a>。</p>

<h3 id="version-of-rest-api">Version of REST API</h3>

<p>在OpenStack的项目中，都是在URL中表明这个API的版本号的，比如Keystone的API会有<strong>/v2.0</strong>和<strong>/v3</strong>的前缀，表明两个不同版本的API；Magnum项目目前的API则为<strong>v1</strong>版本。因为我们的webdemo项目才刚刚开始，所以我们也把我们的API版本设置为<strong>v1</strong>，下文会说明怎么实现这个version号的设置。</p>

<h3 id="rest-api-of-users">REST API of Users</h3>

<p>我们将要设计一个管理用户的API，这个和Keystone的用户管理的API差不多，这里先列出每个API的形式，以及简要的内容说明。这里我们会把上面提到的version号也加入到URL path中，让读者能更容易联系起来。</p>

<blockquote>
  <p><strong>GET /v1/users</strong> 获取所有用户的列表。</p>

  <p><strong>POST /v1/users</strong> 创建一个用户</p>

  <p><strong>GET /v1/users/&lt;UUID&gt;</strong> 获取一个特定用户的详细信息。</p>

  <p><strong>PUT /v1/users/&lt;UUID&gt;</strong> 修改一个用户的详细信息。</p>

  <p><strong>DELETE /v1/users/&lt;UUID&gt;</strong> 删除一个用户。</p>
</blockquote>

<p>这些就是我们要实现的用户管理的API了。其中， <strong>&lt;UUID&gt;</strong>表示使用一个UUID字符串，这个是OpenStack中最经常被用来作为各种资源ID的形式，如下所示：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>In [5]: import uuid
In [6]: print uuid.uuid4()
adb92482-baab-4832-84bc-f842f3eabd66
In [7]: print uuid.uuid4().hex
29520c88de6b4c76ae8deb48db0a71e7
</code></pre></div></div>

<p>因为是个demo，所以我们设置一个用户包含的信息会比较简单，只包含name和age。</p>

<h2 id="使用pecan搭建api服务的框架">使用Pecan搭建API服务的框架</h2>

<p>接下来就要开始编码工作了。首先要把整个服务的框架搭建起来。我们会在<a href="http://segmentfault.com/a/1190000002940724">软件包管理</a>这篇文件中的代码基础上继续我们的demo（所有这些代码在github的仓库里都能看到）。</p>

<h3 id="代码目录结构">代码目录结构</h3>

<p>一般来说，OpenStack项目中，使用Pecan来开发API服务时，都会在代码目录下有一个专门的API目录，用来保存API相关的代码。比如Magnum项目的<em>magnum/api</em>，或者Ceilometer项目的<em>ceilometer/api</em>等。我们的代码也遵守这个规范，让我们直接来看下我们的代码目录结构（#后面的表示注释）：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ ~/programming/python/webdemo/webdemo/api git:(master) ✗ $ tree .
.
├── app.py           # 这个文件存放WSGI application的入口
├── config.py        # 这个文件存放Pecan的配置
├── controllers/     # 这个目录用来存放Pecan控制器的代码
├── hooks.py         # 这个文件存放Pecan的hooks代码（本文中用不到）
└── __init__.py
</code></pre></div></div>

<p>这个在<a href="http://segmentfault.com/a/1190000003810294">API服务(3)</a>这篇文章中已经说明过了。</p>

<h3 id="先让我们的服务跑起来">先让我们的服务跑起来</h3>

<p>为了后面更好的开发，我们需要先让我们的服务在本地跑起来，这样可以方便自己做测试，看到代码的效果。不过要做到这点，还是有些复杂的。</p>

<h4 id="必要的代码">必要的代码</h4>

<p>首先，先创建config.py文件的内容：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">app</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'root'</span><span class="p">:</span> <span class="s">'webdemo.api.controllers.root.RootController'</span><span class="p">,</span>
    <span class="s">'modules'</span><span class="p">:</span> <span class="p">[</span><span class="s">'webdemo.api'</span><span class="p">],</span>
    <span class="s">'debug'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure>

<p>就是包含了Pecan的最基本配置，其中指定了root controller的位置。然后看下app.py文件的内容，主要就是读取config.py中的配置，然后创建一个WSGI application：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pecan</span>

<span class="kn">from</span> <span class="nn">webdemo.api</span> <span class="kn">import</span> <span class="n">config</span> <span class="k">as</span> <span class="n">api_config</span>


<span class="k">def</span> <span class="nf">get_pecan_config</span><span class="p">():</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">api_config</span><span class="p">.</span><span class="n">__file__</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="s">'.pyc'</span><span class="p">,</span> <span class="s">'.py'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pecan</span><span class="p">.</span><span class="n">configuration</span><span class="p">.</span><span class="n">conf_from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">setup_app</span><span class="p">():</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">get_pecan_config</span><span class="p">()</span>

    <span class="n">app_conf</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">app</span><span class="p">)</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">pecan</span><span class="p">.</span><span class="n">make_app</span><span class="p">(</span>
        <span class="n">app_conf</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'root'</span><span class="p">),</span>
        <span class="n">logging</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="s">'logging'</span><span class="p">,</span> <span class="p">{}),</span>
        <span class="o">**</span><span class="n">app_conf</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">app</span></code></pre></figure>

<p>然后，我们至少还需要实现一下root controller，也就是<em>webdemo/api/controllers/root.py</em>这个文件中的<code class="language-plaintext highlighter-rouge">RootController</code>类：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">pecan</span> <span class="kn">import</span> <span class="n">rest</span>
<span class="kn">from</span> <span class="nn">wsme</span> <span class="kn">import</span> <span class="n">types</span> <span class="k">as</span> <span class="n">wtypes</span>
<span class="kn">import</span> <span class="nn">wsmeext.pecan</span> <span class="k">as</span> <span class="n">wsme_pecan</span>


<span class="k">class</span> <span class="nc">RootController</span><span class="p">(</span><span class="n">rest</span><span class="p">.</span><span class="n">RestController</span><span class="p">):</span>

    <span class="o">@</span><span class="n">wsme_pecan</span><span class="p">.</span><span class="n">wsexpose</span><span class="p">(</span><span class="n">wtypes</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">"webdemo"</span></code></pre></figure>

<h4 id="本地测试服务器">本地测试服务器</h4>

<p>为了继续开放的方便，我们要先创建一个Python脚本，可以启动一个单进程的API服务。这个脚本会放在<em>webdemo/cmd/</em>目录下，名称是<strong>api.py</strong>（这目录和脚本名称也是惯例），来看看我们的api.py吧：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">wsgiref</span> <span class="kn">import</span> <span class="n">simple_server</span>

<span class="kn">from</span> <span class="nn">webdemo.api</span> <span class="kn">import</span> <span class="n">app</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">host</span> <span class="o">=</span> <span class="s">'0.0.0.0'</span>
    <span class="n">port</span> <span class="o">=</span> <span class="mi">8080</span>

    <span class="n">application</span> <span class="o">=</span> <span class="n">app</span><span class="p">.</span><span class="n">setup_app</span><span class="p">()</span>
    <span class="n">srv</span> <span class="o">=</span> <span class="n">simple_server</span><span class="p">.</span><span class="n">make_server</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">application</span><span class="p">)</span>

    <span class="n">srv</span><span class="p">.</span><span class="n">serve_forever</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span></code></pre></figure>

<h4 id="运行测试服务器的环境">运行测试服务器的环境</h4>

<p>要运行这个测试服务器，首先需要安装必要的包，并且设置正确的路径。在后面的文章中，我们将会知道，这个可以通过<strong>tox</strong>这个工具来实现。现在，我们先做个简单版本的，就是手动创建这个运行环境。</p>

<p>首先，完善一下<strong>requirements.txt</strong>这个文件，包含我们需要的包：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pbr&lt;2.0,&gt;=0.11
pecan
WSME
</code></pre></div></div>

<p>然后，我们手动创建一个virtualenv环境，并且安装requirements.txt中要求的包：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ ~/programming/python/webdemo git:(master) ✗ $ virtualenv .venv
New python executable in .venv/bin/python
Installing setuptools, pip, wheel...done.
➜ ~/programming/python/webdemo git:(master) ✗ $ source .venv/bin/activate
(.venv)➜ ~/programming/python/webdemo git:(master) ✗ $ pip install -r requirement.txt
...
Successfully installed Mako-1.0.3 MarkupSafe-0.23 WSME-0.8.0 WebOb-1.5.1 WebTest-2.0.20 beautifulsoup4-4.4.1 logutils-0.3.3 netaddr-0.7.18 pbr-1.8.1 pecan-1.0.3 pytz-2015.7 simplegeneric-0.8.1 singledispatch-3.4.0.3 six-1.10.0 waitress-0.8.10
</code></pre></div></div>

<h4 id="启动我们的服务">启动我们的服务</h4>

<p>启动服务需要技巧，因为我们的webdemo还没有安装到系统的Python路径中，也不在上面创建virtualenv环境中，所以我们需要通过指定<strong>PYTHONPATH</strong>这个环境变量来为Python程序增加库的查找路径：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(.venv)➜ ~/programming/python/webdemo git:(master) ✗ $ PYTHONPATH=. python webdemo/cmd/api.py
</code></pre></div></div>

<p>现在测试服务器已经起来了，可以通过浏览器访问<em>http://localhost:8080/</em> 这个地址来查看结果。（你可能会发现，返回的是XML格式的结果，而我们想要的是JSON格式的。这个是WSME的问题，我们后面再来处理）。</p>

<p>到这里，我们的REST API服务的框架已经搭建完成，并且测试服务器也跑起来了。</p>

<h2 id="用户管理api的实现">用户管理API的实现</h2>

<p>现在我们来实现我们在第一章设计的API。这里先说明一下：<strong>我们会直接使用Pecan的RestController来实现REST API，这样可以不用为每个接口指定接受的method</strong>。</p>

<h3 id="让api返回json格式的数据">让API返回JSON格式的数据</h3>

<p>现在，所有的OpenStack项目的REST API的返回格式都是使用JSON标准，所以我们也要这么做。那么有什么办法能够让WSME框架返回JSON数据呢？可以通过设置<code class="language-plaintext highlighter-rouge">wsmeext.pecan.wsexpose()</code>的<em>rest_content_types</em>参数来是先。这里，我们借鉴一段Magnum项目中的代码，把这段代码存放在文件<em>webdemo/api/expose.py</em>中：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">wsmeext.pecan</span> <span class="k">as</span> <span class="n">wsme_pecan</span>


<span class="k">def</span> <span class="nf">expose</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="s">"""Ensure that only JSON, and not XML, is supported."""</span>
    <span class="k">if</span> <span class="s">'rest_content_types'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s">'rest_content_types'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s">'json'</span><span class="p">,)</span>

    <span class="k">return</span> <span class="n">wsme_pecan</span><span class="p">.</span><span class="n">wsexpose</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code></pre></figure>

<p>这样我们就封装了自己的<code class="language-plaintext highlighter-rouge">expose</code>装饰器，每次都会设置响应的content-type为JSON。上面的root controller代码也就可以修改为：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">pecan</span> <span class="kn">import</span> <span class="n">rest</span>
<span class="kn">from</span> <span class="nn">wsme</span> <span class="kn">import</span> <span class="n">types</span> <span class="k">as</span> <span class="n">wtypes</span>

<span class="kn">from</span> <span class="nn">webdemo.api</span> <span class="kn">import</span> <span class="n">expose</span>


<span class="k">class</span> <span class="nc">RootController</span><span class="p">(</span><span class="n">rest</span><span class="p">.</span><span class="n">RestController</span><span class="p">):</span>

    <span class="o">@</span><span class="n">expose</span><span class="p">.</span><span class="n">expose</span><span class="p">(</span><span class="n">wtypes</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">"webdemo"</span></code></pre></figure>

<p>再次运行我们的测试服务器，就可以返现返回值为JSON格式了。</p>

<h3 id="实现-get-v1">实现 GET /v1</h3>

<p>这个其实就是实现v1这个版本的API的路径前缀。在Pecan的帮助下，我们很容易实现这个，只要按照如下两步做即可：</p>

<ul>
  <li>先实现v1这个controller</li>
  <li>把v1 controller加入到root controller中</li>
</ul>

<p>按照OpenStack项目的规范，我们会先建立一个<em>webdemo/api/controllers/v1/</em>目录，然后将v1 controller放在这个目录下的一个文件中，假设我们就放在<em>v1/controller.py</em>文件中，效果如下:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">pecan</span> <span class="kn">import</span> <span class="n">rest</span>
<span class="kn">from</span> <span class="nn">wsme</span> <span class="kn">import</span> <span class="n">types</span> <span class="k">as</span> <span class="n">wtypes</span>

<span class="kn">from</span> <span class="nn">webdemo.api</span> <span class="kn">import</span> <span class="n">expose</span>


<span class="k">class</span> <span class="nc">V1Controller</span><span class="p">(</span><span class="n">rest</span><span class="p">.</span><span class="n">RestController</span><span class="p">):</span>

    <span class="o">@</span><span class="n">expose</span><span class="p">.</span><span class="n">expose</span><span class="p">(</span><span class="n">wtypes</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">'webdemo v1controller'</span></code></pre></figure>

<p>然后把这个controller加入到root controller中：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="p">...</span>
<span class="kn">from</span> <span class="nn">webdemo.api.controllers.v1</span> <span class="kn">import</span> <span class="n">controller</span> <span class="k">as</span> <span class="n">v1_controller</span>
<span class="kn">from</span> <span class="nn">webdemo.api</span> <span class="kn">import</span> <span class="n">expose</span>


<span class="k">class</span> <span class="nc">RootController</span><span class="p">(</span><span class="n">rest</span><span class="p">.</span><span class="n">RestController</span><span class="p">):</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">v1_controller</span><span class="p">.</span><span class="n">V1Controller</span><span class="p">()</span>

    <span class="o">@</span><span class="n">expose</span><span class="p">.</span><span class="n">expose</span><span class="p">(</span><span class="n">wtypes</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">"webdemo"</span></code></pre></figure>

<p>此时，你访问http://localhost:8080/v1就可以看到结果了。</p>

<h3 id="实现-get-v1users">实现 GET /v1/users</h3>

<h4 id="添加users-controller">添加users controller</h4>

<p>这个API就是返回所有的用户信息，功能很简单。首先要添加users controller到上面的v1 controller中。为了不影响阅读体验，这里就不贴代码了，请看github上的示例代码。</p>

<h4 id="使用wsme来规范api的响应值">使用WSME来规范API的响应值</h4>

<p>上篇文章中，我们已经提到了WSME可以用来规范API的请求和响应的值，这里我们就要用上它。首先，我们要参考OpenStack的惯例来设计这个API的返回值：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "users": [
    {
      "name": "Alice",
      "age": 30
    },
    {
      "name": "Bob",
      "age": 40
    }
  ]
}
</code></pre></div></div>

<p>其中<em>users</em>是一个列表，列表中的每个元素都是一个user。那么，我们要如何使用WSME来规范我们的响应值呢？<strong>答案就是使用WSME的自定义类型</strong>。我们可以利用WSME的类型功能定义出一个user类型，然后再定义一个user的列表类型。最后，我们就可以使用上面的expose方法来规定这个API返回的是一个user的列表类型。</p>

<h5 id="定义user类型和user列表类型">定义user类型和user列表类型</h5>

<p>这里我们需要用到WSME的Complex types的功能，请先看一下文档<a href="http://wsme.readthedocs.org/en/latest/types.html">Types</a>。简单说，就是我们可以把WSME的基本类型组合成一个复杂的类型。我们的类型需要继承自<em>wsme.types.Base</em>这个类。因为我们在本文只会实现一个user相关的API，所以这里我们把所有的代码都放在<em>webdemo/api/controllers/v1/users.py</em>文件中。来看下和user类型定义相关的部分：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">wsme</span> <span class="kn">import</span> <span class="n">types</span> <span class="k">as</span> <span class="n">wtypes</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">wtypes</span><span class="p">.</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">wtypes</span><span class="p">.</span><span class="n">text</span>
    <span class="n">age</span> <span class="o">=</span> <span class="nb">int</span>


<span class="k">class</span> <span class="nc">Users</span><span class="p">(</span><span class="n">wtypes</span><span class="p">.</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">users</span> <span class="o">=</span> <span class="p">[</span><span class="n">User</span><span class="p">]</span></code></pre></figure>

<p>这里我们定义了<code class="language-plaintext highlighter-rouge">class User</code>，表示一个用户信息，包含两个字段，name是一个文本，age是一个整型。<code class="language-plaintext highlighter-rouge">class Users</code>表示一组用户信息，包含一个字段users，是一个列表，列表的元素是上面定义的<code class="language-plaintext highlighter-rouge">class User</code>。完成这些定义后，我们就使用WSME来检查我们的API是否返回了合格的值；另一方面，只要我们的API返回了这些类型，那么就能通过WSME的检查。我们先来完成利用WSME来检查API返回值的代码：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">UsersController</span><span class="p">(</span><span class="n">rest</span><span class="p">.</span><span class="n">RestController</span><span class="p">):</span>

    <span class="c1"># expose方法的第一个参数表示返回值的类型
</span>    <span class="o">@</span><span class="n">expose</span><span class="p">.</span><span class="n">expose</span><span class="p">(</span><span class="n">Users</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></code></pre></figure>

<p>这样就完成了API的返回值检查了。</p>

<h3 id="实现api逻辑">实现API逻辑</h3>

<p>我们现在来完成API的逻辑部分。不过为了方便大家理解，我们直接返回一个写好的数据，就是上面贴出来的那个。</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">UsersController</span><span class="p">(</span><span class="n">rest</span><span class="p">.</span><span class="n">RestController</span><span class="p">):</span>

    <span class="o">@</span><span class="n">expose</span><span class="p">.</span><span class="n">expose</span><span class="p">(</span><span class="n">Users</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">user_info_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s">'name'</span><span class="p">:</span> <span class="s">'Alice'</span><span class="p">,</span>
                <span class="s">'age'</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="s">'name'</span><span class="p">:</span> <span class="s">'Bob'</span><span class="p">,</span>
                <span class="s">'age'</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">]</span>
        <span class="n">users_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">User</span><span class="p">(</span><span class="o">**</span><span class="n">user_info</span><span class="p">)</span> <span class="k">for</span> <span class="n">user_info</span> <span class="ow">in</span> <span class="n">user_info_list</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Users</span><span class="p">(</span><span class="n">users</span><span class="o">=</span><span class="n">users_list</span><span class="p">)</span></code></pre></figure>

<p>代码中，会先根据user信息生成User实例的列表<code class="language-plaintext highlighter-rouge">users_list</code>，然后再生成Users实例。此时，重启测试服务器后，你就可以从浏览器访问http://localhost:8080/v1/users，就能看到结果了。</p>

<h3 id="实现-post-v1users">实现 POST /v1/users</h3>

<p>这个API会接收用户上传的一个JSON格式的数据，然后打印出来（实际中一般是存到数据库之类的），要求用户上传的数据符合User类型的规范，并且返回的状态码为201。代码如下：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">UsersController</span><span class="p">(</span><span class="n">rest</span><span class="p">.</span><span class="n">RestController</span><span class="p">):</span>

    <span class="o">@</span><span class="n">expose</span><span class="p">.</span><span class="n">expose</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">body</span><span class="o">=</span><span class="n">User</span><span class="p">,</span> <span class="n">status_code</span><span class="o">=</span><span class="mi">201</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">user</span></code></pre></figure>

<p>可以使用curl程序来测试：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ~/programming/python/webdemo git:(master) ✗ $ curl -X POST http://localhost:8080/v1/users -H "Content-Type: application/json" -d '{"name": "Cook", "age": 50}' -v
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 8080 (#0)
&gt; POST /v1/users HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.43.0
&gt; Accept: */*
&gt; Content-Type: application/json
&gt; Content-Length: 27
&gt;
* upload completely sent off: 27 out of 27 bytes
* HTTP 1.0, assume close after body
&lt; HTTP/1.0 201 Created
&lt; Date: Mon, 16 Nov 2015 15:18:24 GMT
&lt; Server: WSGIServer/0.1 Python/2.7.10
&lt; Content-Length: 0
&lt;
* Closing connection 0
</code></pre></div></div>

<p>同时，服务器上也会打印出：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1 - - [16/Nov/2015 23:16:28] "POST /v1/users HTTP/1.1" 201 0
&lt;webdemo.api.controllers.v1.users.User object at 0x7f65e058d550&gt;
</code></pre></div></div>

<p>我们用3行代码就实现了这个POST的逻辑。现在来说明一下这里的秘密。<code class="language-plaintext highlighter-rouge">expose</code>装饰器的第一个参数表示这个方法没有返回值；第三个参数表示这个API的响应状态码是201，如果不加这个参数，在没有返回值的情况下，默认会返回204。第二个参数要说明一下，这里用的是<code class="language-plaintext highlighter-rouge">body=User</code>，你也可以直接写<code class="language-plaintext highlighter-rouge">User</code>。使用<code class="language-plaintext highlighter-rouge">body=User</code>这种形式，你可以直接发送符合User规范的JSON字符串；如果是用<code class="language-plaintext highlighter-rouge">expose(None, User, status_code=201)</code>那么你需要发送下面这样的数据：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ "user": {"name": "Cook", "age": 50} }
</code></pre></div></div>
<p>你可以自己测试一下区别。要更多的了解本节提到的expose参数，请参考WSM文档<a href="http://wsme.readthedocs.org/en/latest/functions.html">Functions</a>。</p>

<p>最后，你接收到一个创建用户请求时，一般会为这个用户分配一个id。本文前面已经提到了OpenStack项目中一般使用UUID。你可以修改一下上面的逻辑，为每个用户分配一个UUID。</p>

<h3 id="实现-get-v1users-1">实现 GET /v1/users/<UUID></UUID></h3>

<p>要实现这个API，需要两个步骤：</p>

<ol>
  <li>在UsersController中解析出<UUID>的部分，然后把请求传递给这个一个新的UserController。从命名可以看出，UsersController是针对多个用户的，UserController是针对一个用户的。</UUID></li>
  <li>在UserController中实现<code class="language-plaintext highlighter-rouge">get()</code>方法。</li>
</ol>

<h4 id="使用_lookup方法">使用_lookup()方法</h4>

<p>Pecan的<code class="language-plaintext highlighter-rouge">_lookup()</code>方法是controller中的一个特殊方法，Pecan会在特定的时候调用这个方法来实现更灵活的URL路由。Pecan还支持用户实现<code class="language-plaintext highlighter-rouge">_default()</code>和<code class="language-plaintext highlighter-rouge">_route()</code>方法。这些方法的具体说明，请阅读Pecan的文档：<a href="https://pecan.readthedocs.org/en/latest/routing.html">routing</a>。</p>

<p>我们这里只用到<code class="language-plaintext highlighter-rouge">_lookup()</code>方法，这个方法会在controller中没有其他方法可以执行且没有<code class="language-plaintext highlighter-rouge">_default()</code>方法的时候执行。比如上面的UsersController中，没有定义*/v1/users/<UUID>*如何处理，它只能返回404；如果你定义了`_lookup()`方法，那么它就会调用该方法。</UUID></p>

<p><code class="language-plaintext highlighter-rouge">_lookup()</code>方法需要返回一个元组，元组的第一个元素是下一个controller的实例，第二个元素是URL path中剩余的部分。</p>

<p>在这里，我们就需要在<code class="language-plaintext highlighter-rouge">_lookup()</code>方法中解析出UUID的部分并传递给新的controller作为新的参数，并且返回剩余的URL path。来看下代码：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">UserController</span><span class="p">(</span><span class="n">rest</span><span class="p">.</span><span class="n">RestController</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>


<span class="k">class</span> <span class="nc">UsersController</span><span class="p">(</span><span class="n">rest</span><span class="p">.</span><span class="n">RestController</span><span class="p">):</span>

    <span class="o">@</span><span class="n">pecan</span><span class="p">.</span><span class="n">expose</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="o">*</span><span class="n">remainder</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">UserController</span><span class="p">(</span><span class="n">user_id</span><span class="p">),</span> <span class="n">remainder</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">_lookup()</code>方法的形式为<code class="language-plaintext highlighter-rouge">_lookup(self, user_id, *remainder)</code>，意思就是会把/v1/users/<UUID>中的<UUID>部分作为user_id这个参数，剩余的按照**"/"**分割为一个数组参数（这里remainder为空）。然后，`_lookup()`方法里会初始化一个UserController实例，使用user_id作为初始化参数。这么做之后，这个初始化的控制器就能知道是要查找哪个用户了。然后这个控制器会被返回，作为下一个控制被调用。请求的处理流程就这么转移到UserController中了。</UUID></UUID></p>

<h4 id="实现api逻辑-1">实现API逻辑</h4>

<p>实现前，我们要先修改一下我们返回的数据，里面需要增加一个id字段。对应的User定义如下：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">wtypes</span><span class="p">.</span><span class="n">Base</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">wtypes</span><span class="p">.</span><span class="n">text</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">wtypes</span><span class="p">.</span><span class="n">text</span>
    <span class="n">age</span> <span class="o">=</span> <span class="nb">int</span></code></pre></figure>

<p>现在，完整的UserController代码如下：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">UserController</span><span class="p">(</span><span class="n">rest</span><span class="p">.</span><span class="n">RestController</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>

    <span class="o">@</span><span class="n">expose</span><span class="p">.</span><span class="n">expose</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">user_info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">'id'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span>
            <span class="s">'name'</span><span class="p">:</span> <span class="s">'Alice'</span><span class="p">,</span>
            <span class="s">'age'</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">User</span><span class="p">(</span><span class="o">**</span><span class="n">user_info</span><span class="p">)</span></code></pre></figure>

<p>使用curl来检查一下效果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ ~/programming/python/webdemo git:(master) ✗ $ curl http://localhost:8080/v1/users/29520c88de6b4c76ae8deb48db0a71e7
{"age": 30, "id": "29520c88de6b4c76ae8deb48db0a71e7", "name": "Alice"}
</code></pre></div></div>

<h4 id="定义wsme类型的技巧">定义WSME类型的技巧</h4>

<p>你可能会有疑问：这里我们修改了User类型，增加了一个id字段，那么前面实现的<em>POST /v1/users</em>会不会失效呢？你可以自己测试一下。（答案是不会，因为这个类型里的字段都是可选的）。这里顺便讲两个技巧。</p>

<p><strong>如何设置一个字段为强制字段</strong></p>

<p>像下面这样做就可以了（你可以测试一下，改成这样后，不传递id的<em>POST /v1/users</em>会失败）：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">wtypes</span><span class="p">.</span><span class="n">Base</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">wtypes</span><span class="p">.</span><span class="n">wsattr</span><span class="p">(</span><span class="n">wtypes</span><span class="p">.</span><span class="n">text</span><span class="p">,</span> <span class="n">mandatory</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">wtypes</span><span class="p">.</span><span class="n">text</span>
    <span class="n">age</span> <span class="o">=</span> <span class="nb">int</span></code></pre></figure>

<p><strong>如何检查一个可选字段的值是否存在</strong></p>

<p>检查这个值是否为None是肯定不行的，需要检查这个值是否为<strong>wsme.Unset</strong>。</p>

<h3 id="实现-put-v1users">实现 PUT /v1/users/<UUID></UUID></h3>

<p>这个和上一个API一样，不过<code class="language-plaintext highlighter-rouge">_lookup()</code>方法已经实现过了，直接添加方法到UserController中即可：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">UserController</span><span class="p">(</span><span class="n">rest</span><span class="p">.</span><span class="n">RestController</span><span class="p">):</span>

    <span class="o">@</span><span class="n">expose</span><span class="p">.</span><span class="n">expose</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">body</span><span class="o">=</span><span class="n">User</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
        <span class="n">user_info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">'id'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span>
            <span class="s">'name'</span><span class="p">:</span> <span class="n">user</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s">'age'</span><span class="p">:</span> <span class="n">user</span><span class="p">.</span><span class="n">age</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">User</span><span class="p">(</span><span class="o">**</span><span class="n">user_info</span><span class="p">)</span></code></pre></figure>

<p>通过curl来测试：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜ ~/programming/python/webdemo git:(master) ✗ $ curl -X PUT http://localhost:8080/v1/users/29520c88de6b4c76ae8deb48db0a71e7 -H "Content-Type: application/json" -d '{"name": "Cook", "age": 50}'
{"age": 51, "id": "29520c88de6b4c76ae8deb48db0a71e7", "name": "Cook"}% 
</code></pre></div></div>

<h3 id="实现-delete-v1users">实现 DELETE /v1/users/<UUID></UUID></h3>

<p>同上，没有什么新的内容：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">UserController</span><span class="p">(</span><span class="n">rest</span><span class="p">.</span><span class="n">RestController</span><span class="p">):</span>

    <span class="o">@</span><span class="n">expose</span><span class="p">.</span><span class="n">expose</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">'Delete user_id: %s'</span> <span class="o">%</span> <span class="bp">self</span><span class="p">.</span><span class="n">user_id</span></code></pre></figure>

<h2 id="总结">总结</h2>

<p>到此为止，我们已经完成了我们的API服务了，虽然没有实际的逻辑，但是本文搭建起来的框架也是OpenStack中API服务的一个常用框架，很多大项目的API服务代码都和我们的webdemo长得差不多。最后再说一下，本文的代码在github上托管着：<a href="https://github.com/diabloneo/webdemo">diabloneo/webdemo</a>。</p>

<p>现在我们已经了解了包管理和API服务了，那么接下来就要开始数据库相关的操作了。大部分OpenStack的项目都是使用非常著名的sqlalchemy库来实现数据库操作的，本系列接下来的文章就是要来说明数据库的相关知识和应用。</p>


    <br />

    <div>
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。
    </div>

    <br />
    
      <!-- Go to www.addthis.com/dashboard to customize your tools -->
      <div class="addthis_inline_share_toolbox"></div>
    
  </div>

  
    <div class="post-comment">
      
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
  this.page.url = "http://diabloneo.github.io/2015/11/17/learn-openstack-dev-skill-by-demo-05/"; // <--- use canonical URL
  this.page.identifier = "/2015/11/17/learn-openstack-dev-skill-by-demo-05";
};
(function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');

  s.src = 'https://coffee-coke-and-code.disqus.com/embed.js';

  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


    </div>
  

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Coffee, Coke and Code</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Coffee, Coke and Code</li>
          <li><a href="mailto:diabloneo@gmail.com">diabloneo@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <i class="fa fa-github"></i>
            <a href="https://github.com/diabloneo">
              <span class="username">diabloneo</span>
            </a>
          </li>
          

          
          <li>
            <i class="fa fa-twitter"></i>
            <a href="https://twitter.com/diabloneo">
              <span class="username">diabloneo</span>
            </a>
          </li>
          

          
          <li>
            <i class="fa fa-weibo"></i>
            <a href="https://weibo.com/diabloneo">
              <span class="username">diabloneo</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Archive diabloneo's articles.
</p>
      </div>
    </div>

  </div>

</footer>

    
      <!-- Go to www.addthis.com/dashboard to customize your tools -->
      <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-59e59696a86877c1"></script> 
    
  </body>

</html>
